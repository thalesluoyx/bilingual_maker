
# Foreword  
#### 致未来的Principal Engineer，苟富贵勿相忘。_-- ThalesLuo_

# Preface  

Sun Java Center and the J2EE Pattern Catalog   
What This Book is About?   
What This Book Is Not?   
Who Should Read this Book?   
How This Book is Organized   
Companion Website and Contact Information  

Sun Java中心与J2EE模式目录  
本书内容  
本书不涉及的内容  
目标读者  
本书结构  
配套网站与联系方式

Acknowledgments  

致谢

# I: PATTERNS AND J2EE  

# 1. INTRODUCTION  

What Is J2EE ?   
What Are Patterns?   
J2EE Pattern Catalog   
Patterns, Frameworks, and Reuse   
Summary  

什么是J2EE？  
什么是模式？  
J2EE模式目录  
模式、框架与复用  
总结

# 2. J2EE PLATFORM OVERVIEW  

A Brief Perspective   
J2EE Platform   
J2EE Patterns and J2EE Platform   
Summary  

简明视角  
J2EE平台  
J2EE模式与J2EE平台  
总结

II: DESIGN CONSIDERATIONS, BAD PRACTICES, AND REFACTORINGS  

二：设计考量、不良实践与重构

3. PRESENTATION TIER DESIGN CONSIDERATIONS AND BAD PRACTICES Presentation Tier Design Considerations Presentation Tier Bad Practices  

3. 表示层设计考量与不良实践  
表示层设计考量  
表示层不良实践

4. BUSINESS TIER DESIGN CONSIDERATIONS AND BAD PRACTICES Business Tier Design Considerations Business and Integration Tiers Bad Practices  

4. 业务层设计考量与不良实践  
业务层设计考量  
业务与集成层不良实践

# 5. J2EE REFACTORINGS  

Presentation Tier Refactorings Business and Integration Tier Refactorings General Refactorings  

表现层重构 业务与集成层重构 通用重构

III: J2EE PATTERN CATALOG  

III: J2EE 模式目录

Part 3 includes the following four chapters:  

第三部分包含以下四个章节：

# 6. J2EE PATTERNS OVERVIEW  

What Is a Pattern?   
Identifying a Pattern   
The Tiered Approach   
J2EE Patterns   
Guide to the Catalog   
J2EE Pattern Relationships   
Relationship to Known Patterns   
Patterns Roadmap   
Summary  

什么是模式？  
识别模式  
分层架构方法  
J2EE模式  
目录指南  
J2EE模式关联  
与已知模式的关系  
模式路线图  
总结

# 7. PRESENTATION TIER PATTERNS  

Intercepting Filter Front Controller View Helper Consequences Related Patterns Composite View Service to Worker Dispatcher View  

拦截过滤器 前端控制器 视图助手 相关模式影响 组合视图 服务到工作者 分发器视图

# 8. BUSINESS TIER PATTERNS  

Business Delegate Value Object Session Facade Composite Entity Value Object Assembler Value List Handler Service Locator  

业务委托 值对象 会话门面 组合实体 值对象组装器 值列表处理器 服务定位器

# 9. INTEGRATION TIER PATTERNS  

Data Access Object Service Activator  

数据访问对象服务激活器

# Epilogue J2EE PATTERNS APPLIED  

PSA Overview   
Use Case Model   
Use Cases, Patterns, and Pattern Frameworks   
Create Project Use Case   
Reserve Resource Use Case   
Find Available Resources Use Case  

PSA 概述  
用例模型  
用例、模式与模式框架  
创建项目用例  
预留资源用例  
查找可用资源用例

# BIBLIOGRAPHY  

# Foreword  

In the world of software, a pattern is a tangible manifestation of an organization's tribal memory. A pattern provides a common solution to a common problem and so, within the culture of one specific organization or within one domain, naming and then specifying a pattern represents the codification of a common solution, drawn from proven, prior experience. Having a good language of patterns at your disposal is like having an extended team of experts sitting at your side during development: by applying one of their patterns, you in effect take the benefit of their hard-won knowledge. As such, the best patterns are not so much invented as they are discovered and then harvested from existing, successful systems. Thus, at its most mature state, a pattern is full of things that work, absent of things that don't work, and revealing of the wisdom and rationale of its designers.  

在软件领域，**模式**是一个组织集体记忆的具体体现。模式为常见问题提供通用解决方案，因此在特定组织文化或领域内，对模式进行命名和规范即意味着将经过实践验证的通用方案进行编码化。掌握一套完善的模式语言，就如同在开发过程中拥有一个专家智囊团：通过应用这些模式，你实际上汲取了他们来之不易的经验。因此，最优秀的模式往往并非被发明，而是从现有成功系统中发掘并提炼而来。当模式发展到最成熟阶段时，它凝聚了行之有效的实践，剔除了无效元素，并展现出设计者的智慧与决策逻辑。

Deep, really useful, patterns are typically ancient: you see one and will often remark, “Hey, I've done that before.” However, the very naming of the pattern gives you a vocabulary that you didn't have previously and so helps you apply that pattern in ways you otherwise might have not have realized. Ultimately, the effect of such a pattern will be to make your system simpler.  

真正深刻且实用的模式往往源远流长：当你遇到时，常会感叹"这方法我用过"。但模式的命名本身提供了你过去缺乏的术语体系，从而让你能以未曾意识到的方式应用该模式。最终，这类模式会让你的系统变得更简洁。

Patterns not only help you build simpler systems that work, but they also help you build beautiful programs. In a culture of time starvation, writing beautiful software is often impossible. That's sad, for as professionals, we strive to build things of quality. By applying a good set of patterns, it is possible to bring a degree of elegance in to your systems that might otherwise have been lacking.  

模式不仅能帮助构建更简洁且可运行的系统，还能助力打造优雅的程序。在时间匮乏的文化氛围中，编写优美的软件往往难以实现。这令人遗憾，因为作为专业人士，我们追求构建高质量的产物。通过运用一套优秀的模式，可以为系统注入原本可能缺失的优雅特质。

The authors of Core J2EE Patterns have harvested a really useful set of patterns. Don't get me wrong: J2EE is certainly an important platform, enabling teams to build some very powerful systems. However, reality is, there is still a wide semantic gap between the abstractions and services that J2EE provides and the final application that a team must build. Patterns such as specified in this book represent solutions that appear again and again in filling that gap. By applying these patterns, you thus carry out the primary means of reducing software risk: you write less software. Rather than discovering these solutions on your own, apply these patterns, which have already proven their utility in existing systems.  

《Core J2EE模式》的作者们提炼出了一套极具实用价值的模式体系。需要澄清的是：J2EE无疑是一个重要平台，它使团队能够构建非常强大的系统。但现实情况是，J2EE提供的抽象与服务与团队最终必须构建的应用程序之间仍存在巨大的语义鸿沟。本书所阐述的模式正是填补这一鸿沟的重复出现的解决方案。通过应用这些模式，您实际上践行了降低软件风险的核心原则：减少代码编写量。与其自行探索这些解决方案，不如直接应用这些已在现有系统中验证过实用性的模式。

More than just naming a set of patterns, the authors make them approachable by specifying their semantics using the UML.  

作者不仅命名了一系列模式，更通过UML规范其语义，使其更易于理解。

Additionally, they show you how to apply these patterns and how to refactor your system to take advantage of them. Again, it's just like having a team of experts sitting at your side.  

此外，书中还展示了如何应用这些模式以及如何重构系统以充分利用它们。这就像有一支专家团队坐在你身边指导一样。

Grady Booch   
Chief Scientist   
Rational Software Corporation  

Grady Booch  
首席科学家  
Rational Software 公司

# Preface  

This book is about patterns for the Java 2 platform, Enterprise Edition (J2EE). These J2EE patterns provide solutions for problems typically encountered by designers of software applications for the J2EE platform. All the patterns documented in the catalog have been discovered in the field, where they have been used to create successful J2EE applications for our customers.  

本书聚焦于Java 2平台企业版（J2EE）的设计模式。这些J2EE模式为平台软件应用设计者常见的问题提供了解决方案。模式目录中记载的所有模式均来自实战经验，它们曾成功应用于为客户构建的J2EE应用程序中。

This book describes proven solutions for the J2EE platform with a particular emphasis on such key J2EE technologies as: Java Server Pages (JSP), Servlets, Enterprise JavaBeans (EJB) components, Java Message Service (JMS), JDBC, and Java Naming and Directory Interface (JNDI). We offer solutions for recurring problems for the J2EE platform through the J2EE Pattern Catalog and J2EE refactorings. You can apply these ideas when developing new systems or when improving the design of existing systems. The patterns in this book will help you quickly gain the proficiency and skills to build robust, efficient enterprise applications.  

本书详细阐述了J2EE平台的成熟解决方案，重点聚焦以下核心J2EE技术：Java Server Pages (JSP)、Servlet、Enterprise JavaBeans (EJB)组件、Java消息服务(JMS)、JDBC以及Java命名与目录接口(JNDI)。我们通过J2EE模式目录和J2EE重构技术，为J2EE平台的常见问题提供解决方案。这些方案既适用于新系统开发，也可用于改进现有系统设计。书中模式将助您快速掌握构建健壮高效企业级应用的技能。

Today, as in the past, many of us naively assume that learning a technology is synonymous with learning to design with the technology. Certainly learning the technology is an important part to being successful in designing with the technology. Many existing Java books are excellent at explaining technology details, such as API specifics and so forth, but at the same time they give no insight on applying the technology. Learning to design comes from experience and from sharing knowledge on best practices and bad practices.  

时至今日，我们许多人仍天真地认为学习某项技术等同于学习用该技术进行设计。诚然，掌握技术本身是成功运用其进行设计的重要前提。现有的大量Java书籍虽能出色阐释技术细节（如API规范等），却鲜少揭示如何实际应用这些技术。设计能力的培养源于实践经验，以及关于最佳实践和错误实践的智慧共享。

The experiences we have conveyed in this book are derived from the work we have done in the field. We are part of Sun Microsystems, Inc.'s Sun Java Center (SJC) consulting organization. In our work, we often encounter situations where, because technology is moving so quickly, designers and developers are still struggling to understand the technology, let alone how to design with the technology.  

本书所阐述的经验源自我们在该领域的实践成果。作为Sun Microsystems公司Sun Java中心（SJC）咨询团队的一员，我们在工作中经常遇到这样的情形：由于技术迭代速度过快，设计者和开发者仍在艰难消化技术本身，更遑论运用这些技术进行架构设计。

It is not good enough to tell designers and developers to write good code, nor is it sufficient to suggest using Servlets and JSP for developing the presentation tier and EJB components[1] for developing the business tier.  

仅告诉设计者和开发者编写优质代码是不够的，仅建议使用 **Servlet** 和 **JSP** 开发表示层、用 **EJB 组件**[1] 开发业务层也远非充分方案。  

[1] 译者注：EJB (Enterprise JavaBeans) 组件

# Sun Java Center and the J2EE Pattern Catalog  

Since its inception, SJC architects have been working with clients all over the world to successfully design, architect, build, and deploy various types of systems based on Java and J2EE. The SJC is a rapidly growing consulting organization constantly adding new hires to its ranks of experienced architects.  

自成立以来，SJC架构师团队始终与全球客户合作，基于Java和J2EE技术成功设计、架构、构建并部署各类系统。SJC作为快速发展的咨询机构，持续吸纳新成员加入其经验丰富的架构师队伍。

Recognizing the need to capture and share proven designs and architectures, we started to document our work on the J2EE platform in the form of patterns in 1999. Although we looked in the existing literature, we could not find a catalog of patterns that dealt specifically with the J2EE platform. We found many books dealing with one or more of the J2EE technologies, and these books do an excellent job of explaining the technology and unraveling the nuances of the specifications. Some books offered extra help by providing some design considerations.  

意识到需要记录和分享经过验证的设计与架构，我们于1999年开始以模式的形式记录在J2EE平台上的工作成果。尽管查阅了现有文献，但未能找到专门针对J2EE平台的模式目录。我们发现许多书籍涉及一项或多项J2EE技术，这些书籍在技术解析和规范细节阐释方面表现卓越。部分书籍还通过提供设计考量事项提供了额外帮助。

Since we first publicly presented our ideas on J2EE patterns at the JavaOne Conference in June 2000, we have received an overwhelming response from architects and developers. While some individuals expressed great interest in learning more about the patterns, others confirmed that they had applied the patterns, but had never named or documented them. This interest in patterns for the J2EE platform further motivated us to continue our work.  

自2000年6月在JavaOne大会上首次公开提出J2EE模式理念以来，我们收到了来自架构师和开发人员的强烈反响。部分人士表现出深入学习这些模式的浓厚兴趣，另一些则证实他们早已应用了这些模式，但从未对其进行命名或文档化。这种对J2EE平台模式的关注，进一步推动了我们持续开展相关研究工作。

Thus, we put together the J2EE Pattern Catalog., which was initially made available to the entire J2EE community in beta form via the Java Developer Connection in March, 2001. Based largely on community feedback, the beta documentation evolved into the release you see in this book.  

因此，我们整合了《J2EE模式目录》，该目录最初于2001年3月通过Java开发者社区以测试版形式向整个J2EE社区开放。基于大量社区反馈，测试版文档最终演变为本书呈现的正式版本。

We hope these patterns, best practices, strategies, bad practices, and refactorings for the J2EE platform, provide the same benefits to you as they do for us.  

我们希望这些针对J2EE平台的模式、最佳实践、策略、反面案例和重构方案，能为您带来与我们同等的价值。

# What This Book is About?  

This book is about:  

本书涵盖以下内容：

Using patterns for the J2EE Platform.  

运用J2EE平台的设计模式

Based on our collective J2EE platform experience, we have assembled the pattern catalog in this book. The J2EE Pattern Catalog describes various best practices related to architecting and designing applications for the J2EE platform. This book focuses on the following four J2EE technologies: Servlets, JSP, EJB components, and JMS.  

基于我们在J2EE平台上的集体经验，我们编纂了本书的模式目录。该J2EE模式目录阐述了与J2EE平台应用架构和设计相关的多种最佳实践。本书重点聚焦以下四项J2EE技术：Servlet、JSP、EJB组件及JMS。

Using best practices to design applications that use JSP, Servlet, EJB components, and JMS technologies.  

运用最佳实践设计基于JSP、Servlet、EJB组件及JMS技术的应用程序。

It is not sufficient to merely learn the technology and the APIs. It is equally important to learn to design with the technology. We have documented what we have experienced to be the best practices for these technologies.  

仅学习技术和API是不够的，掌握如何运用技术进行设计同样重要。我们已将实践证明的最佳实践整理成文档。

• Preventing re-inventing-the-wheel when it comes to design and architecture for the J2EE platform.  

• 避免在J2EE平台的设计与架构层面重复造轮子。

Patterns promote design reuse. Reusing known solutions reduces the cycle time for designing and developing applications, including J2EE applications.  

模式促进设计复用。重用已知解决方案可缩短设计和开发应用程序（包括J2EE应用程序）的周期时间。

Identifying bad practices in existing designs and refactoring these designs to move to a better solution using the J2EE patterns.  

识别现有设计中的不良实践，并运用J2EE模式重构这些设计以转向更优解决方案。

Knowing what works well is good. Knowing what does not work is equally important. We have documented some of the bad practices we have experienced when designing applications for the J2EE platform.  

了解哪些实践行之有效固然重要，但识别哪些实践存在问题同样关键。我们在为J2EE平台设计应用程序的过程中，已将部分亲身经历的不良实践记录在案。

# What This Book Is Not?  

This book is not about:  

本书不涉及以下内容：

How to program with Java or J2EE technologies  

如何使用Java或J2EE技术进行编程

This book is not about programming. While this book is heavily based on the J2EE technologies, we do not describe the specific APIs. If you wish to learn about programming using Java or using any of the J2EE technologies, there are a number of excellent books and online resources from which to learn. The online tutorials on the official Java home page at http://java.sun.com are highly recommended if you wish to learn about individual technologies. The official specifications for J2EE technologies are also available from the Java home page.  

本书并非编程指南。尽管内容深度依托J2EE技术体系，但不会涉及具体API的讲解。若需学习Java编程或J2EE技术实践，现有大量优质书籍和网络资源可供参考。推荐访问Java官方网站http://java.sun.com的在线教程以掌握单项技术细节，该站点同时提供完整的J2EE技术规范文档。

What process and methodology to use  

采用何种流程与方法论

We do not suggest any type of process or methodology to use since the material presented in this book is not related to either. Hence, this book does not teach you about a process or methodology to follow in your projects. If you would like to learn more about processes and methodologies, there are a good number of books that deal with various object-oriented methodologies and new books on lightweight processes, such as Extreme Programming.  

本书所呈现的内容与具体流程或方法论无关，因此我们不会推荐任何类型的开发流程或方法论。换言之，本书不会指导您在项目中遵循特定的流程或方法论。若您希望深入了解流程与方法论，市面上有大量探讨各类面向对象方法论的书籍，以及关于轻量级流程（如极限编程）的新著作可供参考。

How to use Unified Modeling Language (UML)  

如何使用统一建模语言（UML）

This book is not going to teach you about UML. We use UML extensively (specifically class and sequence diagrams) to document the patterns and describe the static and dynamic interactions. If you want to learn more about UML, please refer to the UML User Guide [Booch] and the UML Reference Manual [Rumbaugh] by Grady Booch, Ivar Jacobson and James Rumbaugh.  

本书不会教授UML相关知识。我们广泛采用UML（特别是类图和时序图）来记录模式并描述静态与动态交互。如需深入学习UML，请参阅Grady Booch、Ivar Jacobson和James Rumbaugh所著的《UML用户指南》[Booch]与《UML参考手册》[Rumbaugh]。

# Who Should Read this Book?  

This book is for all J2EE enthusiasts, programmers, architects, developers, and technical managers. In short, anyone who is remotely interested in designing, architecting and developing applications for the J2EE platform.  

本书面向所有J2EE爱好者、程序员、架构师、开发人员和技术管理者。简而言之，任何对J2EE平台应用设计、架构和开发感兴趣的人士皆可从中获益。

We have attempted to distinguish this book as a training guide for J2EE architects and designers. We all recognize the importance of good designs and well-architected projects, and that we need good architects to get there.  

我们致力于将本书打造为面向J2EE架构师和设计者的专业培训指南。众所周知，优秀的设计与良好的架构对项目至关重要，而达成这一目标离不开卓越的架构师。

The use of well-documented patterns, best practices, and bad practices to share and transfer knowledge and experience can prove invaluable for teams with varied experience levels, and we hope that this book answers some of these needs.  

采用良好文档化的模式、最佳实践和反面案例来共享与传递知识经验，对于经验水平各异的团队而言极具价值，我们希望本书能满足这些需求。

# How This Book is Organized  

This book is organized into three parts.  

本书分为三大部分。

Part 1—“Patterns and J2EE”, consists of Chapter 1 and Chapter 2.  

第一部分——“模式与J2EE”，包含第1章和第2章。

Chapter 1: “Introduction” is a brief discussion on various topics, including patterns, J2EE platform, defining a pattern, and pattern categorization. It ends by introducing the J2EE Pattern Catalog.  

第1章：“引言”简要讨论了多个主题，包括模式、J2EE平台、模式定义以及模式分类，最后介绍了J2EE模式目录。

Chapter 2 : “J2EE Platform Overview” provides a high level overview of the J2EE platform for those readers unfamiliar with J2EE, or who wish to refresh their knowledge of the J2EE platform.  

第2章：“J2EE平台概述”为不熟悉J2EE或希望重温J2EE平台知识的读者提供了该平台的高层次概述。

Part 2—“Design Considerations, Bad Practices, and Refactorings” deals with design considerations for JSP, Servlets, and enterprise beans. This part also includes bad practices and refactorings for the J2EE platform. This part is comprised of Chapter 3, 4, and 5.  

第二部分——“设计考量、不良实践与重构”聚焦于JSP、Servlet及企业级Bean的设计考量，同时涵盖J2EE平台的不良实践与重构方案。该部分由第3、4、5章组成。

Chapter 3 “Presentation Tier Design Considerations and Bad Practices” and Chapter 4 “Business Tier Design Considerations and Bad Practices” discuss the design considerations and bad practices for the presentation tier and business/integration tiers respectively. The design considerations are issues that a J2EE developer/designer/architect needs to consider while working with the J2EE  

第3章“表示层设计考量与不良实践”和第4章“业务层设计考量与不良实践”分别讨论了表示层及业务/集成层的设计考量与不良实践。这些设计考量是J2EE开发人员/设计师/架构师在使用J2EE时需要重点考虑的问题。

platform. The topics presented in these chapters point the reader to other sources (such as official specifications and well written books on these topics) for more detailed information on these issues.  

平台。这些章节所介绍的主题会引导读者查阅其他资料（例如官方规范和相关领域的优秀著作）以获取更详细的信息。

Chapter 5: “J2EE Refactorings” includes some of the refactorings we have experienced in our work in the field that has enabled us to move our design from a less optimal solution to a better solution. The refactorings provide another way to think about the material in the rest of the book, providing what we believe to be valuable companion material to the pattern catalog. This chapter shows how we have been influenced by Martin Fowler and his book "Refactoring" [Fowler]. For those readers who are familiar with the Refactoring book, the format of this chapter will be very familiar. However, the content of this chapter is entirely in the context of J2EE technologies, whereas Martin Fowler addresses refactoring at a different level.  

第5章《J2EE重构实践》收录了我们在实际工作中总结的重构案例，这些重构帮助我们实现了从次优设计到更优设计的演进。本章内容为本书其他章节的架构模式提供了另一种思考维度，我们相信这些重构案例将成为模式目录极具价值的补充材料。本章体现了Martin Fowler及其著作《重构》[Fowler]对我们的深远影响。熟悉《重构》一书的读者会立即认出本章的编排体例。但需要特别说明的是，本章所有重构案例均基于J2EE技术栈的特定语境，而Martin Fowler探讨的重构则处于不同的抽象层次。

Part 3—“J2EE Pattern Catalog” presents the J2EE pattern catalog. The catalog contains the fifteen patterns that form the core of this book. This part is comprised of Chapter 6, 7, 8, and 9.  

第三部分——“J2EE模式目录”呈现了J2EE模式目录。该目录包含构成本书核心的十五种模式，由第6、7、8、9章组成。

Chapter 6: “J2EE Patterns Overview” provides an overview of the J2EE pattern catalog. This chapter begins with a high level discussion of the pattern ideas and explains the way the patterns are categorized into tiers. It also explains the J2EE pattern template, which is used to present all patterns in this book. The chapter discusses all the J2EE patterns and uses a diagram to show their inter-relationships. It also provides what we have termed a roadmap to the pattern catalog. This roadmap presents common J2EE design and architecture-related questions with references to patterns or refactorings that provide solutions to these questions. Understanding the pattern relationships and the roadmap is key to using these patterns.  

第6章“J2EE模式概述”对J2EE模式目录进行了整体介绍。本章首先从高层次讨论模式理念，并解释模式按层次分类的方式。同时阐述了本书用于呈现所有模式的J2EE模式模板。该章节讨论了所有J2EE模式，并通过图示展示其相互关系。此外还提供了我们称之为模式目录的路线图，该路线图针对常见的J2EE设计和架构相关问题，给出了提供解决方案的对应模式或重构方法参考。理解模式关系与路线图是运用这些模式的关键。

Chapter 7: “Presentation Tier Patterns” presents six patterns that pertain to using Servlets, JSP, JavaBeans, and custom tags to design web-based applications for the J2EE platform. The patterns describe numerous implementation strategies, and address common problems such as request handling, application partitioning, and generating composite displays.  

第7章《表示层模式》介绍了六种与使用Servlet、JSP、JavaBean和自定义标签相关的模式，用于为J2EE平台设计基于Web的应用程序。这些模式描述了多种实现策略，并解决了请求处理、应用分区和生成复合视图等常见问题。

Chapter 8: “Business Tier Patterns” presents seven patterns that pertain to using EJB technology to design business components for the J2EE platform. The patterns in this chapter provide the best practices for using the EJB and JMS technologies. Where relevant, these patterns include discussion on other technologies, such as JNDI and JDBC.  

第8章：“业务层模式”介绍了七种与使用EJB技术为J2EE平台设计业务组件相关的模式。本章中的模式提供了使用EJB和JMS技术的最佳实践。在适当情况下，这些模式还涉及对其他技术（如JNDI和JDBC）的讨论。

Chapter 9: “Integration Tier Patterns” presents two patterns that pertain to integrating J2EE applications with the resource tier and external systems. The patterns deal with using JDBC and JMS to enable integration between business tier and resource tier components.  

第9章《集成层模式》介绍了两种与J2EE应用集成资源层及外部系统相关的模式。这些模式涉及使用JDBC和JMS实现业务层组件与资源层组件间的集成。

Epilogue: “J2EE Patterns Applied” discusses realizing sample use cases with the patterns. This chapter discusses and demonstrates how patterns are combined and work together. This chapter reinforces the idea that patterns exist in a community, and that each pattern supports, and is supported by, other patterns.  

后记：《J2EE模式实战》探讨了如何运用模式实现示例用例。本章讨论并演示了模式的组合方式与协同工作机制，强调模式存在于生态体系中，每个模式既支撑其他模式，也被其他模式所支撑。

# Companion Website and Contact Information  

The official companion website where we will provide updates and other material is http://www.phptr.com/corej2eepatterns.  

官方配套网站地址为 http://www.phptr.com/corej2eepatterns，我们将在此提供更新资料及其他相关资源。

The J2EE Patterns interest group, j2eepatterns-interest@java.sun.com is available for public subscription and participation. To subscribe to the interest group and review the discussion archives, please visit:  

J2EE模式兴趣小组（j2eepatterns-interest@java.sun.com）现开放公开订阅与参与。如需订阅兴趣小组并查阅讨论存档，请访问：

http://archives.java.sun.com/archives/j2eepatterns-interest.html  

http://archives.java.sun.com/archives/j2eepatterns-interest.html

# Acknowledgments  

We wish to thank Stu Stern, Director of Global Sun Java Center and Mark Bauhaus, VP of .COM Consulting without whose support, vision, and belief in our work this effort would never have been realized.  

我们衷心感谢全球Sun Java中心总监Stu Stern和.COM咨询副总裁Mark Bauhaus，正是他们对本项目的支持、远见以及对工作的信任，才使得这一成果得以实现。

We wish to thank Ann Betser, without whose support, encouragement and skilled advice, we would have been lost.  

我们要感谢安·贝特瑟，没有她的支持、鼓励和专业建议，我们将无从着手。

We wish to express our sincere thanks to the PSA/iWorkflow reference implementation team of SJC architects: Fred Bloom, Narayan Chintalapati, Anders Eliasson, Kartik Ganeshan, Murali Kalyanakrishnan, Kamran Khan, Rita El Khoury, Rajmohan Krishnamurty, Ragu Sivaraman, Robert Skoczylas, Minnie Tanglao, and Basant Verma.  

我们谨向SJC架构师团队的PSA/iWorkflow参考实现小组致以诚挚谢意，成员包括：Fred Bloom、Narayan Chintalapati、Anders Eliasson、Kartik Ganeshan、Murali Kalyanakrishnan、Kamran Khan、Rita El Khoury、Rajmohan Krishnamurty、Ragu Sivaraman、Robert Skoczylas、Minnie Tanglao以及Basant Verma。

We wish to thank the Sun Java Center J2EE Patterns Working Group members: Mohammed Akif, Thorbiörn Fritzon, Beniot Garbinato, Paul Jatkowski, Karim Mazouni, Nick Wilde, and Andrew X. Yang.  

我们谨此感谢Sun Java中心J2EE模式工作组的成员：Mohammed Akif、Thorbiörn Fritzon、Beniot Garbinato、Paul Jatkowski、Karim Mazouni、Nick Wilde以及Andrew X. Yang。

We wish to thank Brendan McCarthy, SJC Chief Methodologist for keeping us in balance and for all the advice.  

我们感谢首席方法论专家Brendan McCarthy在保持我们平衡方面提供的所有建议。

We wish to thank Jennifer Helms and John Kapson for introducing the patterns to customers.  

我们感谢Jennifer Helms和John Kapson向客户介绍这些模式。

We wish to express our gratitude to the following SJC architects from around the world for their support, feedback, and advice: Mark Cade, Mark Cao, Torbjörn Dahlén, Peter Gratzer, Bernard Van Haecke, Patricia de las Heras, Scott Herndon, Grant Holland, Girish Ippadi, Murali Kaundinya, Denys Kim, Stephen Kirkham, Todd Lasseigne, Sunil Mathew, Fred Muhlenberg, Vivek Pande, John Prentice, Alexis Roos, Gero Vermaas, Miguel Vidal.  

我们衷心感谢以下来自全球各地的SJC架构师们提供的支持、反馈与建议：Mark Cade、Mark Cao、Torbjörn Dahlén、Peter Gratzer、Bernard Van Haecke、Patricia de las Heras、Scott Herndon、Grant Holland、Girish Ippadi、Murali Kaundinya、Denys Kim、Stephen Kirkham、Todd Lasseigne、Sunil Mathew、Fred Muhlenberg、Vivek Pande、John Prentice、Alexis Roos、Gero Vermaas、Miguel Vidal。

We wish to thank our management Hank Harris, Dan Hushon, Jeff Johnson, Nimish Radia, Chris Steel, and Alex Wong for their support and encouragement.  

我们衷心感谢管理层Hank Harris、Dan Hushon、Jeff Johnson、Nimish Radia、Chris Steel和Alex Wong的支持与鼓励。

We wish to thank the following Sun colleagues for their collaboration:  

我们要感谢以下Sun公司的同事们的合作：

Bruce Delagi from Software Systems group; Mark Hapner, Vlada Matena from Java Software Engineering; Paul Butterworth and Jim Dibble from Forte Products Group; Deepak Balakrishna from iPlanet Products Group; Larry Freeman, Cori Kaylor, Rick Saletta, and Inderjeet Singh from the J2EE Blueprints Team; Heidi Dailey; Dana Nourie, Laureen Hudson, Edward Ort, Margaret Ong, and Jenny Pratt from Java Developer Connection.  

来自软件系统组的Bruce Delagi；来自Java软件工程的Mark Hapner和Vlada Matena；来自Forte产品组的Paul Butterworth和Jim Dibble；来自iPlanet产品组的Deepak Balakrishna；来自J2EE蓝图团队的Larry Freeman、Cori Kaylor、Rick Saletta和Inderjeet Singh；Heidi Dailey；来自Java开发者连接的Dana Nourie、Laureen Hudson、Edward Ort、Margaret Ong和Jenny Pratt。

We wish to thank the following for their feedback, advice, and support:  

我们要感谢以下人员提供的反馈、建议与支持：

Martin Fowler and Josh Mackenzie from ThoughtWorks, Inc.; Richard Monson-Haefel; Phil Nosonowitz and Carl Reed from Goldman Sachs; Jack Greenfield, Wojtek Kozaczynski, and Jon Lawrence from Rational Software; Alexander Aptus from TogetherSoft; Kent Mitchell from Zaplets.com; Bill Dudney; David Geary; Hans Bergsten; Members of the J2EE Patterns Interest group (j2eepatterns-interest@java.sun.com).  

来自ThoughtWorks公司的Martin Fowler和Josh Mackenzie；Richard Monson-Haefel；高盛集团的Phil Nosonowitz和Carl Reed；Rational Software的Jack Greenfield、Wojtek Kozaczynski和Jon Lawrence；TogetherSoft的Alexander Aptus；Zaplets.com的Kent Mitchell；Bill Dudney；David Geary；Hans Bergsten；以及J2EE模式兴趣小组的成员（j2eepatterns-interest@java.sun.com）。

We wish to express our special thanks and gratitude to our lead technical editor Beth Stearns, transforming our manuscripts and making them readable, at the same time keeping us on track, and working with us all the way with a heavily demanding schedule.  

我们特别感谢首席技术编辑Beth Stearns，她不仅将我们的手稿润色得清晰易读，还确保项目进度不偏离轨道，并以极高的工作强度全程与我们并肩协作。

We wish to thank the technical editors Daniel S. Barclay, Steven J. Halter, Spencer Roberts, and Chris Taylor for their expertise, meticulous review and feedback.  

我们衷心感谢技术编辑 Daniel S. Barclay、Steven J. Halter、Spencer Roberts 和 Chris Taylor 提供的专业指导、细致审阅与宝贵建议。

We wish to thank Greg Doench, Lisa Iarkowski, Mary Sudul, and Debby Van Dijk from Prentice Hall; Michael Alread and Rachel Borden from Sun Microsystems Press, for doing everything it took to produce this book.  

我们衷心感谢Prentice Hall的Greg Doench、Lisa Iarkowski、Mary Sudul和Debby Van Dijk，以及Sun Microsystems Press的Michael Alread和Rachel Borden，他们为本书的出版付出了不懈努力。

We thank Bill Jirsa, John Hathaway, and Darlene Khosrowpour from Sun Educational Services for their effort creating the SunEd J2EE Patterns course (SL-500), John Sharp and Andy Longshaw from Content Master Ltd., as well as all the course reviewers for SL-500.  

我们感谢来自Sun教育服务部门的Bill Jirsa、John Hathaway和Darlene Khosrowpour为创建SunEd J2EE模式课程（SL-500）所付出的努力，同时感谢Content Master Ltd.的John Sharp和Andy Longshaw，以及所有参与SL-500课程评审的专家。

We wish to thank the patterns and the Java communities on whose work we have built.  

我们衷心感谢模式社区和Java社区，正是基于他们的工作成果我们才得以构建。

The authors wish to thank their families for their support.  

作者谨向家人致以谢意，感谢他们一直以来的支持。

Deepak Alur wishes to thank:  

迪帕克·阿卢尔（Deepak Alur）谨致谢意：

Kavya, Shivaba and Samiksha—for your support, understanding, and inspiration;   
My Parents and Ajay.  

卡维娅、希瓦巴与萨米克莎——感谢你们的支持、理解与启迪；  
我的父母与阿贾伊。

John Crupi wishes to thank:  

John Crupi 致谢：

Ellen and Rachel—for your support , understanding and love.  

艾伦和瑞秋——感谢你们的支持、理解与爱。

Casey and Smokey—two great dogs will be forever missed.  

凯西和斯莫基——两只永远被怀念的忠犬。

Dan Malks wishes to thank:  

丹·马尔克斯（Dan Malks）谨致谢意：

Beth, Sarah, and Jonathan—for your support and for bringing special meaning to everything in my life.  

贝丝、莎拉和乔纳森——感谢你们的支持，为我生命中的一切赋予了特殊意义。

# Part I: PATTERNS AND J2EE  

Part I includes the following two chapters:  

第一部分包含以下两章：

Chapter 1—Introduction • Chapter 2—J2EE Platform Overview  

第1章 引言 • 第2章 J2EE平台概述

Chapter 1 presents a high-level discussion on patterns and the J2EE. The chapter presents numerous pattern definitions, information on pattern categorization, and some benefits of using patterns. This chapter sets the context for our J2EE Patterns work and provides the rationale and motivation behind the J2EE Pattern Catalog.  

第1章对模式与J2EE进行了高层次探讨。本章提供了大量模式定义、模式分类信息以及使用模式的若干优势，为后续J2EE模式研究工作奠定基础，同时阐述了《J2EE模式目录》编纂的理论依据与核心动机。

Chapter 2 provides a high level overview of the J2EE, its background, and the platform's value proposition. The chapter also discusses the relation between the J2EE Platform and the J2EE Pattern Catalog.  

第2章对J2EE进行了高层次概述，包括其背景和平台的价值主张。本章还讨论了J2EE平台与J2EE模式目录之间的关系。

# Chapter 1. INTRODUCTION  

# Topics in This Chapter  

What Is J2EE?   
What Are Patterns?   
J2EE Pattern Catalog   
Patterns, Frameworks, and Reuse  

什么是J2EE？  
什么是模式？  
J2EE模式目录  
模式、框架与复用

The last few years have been extraordinary with respect to the changing landscape of enterprise software development. At the center of this change is the Java 2 Platform, Enterprise Edition (J2EE), which provides a unified platform for developing distributed, server-centric applications. The widespread adoption of the strategic, enabling technologies of the J2EE have provided the development community with open standards on which to build service-based architectures for the enterprise.  

过去几年，企业软件开发领域的变革格局堪称非凡。这一变革的核心正是Java 2平台企业版（J2EE），它为开发分布式、以服务器为中心的应用提供了统一平台。J2EE战略赋能技术的广泛采用，为开发社区提供了构建企业级服务架构的开放标准。

At the same time, learning J2EE technologies is too often confused with learning to design with J2EE technologies. Many existing Java books do an excellent job of explaining specific aspects of the technology, but are not always clear on how to apply it.  

与此同时，学习J2EE技术常常与运用J2EE技术进行设计相混淆。许多现有的Java书籍在解释技术细节方面做得非常出色，但往往未能清晰地阐明如何应用这些技术。

A J2EE architect needs to understand more than the relevant APIs, including  

J2EE架构师需要掌握的远不止相关API，还需深入理解

What are the best practices?   
What are the bad practices?   
What are the common recurring problems and proven solutions   
to these problems?   
How is code refactored from a less optimal scenario, or bad   
practice, to a better one typically described by a pattern?  

最佳实践有哪些？  
不良实践有哪些？  
针对这些问题的常见重复性问题及已验证的解决方案是什么？  
如何通过典型模式描述的方式，将代码从次优场景或不良实践重构为更佳方案？

That is what this book is all about. Good designs are discovered from experience. When these designs are communicated as patterns using a standard pattern template, they become a powerful mechanism for communication exchange and reuse, and can be leveraged to improve the way we design and build software.  

这正是本书的核心主旨。优秀的设计源于经验积累。当这些设计通过标准模式模板以模式形式进行表述时，它们将成为沟通交流与复用的强大机制，并能有效提升软件设计与构建的方式。

# What Is J2EE?  

J2EE is a platform for developing distributed enterprise software applications. Since the inception of the Java language, it has undergone tremendous adoption and growth. More and more technologies have become part of the Java platform, and new APIs and standards have been developed to address various needs. Eventually, Sun and a group of industry leaders, under the auspices of the open Java Community Process (JCP), unified all these enterprise-related standards and APIs into the J2EE Platform.  

J2EE 是一个用于开发分布式企业级软件应用的平台。自 Java 语言诞生以来，其采用率与生态规模均实现了显著增长。越来越多的技术被纳入 Java 平台体系，为满足多样化需求，新的 API 与标准相继问世。最终，Sun 公司与行业领袖团体在开放 Java 社区进程（JCP）框架下，将所有这些企业级相关标准与 API 统一整合为 J2EE 平台。

The J2EE Platform offers numerous advantages to the enterprise:  

J2EE平台为企业提供了诸多优势：

• J2EE establishes standards for areas of enterprise computing needs such as database connectivity, enterprise business  

• J2EE 为数据库连接、企业业务等企业计算需求领域制定了标准

components, message-oriented middleware (MOM),   
Web-related components, communication protocols, and interoperability.   
J2EE promotes best-of-breed implementations based on open standards, protecting technological investment.   
J2EE provides a standard platform for building software   
components that are portable across vendor implementations, avoiding vendor lock-in.   
J2EE increases time-to-market since much of the infrastructure and plumbing is provided by the vendors' products that are implemented according to the standard J2EE specification. IT organizations can now get out of the middleware business and concentrate on building applications for their business.   
J2EE increases programmer productivity, since Java   
programmers can relatively easily learn J2EE technologies based on the Java language. All enterprise software   
development can be accomplished under the J2EE platform, using Java as the programming language.   
J2EE promotes interoperability within existing heterogenous environments.  

组件、面向消息的中间件（MOM）、  
Web相关组件、通信协议及互操作性。  
J2EE基于开放标准推动最佳实践实现，保护技术投资。  
J2EE为构建软件组件提供标准平台，  
确保组件可跨供应商实现移植，避免厂商锁定。  

J2EE显著缩短上市时间——其标准规范下的供应商产品  
已提供大量基础设施与底层架构。IT组织得以摆脱中间件业务，  
专注于构建企业级应用。  

J2EE提升开发者生产力，Java程序员  
可基于Java语言快速掌握J2EE技术。所有企业软件开发  
均可通过J2EE平台以Java编程语言完成。  
J2EE增强现有异构环境中的互操作性。

We discuss the J2EE Platform in greater detail in Chapter 2, so refer to that chapter for more information. Now we will take a brief look at patterns, their history, and the types of patterns in the J2EE Pattern Catalog that you will find in Part 3 of this book.  

我们将在第2章更详细地讨论J2EE平台，更多信息请参考该章节。现在我们将简要介绍模式的概念、发展历史，以及本书第三部分中J2EE模式目录所包含的模式类型。

# What Are Patterns?  

# Historical References  

In the 1970s, Christopher Alexander [Alex, Alex2] wrote a number of books documenting patterns in civil engineering and architecture. The software community subsequently adopted the idea of patterns based on his work, though there was burgeoning interest in the software community in these ideas already.  

20世纪70年代，Christopher Alexander [Alex, Alex2] 撰写了一系列记录土木工程与建筑领域模式的著作。软件界随后基于其研究采纳了模式思想，尽管当时软件社区对这些理念的兴趣已然萌芽。

Patterns in software were popularized by the book Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (also known as the Gang of Four, or GoF). Of course, while the Gang of Four work resulted in patterns becoming a common discussion topic in software development teams around the world, the important point to remember is that the patterns they describe were not invented by  

软件模式的概念因Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides（合称"四人帮"或GoF）所著的《设计模式：可复用面向对象软件的基础》一书而广为人知。当然，尽管四人帮的著作使得模式成为全球软件开发团队的常见讨论话题，但需要记住的关键点是：他们所描述的模式并非由

these authors. Instead, having recognized recurring designs in numerous projects, the authors identified and documented this collection.  

这些作者并未自行发明这些模式。相反，在识别出众多项目中反复出现的设计方案后，他们系统性地归纳并编纂了这套模式集合。

Many software patterns books have been published since the GoF book, covering patterns for various domains and purposes. We provide references to a selected list of these titles and encourage you to investigate the other types of patterns described in these books.  

自GoF著作问世以来，众多软件模式书籍相继出版，涵盖了不同领域和用途的模式。我们精选了部分书目作为参考，并建议您深入研读这些著作中描述的其他模式类型。

# Defining a Pattern  

Patterns are about communicating problems and solutions. Simply put, patterns enable us to document a known recurring problem and its solution in a particular context, and to communicate this knowledge to others. One of the key elements in the previous statement is the word recurring, since the goal of the pattern is to foster conceptual reuse over time.  

模式的核心在于问题与解决方案的传递。简而言之，模式让我们能够记录特定上下文中已知的**重复出现的问题**及其解决方案，并将这些知识传递给他人。上述定义的关键词是“重复出现”——因为模式的根本目标在于促进概念的长期复用。

We explore this in more detail in Chapter 6, in the section “What Is a Pattern?”.  

我们将在第6章的“什么是模式？”一节中对此进行更详细的探讨。

Here we examine some well-known definitions of patterns, beginning with one from Christopher Alexander in A Pattern Language [Alex2]:  

这里我们考察一些关于模式的经典定义，首先引用克里斯托弗·亚历山大在《模式语言》[Alex2]中的阐述：

Each pattern is a three-part rule, which expresses a relation between a certain context, a problem, and a solution.  

每个模式都是一个三部分组成的规则，它表达了特定上下文、问题及解决方案之间的关系。

—Christopher Alexander  

——克里斯托弗·亚历山大

Alexander expands his definition further, and noted patterns figure Richard Gabriel [Gabriel] discusses this definition in more detail [Hillside2]. Gabriel offers his own version of Alexander's definition as applied to software:  

亚历山大进一步扩展了他的定义，而知名模式专家理查德·加布里埃尔[Gabriel]在[Hillside2]中更详细地讨论了这个定义。加布里埃尔针对软件领域提出了他自己版本的亚历山大定义：

Each pattern is a three-part rule, which expresses a relation between a certain context, a certain system of forces which occurs repeatedly in that context, and a certain software configuration which allows these forces to resolve themselves. [See A Timeless Way of Hacking.]  

每个模式都是一条三部分组成的规则，它表达了特定上下文、在该上下文中反复出现的特定作用力系统，以及允许这些作用力自行消解的特定软件配置之间的关系。[参见《永恒的设计之道》]

—Richard Gabriel  

——理查德·加布里埃尔

This is a fairly rigorous definition, but there are also much looser ones. For example, Martin Fowler offers the following definition in Analysis Patterns [Fowler2]:  

这是一个相当严格的定义，但也存在更为宽松的表述。例如，Martin Fowler在《分析模式》[Fowler2]中给出了如下定义：

A pattern is an idea that has been useful in one practical context and will probably be useful in others.  

模式是一种在某个实际场景中已被证明有效的思想，并可能在其他场景中同样适用。

—Martin Fowler  

——马丁·福勒

As you can see, there are many definitions for a pattern, but all these definitions have a common theme relating to the recurrence of a problem/solution pair in a particular context.  

可以看出，关于模式存在多种定义，但这些定义都有一个共同主题：特定上下文中问题/解决方案对的重复出现。

Some of the common characteristics of patterns are  

模式的一些常见特征包括

Patterns are observed through experience. Patterns are typically written in a structured format (see “Pattern Template”). Patterns prevent reinventing the wheel. Patterns exist at different levels of abstraction.   
• Patterns undergo continuous improvement.   
• Patterns are reusable artifacts.   
• Patterns communicate designs and best practices. Patterns can be used together to solve a larger problem.  

模式是通过经验观察总结而来的。模式通常以结构化格式编写（参见“模式模板”）。模式能避免重复造轮子，且存在于不同抽象层级中。  
• 模式会持续迭代优化  
• 模式是可复用的技术制品  
• 模式能传递设计思想与最佳实践，通过组合使用可解决更复杂问题

Many great minds have spent a significant amount of time attempting to define and refine the notion of a software pattern. Suffice it to say, we do not presume to be great minds, nor do we wish to spend time expanding these discussions. Instead, we attempt to be true to aspects of these various definitions, focusing on the most simple and recurring theme in each.  

众多杰出学者曾耗费大量时间试图定义和完善软件模式的概念。可以说，我们既不自诩为天才，也不愿花时间扩展这些讨论。相反，我们力求忠实于这些不同定义的核心要素，聚焦于其中最简单且反复出现的主题。

# Categorizing Patterns  

Patterns, then, represent expert solutions to recurring problems in a context and thus have been captured at many levels of abstraction and in numerous domains. Numerous categories have been suggested for classifying software patterns, with some of the most common being  

模式，即在特定上下文中对重复出现问题的专家级解决方案，因此已被抽象为多个层次并应用于众多领域。针对软件模式的分类已提出多种范畴，其中最常见的包括

design patterns architectural patterns analysis patterns creational patterns structural patterns behavioral patterns  

设计模式 架构模式 分析模式 创建型模式 结构型模式 行为模式

Even within this brief list of categories, we see numerous levels of abstraction and orthogonal classification schemes. Thus, while many taxonomies have been suggested, there is no one right way to document these ideas.  

即便在这个简短的分类列表中，我们也能看到多层次的抽象和正交的分类方案。因此，尽管已有多种分类法被提出，但记录这些理念并不存在唯一正确的方式。

We refer to the patterns in the catalog simply as “J2EE patterns”. Each pattern hovers somewhere between a design pattern and an architectural pattern, while the strategies document portions of each pattern at a lower level of abstraction. The only scheme we have introduced is to classify each pattern within one of the following three logical architectural tiers:  

我们将目录中的模式统称为“J2EE模式”。每个模式介于设计模式与架构模式之间，而策略文档则以较低抽象层级描述各模式的组成部分。我们采用的唯一分类方案是将每个模式归入以下三个逻辑架构层之一：

presentation tier business tier integration tier  

表示层 业务层 集成层

At some point in the evolution of the pattern catalog, perhaps it will grow to a size that will warrant its being classified using a more sophisticated scheme. Currently, however, we prefer to keep things simple and not to introduce any new terms unnecessarily.  

在模式目录的演进过程中，或许其规模会增长到需要采用更复杂的分类方案。但目前我们更倾向于保持简洁，避免不必要地引入新术语。

# J2EE Pattern Catalog  

# Continuous Evolution  

The J2EE patterns described in this book are based on our collective experience of working on the J2EE platform with Sun Java Center clients around the world. The Sun Java Center, a part of Sun Professional Services, is a consulting organization focused on building Java technology-based solutions for customers. We have been creating solutions for the J2EE platform since the platform's inception, focusing on achieving Quality of Service goals such as scalability, availability, and performance.  

本书所述的J2EE模式基于我们与全球Sun Java中心客户在J2EE平台上合作的集体经验。作为Sun专业服务部门的一部分，Sun Java中心是一家专注于为客户构建基于Java技术解决方案的咨询机构。自该平台诞生以来，我们始终致力于实现可扩展性、可用性和性能等服务质量目标，持续为J2EE平台打造解决方案。

During the early days, as we designed, developed, and implemented various systems on the J2EE platform, we started documenting our experiences in an informal way as design considerations, ideas, and notes. As the knowledge base grew, we recognized a need for a slightly more formal documentation to capture and communicate this knowledge. We transitioned to documenting these ideas as patterns, since patterns are ideally suited to capturing and communicating knowledge related to recurring problems and solutions.  

在早期阶段，当我们基于J2EE平台设计、开发和实现各类系统时，我们开始以非正式的方式记录经验，包括设计考量、构思和笔记。随着知识库的不断扩充，我们意识到需要采用更规范的文档形式来沉淀和传递这些知识。于是我们将这些构思转化为模式进行记录，因为模式天然适合捕捉和传递与重复出现的问题及解决方案相关的知识。

The first order of business was to sort out the level of abstraction with which the patterns were to be documented. Some problems and solutions overlapped others in that the core of the problem was the same, but the solution was implemented in a different manner. To address this overlap, we had to tackle the issue of the level of abstraction and the granularity with which we defined each pattern. As you will see in the J2EE pattern catalog, we eventually settled on a level of abstraction that hovers somewhere between design pattern and architectural pattern. The details related to the solutions that deal with implementation at a lower level of abstraction are addressed in the “Strategies” sections in our pattern template (see “Pattern Template”). This allows us to describe each pattern at a higher level of abstraction and at the same time discuss the implementation details.  

首要任务是明确记录这些模式时所采用的抽象层级。某些问题与解决方案存在重叠，其核心问题相同但实现方式各异。为解决这种重叠性，我们必须处理抽象层级和模式定义粒度的问题。正如您在J2EE模式目录中将看到的，我们最终确定的抽象层级介于设计模式与架构模式之间。针对较低抽象层级的实现细节，则在模式模板的"策略"章节予以阐述（参见"模式模板"）。这种处理方式使我们既能以较高抽象层级描述每个模式，又可同步讨论具体实现细节。

Each pattern has been named and renamed many times. Additionally, each pattern has been rewritten many times, based on community feedback. Needless to say, these patterns, like all patterns, are subject to continuous improvement and will certainly evolve as the technology and specifications change.  

每个模式都经历了多次命名与重命名。此外，基于社区反馈，每个模式也经过了多次重写。毋庸置疑，这些模式与所有模式一样，将持续改进，并随着技术和规范的演变而不断发展。

The J2EE pattern catalog currently includes 15 patterns and is presented in three chapters: Chapter 7, “Presentation Tier Patterns,” Chapter 8, “Business Tier Patterns,” and Chapter 9, “Integration Tier Patterns.” Each pattern is documented in our pattern template.  

J2EE模式目录目前包含15种模式，分为三章呈现：第7章“表示层模式”、第8章“业务层模式”以及第9章“集成层模式”。所有模式均采用标准模式模板进行文档化。

Table 1-1 lists the patterns included in the catalog.  

表1-1列出了本目录中包含的模式。

<html><body><table><tr><td colspan="2">Table 1-1. Patterns in the J2EE Pattern Catalog</td></tr><tr><td>Tier</td><td>PatternName</td></tr><tr><td>Presentation Tier</td><td>InterceptingFilter""Front Controller""View Helper""Composite View""Service toWorker""DispatcherView'</td></tr><tr><td>BusinessTier</td><td>Business Delegate""ValueObject""Session Facade""Composite Locator"</td></tr><tr><td>Integration Tier</td><td>DataAccessObject""ServiceActivator"</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表1-1. J2EE模式目录中的模式</td></tr><tr><td>分层</td><td>模式名称</td></tr><tr><td>表示层</td><td>InterceptingFilter""Front Controller""View Helper""Composite View""Service toWorker""DispatcherView'</td></tr><tr><td>业务层</td><td>Business Delegate""ValueObject""Session Facade""Composite Locator"</td></tr><tr><td>集成层</td><td>DataAccessObject""ServiceActivator"</td></tr></table></body></html>

# How to Use the J2EE Pattern Catalog  

One of the challenges when using any set of patterns is understanding how to best use the patterns in combination. As Christopher Alexander says in his book, A Pattern Language [Alex2]:  

使用任何模式集时面临的挑战之一，在于如何理解如何最佳地组合使用这些模式。正如克里斯托弗·亚历山大在其著作《模式语言》[Alex2]中所言：

In short, no pattern is an isolated entity. Each pattern can exist in the world, only to the extent that is supported by other patterns: the larger patterns in which it is embedded, and the patterns of the same size that surround it, and the smaller patterns which are embedded in it.  

简言之，任何模式都不是孤立存在的。每个模式能够存在于世，仅因其被其他模式所支撑：包含它的更大模式、环绕它的同尺度模式、以及它所包含的更小模式。

—Christopher Alexander  

——克里斯托弗·亚历山大

The patterns in the J2EE pattern catalog are no exception to this rule. The pattern relationships diagram, explained in Chapter 6, “J2EE Patterns Overview,” describes how each pattern is supported by other patterns in the catalog. Chapter 6 also provides a roadmap to the J2EE pattern catalog, presented in tabular form, with common J2EE design and architecture-related questions paired with pattern or refactoring references, providing solutions to each question. To gain the maximum benefit from using these patterns, it is recommended that the pattern relationships and the pattern roadmap be well understood.  

J2EE模式目录中的模式亦遵循此规则。第6章《J2EE模式纵览》阐述的模式关系图，描述了目录中每个模式如何被其他模式所支撑。该章节还以表格形式提供了J2EE模式目录的路线图，将常见的J2EE设计和架构相关问题与模式或重构参考配对，为每个问题提供解决方案。为充分发挥这些模式的价值，建议深入理解模式间的关联关系及模式路线图。

As you study each pattern in detail, you will see the patterns and strategies that are embedded within it, in which it is contained, and which it supports. Sometimes the pattern builds on other patterns from the J2EE pattern catalog or from other patterns described in well-known literature such as Design Patterns: Elements of Reusable Object-Oriented Software [GoF] or Patterns of Software Architecture [POSA1, POSA2].  

在深入研究每个模式时，您会发现其中嵌入的模式与策略、其所归属的架构以及它所支撑的体系。某些模式会基于J2EE模式目录中的其他模式，或是经典著作（如《设计模式：可复用面向对象软件的基础》[GoF]或《软件架构模式》[POSA1, POSA2]）所描述的模式进行构建。

In an attempt to aid you in further understanding the patterns, their interrelationships, pattern selection, and pattern usage, we have provided supporting chapters in Part 2 of the book.  

为帮助您进一步理解模式、模式间的相互关系、模式选择及模式运用，我们在本书第二部分提供了相关辅助章节。

In Part 2 of the book, we present bad practices and refactorings for the J2EE platform. For each bad practice that has been listed in these chapters, we provide links to refactorings or patterns that offer solutions to alleviate the problems created by that bad practice. In Chapter 5, “J2EE Refactorings,” we present refactorings that describe the steps involved in moving from a less optimal solution to a preferred one. The mechanics section of each refactoring provides references to patterns and design considerations that influence the direction of the refactoring.  

在本书第二部分，我们将探讨J2EE平台的不良实践与重构方案。针对各章节列出的每个不良实践，我们均提供了相关重构方法或模式的链接，这些方案可缓解不良实践引发的问题。第五章"J2EE重构"详细阐述了从次优方案转向优选方案的具体步骤，每个重构的"实施要点"部分均引用了影响重构方向的设计考量与模式参考。

Finally, in Epilogue, “J2EE Patterns Applied,” we demonstrate an example of an application based on the J2EE patterns. We present some use cases to show how these patterns interact and work together to help realize a use case.  

最后，在结语《J2EE模式实战》中，我们演示了一个基于J2EE模式的应用实例。通过若干用例展示这些模式如何相互协作，共同实现业务场景。

# Benefits of Using Patterns  

You can use the J2EE patterns in this book to improve your system design, and you can apply them at any point in a project life cycle. The patterns in the catalog are documented at a relatively high level of abstraction and will provide great benefit when applied early in a project. Alternatively, if you apply a pattern during the implementation phase, you may have to rework existing code. In this case, the refactorings in Chapter 5 may prove quite useful.  

您可以通过本书中的J2EE模式来优化系统设计，这些模式可应用于项目生命周期的任何阶段。目录中的模式以较高抽象层级进行文档化，在项目早期应用时将发挥显著效益。若在实现阶段才应用某个模式，则可能需要重构现有代码。此时，第五章所述的重构技术将极具实用价值。

Patterns are often quite simple to use, though not always easy to understand. However, patterns can be difficult and time consuming to document, since this effort requires an examination of the essence of what constitutes a good practice. Recognizing good practices is typically a long-term effort. It involves distilling a large volume of knowledge down to its basics and putting it into words. We have tried to ensure that our documentation is clear and that it relates well to real world issues. At the same time, we recognize that this effort will continue to evolve and to be refined and improved over time.  

模式的使用通常相当简单，尽管理解起来并不总是容易。然而，模式的文档化可能既困难又耗时，因为这项工作需要深入探究优秀实践的本质。识别优秀实践通常是一项长期努力，涉及将大量知识提炼为基础要素并用文字表述。我们已尽力确保文档清晰明了，并与现实问题紧密关联。同时，我们也认识到这项工作将持续演进，并随着时间的推移不断优化改进。

What are the benefits of using patterns? We describe in the following sections some of the benefits of using and applying patterns in a project. In brief, patterns  

使用模式有哪些优势？我们将在以下章节详细阐述在项目中应用模式的部分优势。简而言之，模式

Leverage a proven solution.   
Provide a common vocabulary.   
Constrain solution space.  

采用经过验证的解决方案  
提供统一术语体系  
限定解决方案范围

# Leverage a Proven Solution  

A pattern is documented based on the fact that the solution it offers has been used over and over again to solve similar problems at different times in different projects. Thus, patterns provide a powerful mechanism for reuse, helping developers and architects to avoid reinventing the wheel.  

模式的文档化基于这样一个事实：它所提供的解决方案已在不同时期的不同项目中反复用于解决类似问题。因此，模式提供了强大的复用机制，帮助开发者和架构师避免重复造轮子。

# Common Vocabulary  

Patterns provide software designers with a common vocabulary. As designers, we use patterns not only to help us leverage and duplicate successful designs, but also to help us convey a common vocabulary and format to developers.  

模式为软件设计者提供了通用的术语体系。作为设计者，我们运用模式不仅是为了复用成功的解决方案，更是为了在开发团队中建立统一的表达范式和沟通标准。

A designer who does not rely on patterns needs to expend more effort to communicate his design to other designers or developers. Software designers use the pattern vocabulary to communicate effectively. This is similar to the real world, where we use a common vocabulary to communicate and exchange ideas. Just as in the real world, developers can build their vocabulary by learning and understanding patterns, increasing their design vocabulary as new patterns are documented.  

不依赖模式的设计师需要耗费更多精力向其他设计师或开发者传达其设计意图。软件设计师通过模式术语体系实现高效沟通，这与现实世界中使用通用词汇交流思想的场景如出一辙。正如现实世界的经验法则，开发者可以通过学习理解模式来构建术语体系，随着新模式的文档化不断扩充设计词汇库。

Once you start to use these patterns, you'll notice that you'll quickly begin to incorporate the pattern names into your vocabulary—and that you use the names of the patterns to replace lengthy descriptions. For example, suppose your problem solution entails use of a Value Object pattern. At first, you might describe the problem without putting a label on it. You may describe the need for your application to exchange data with enterprise beans, the need to maximize performance given the network overhead with remote invocations, and so forth. Later, once you've learned how to apply the Value Object pattern to the problem, you may refer to a similar situation in terms of a “Value Object” solution and build from there.  

当你开始运用这些模式时，会发现很快就能将这些模式名称融入日常技术讨论——用模式名称替代冗长的描述。例如，假设你的解决方案需要使用值对象模式。起初，你可能会在描述问题时避免使用专业术语：比如说明应用需要与企业级Bean交换数据，或强调在远程调用存在网络开销时需要最大化性能等。而当你掌握如何应用值对象模式后，就能直接将其称为"值对象"解决方案，并基于此展开讨论。

To understand the impact of the pattern vocabulary, consider this exercise after you and another team member are familiar with the pattern catalog. Without using pattern names, try to explain what can be conveyed by simple sentences such as the following, in which the pattern names from the J2EE pattern catalog are italicized:  

要理解模式词汇表的影响力，可在您与团队成员熟悉模式目录后进行以下练习：在不使用模式名称的情况下，尝试解释诸如以下简单句子所传达的含义（其中斜体部分为J2EE模式目录中的模式名称）：

We should use Data Access Objects in our servlets and session beans.   
How about using Value Object for transferring data to and from enterprise beans, and encapsulating all business services with Business Delegates?   
Let's use Front Controller and Service to Worker. We may have to use Composite Views for some complex pages.  

我们应当在Servlet和会话Bean中使用数据访问对象。  
采用值对象在Enterprise Bean之间传输数据，并通过业务委托封装所有业务服务如何？  
建议采用前端控制器和服务工作者模式。对于某些复杂页面，可能需要使用复合视图。

# Constrains Solution Space  

Pattern application introduces a major design component—constraints. Using a pattern constrains or creates boundaries within a solution space to which a design and implementation can be applied. Thus, a pattern strongly suggests to a developer boundaries to which an implementation might adhere. Going outside of these boundaries breaks the adherence to the  

模式应用引入了一个关键设计组件——约束。使用模式会限制或创建解决方案空间内的边界，设计和实现可应用于该空间。因此，模式会强烈建议开发者遵循实现可能依附的边界。超出这些边界将破坏对（模式的）遵循。

pattern and design, and may lead to the unwanted introduction of an anti-pattern.  

模式与设计，并可能导致意外引入反模式。

However, patterns do not stifle creativity. Instead, they describe a structure or shape at some level of abstraction. Designers and developers still have many options open to them for implementing the patterns within these boundaries.  

然而，模式并不会扼杀创造力。相反，它们描述了某种抽象层级上的结构或形态。在这些边界范围内，设计者和开发者仍拥有众多实现模式的可选方案。

# Patterns, Frameworks, and Reuse  

We have been chasing the illustrious software reuse goal for years now and have only had moderate success. In fact, most of the commercial reuse success has been in the user interface area, not in business components, which is our focus. As business system architects, we strive to promote reuse, but have really been concentrating on reuse at the design and architecture levels. The pattern catalog has proven a powerful way to promote this level of reuse.  

多年来我们一直追求卓越的软件复用目标，但仅取得了有限成功。事实上，商业复用的成功案例主要集中在用户界面领域，而非我们关注的核心业务组件层面。作为业务系统架构师，我们虽致力于推动复用实践，但实际聚焦的是设计与架构层面的复用。实践证明，模式目录是促进该层级复用的有效途径。

There are numerous relationships between each of the patterns in the catalog, and these relationships are sometimes referred to as being part of a pattern language. We provide a diagram of these relationships in Chapter 6, Figure 6.2. Another way to describe these relationships is in terms of a pattern framework, or a collection of patterns in a united scenario. This concept is key to identifying end-to-end solutions and wiring components together at the pattern level.  

模式目录中的各个模式之间存在大量关联关系，这些关系有时被称为**模式语言**的组成部分。我们将在第6章的图6.2中提供这些关系的示意图。另一种描述这些关系的方式是通过**模式框架**的概念，即在统一场景下的模式集合。这一概念对于识别端到端解决方案以及在模式层级将组件**装配**起来至关重要。

Developers must understand more than discrete patterns in isolation, and have been asking for best practices as to how to link patterns together to form larger solutions. Combining the patterns from the catalog in this manner is what we refer to as leveraging a J2EE pattern framework. A framework, in this context, is about linking patterns together to form a solution to address a set of requirements. We think that this type of usage will drive the next generation of tools in J2EE development. Such automation of a pattern-driven process requires  

开发者必须超越孤立地理解单个模式，并一直寻求如何将模式组合形成更大解决方案的最佳实践。以这种方式将目录中的模式进行组合，就是我们所说的**J2EE模式框架**的运用。在此语境下，框架的核心在于将模式串联起来形成满足特定需求集的解决方案。我们认为这种模式运用方式将推动J2EE开发的下一代工具演进。这种模式驱动流程的自动化需要

Identifying scenarios and offering patterns that apply for each tier. Identifying pattern combinations, or motifs, to provide pattern frameworks. • Selecting implementation strategies for each role.  

识别适用各层的场景并提供对应模式，确定模式组合（即模式框架）以构建模式框架体系。  
• 为每个角色选定实现策略。

We provide a bit more information on this evolving area of development in Epilogue.  

关于这一不断演进的开发领域，我们将在结语部分提供更多信息。

# Summary  

By now you should have a good understanding of what constitutes a pattern and what this book is all about. The next chapter provides an introduction to the J2EE Platform and its various technologies.  

至此，您应该已经充分理解了模式的构成要素以及本书的核心内容。下一章将介绍J2EE平台及其各项技术。

# Chapter 2. J2EE PLATFORM OVERVIEW  

# Topics in This Chapter  

A Brief Perspective   
J2EE Platform   
J2EE Patterns and J2EE Platform  

简要视角  
J2EE平台  
J2EE模式与J2EE平台

This chapter presents a high level overview of the Java™ 2 Platform, Enterprise Edition (J2EE) and its technologies. If you already understand the J2EE platform and its technologies and APIs, you may wish to skip this chapter. However, we suggest at a minimum that you read the section “J2EE Patterns and J2EE Platform”to understand what J2EE patterns are all about.  

本章对Java™ 2平台企业版（J2EE）及其技术体系进行高层概述。若您已熟悉J2EE平台及其技术与API，可跳过本章。但我们建议至少阅读"J2EE模式与J2EE平台"章节，以理解J2EE模式的核心内涵。

Read on if you wish to refresh your memory on J2EE.  

若需重温J2EE相关知识，请继续阅读。

# A Brief Perspective  

From its introduction to the world in 1994 to current day, the Java™ programming language has revolutionized the software industry. Java has been used in a myriad of ways to implement various types of systems. As Java started becoming more and more ubiquitous, spreading from browsers to phones to all kinds of devices, we saw it gradually hone in on one particular area and establish its strength and value proposition: That area is the use of Java on servers. Over time, Java has become the chosen platform for programming servers.  

自1994年问世至今，Java™编程语言已彻底改变了软件行业。Java以无数种方式被用于实现各类系统。随着Java从浏览器扩展到手机乃至各类设备，变得无处不在，我们观察到它逐渐聚焦于一个特定领域并确立其优势与价值主张：该领域正是Java在服务器端的应用。历经发展，Java已成为服务器编程的首选平台。

Java provides its Write Once Run Anywhere™ advantage to IT organizations, application developers, and product vendors. IT organizations leverage the benefits of vendor independence and portability of their applications. The increasing availability of skilled Java programmers promoted Java's adoption in the industry. Unbelievably, the number of Java programmers has rocketed to 2.5 million developers in only five years.  

Java为IT组织、应用程序开发者和产品供应商提供了"一次编写，随处运行™"的独特优势。IT组织充分利用了应用程序的供应商独立性和可移植性优势。随着熟练Java程序员数量的持续增长，Java在业内的采用率不断提升。令人难以置信的是，仅用五年时间，Java程序员数量就激增至250万开发者。

The simplicity of the language and the explosive growth of its use on the Internet and the intranet urged numerous developers and IT organizations to embrace Java as the de facto programming language for their projects.  

该语言的简洁性及其在互联网和内联网上的爆炸式增长，促使众多开发者和IT组织将Java视为项目开发的事实编程语言。

The client-server application architecture, a two-tier architecture, over time evolved to a multitier architecture. This natural progression occurred as additional tiers were introduced between the end-user clients and backend systems. Although a multitier architecture brings greater flexibility in design, it also increases the complexity for building, testing, deploying, administering, and maintaining application components. The J2EE platform is designed to support a multitier architecture, and thus it reduces this complexity.  

客户端-服务器应用架构（即双层架构）随着时间推移逐步演变为多层架构。这种自然演进源于在终端用户客户端与后端系统之间引入了更多中间层。虽然多层架构带来了更高的设计灵活性，但也增加了构建、测试、部署、管理和维护应用组件的复杂度。J2EE平台专为支持多层架构而设计，从而有效降低了这种复杂性。

During this time, corporate Internet usage changed. Corporations transitioned from providing a simple corporate Web site to exposing some of their not-so-critical applications to the external world. In this first phase of Internet experimentation, IT managers were still skeptical and the security police were adamantly unfriendly to the idea of using the Internet to run and expose business services.  

在此期间，企业互联网应用模式发生了转变。企业从仅提供简单的公司网站，逐步转向向外界开放部分非核心业务系统。在这场互联网试水的初期阶段，IT管理者仍持怀疑态度，安全策略部门也坚决反对通过互联网运行和暴露业务服务的构想。

Before long, more and more companies started to embrace the power of the Internet. For example, customer service organizations began to provide service on the Web, in addition to the traditional methods of supporting customers by phone and email. Such organizations recognized the major cost implications of providing online service. Customers could now help themselves for most problems, and call a customer service agent only for more serious issues.  

不久之后，越来越多的企业开始拥抱互联网的力量。例如，客户服务机构除了通过电话和电子邮件等传统方式提供支持外，也开始在Web端提供服务。这类机构意识到在线服务能显著降低成本——客户现在可以自助解决大部分问题，仅需为更复杂的情况联系客服专员。

Customers liked using the Web too, as it improved their productivity. Soon, customers started expecting more and more online services from companies, and companies had to step up and provide these services. If they did not, someone else would.  

客户也喜欢使用网络，因为它提高了工作效率。很快，客户开始期望企业提供越来越多的在线服务，企业不得不跟进并提供这些服务。如果他们不这样做，就会有其他企业取而代之。

Since then, almost everything has gone online—banking, bill payment, travel, ticketing, auctioning, car buying services, mortgages and loans, pharmacies, and even pet food! New companies were created that had no business model (now we know) other than opening shop online. They thrived and they thrashed. Established companies had to make their online presence felt to face the challenges of these new kids on the block. This tremendous growth fueled the need for a robust, enterprise class, Web-centric application infrastructure.  

自此，几乎所有业务都转向了线上——银行业务、账单支付、旅行预订、票务服务、拍卖交易、购车服务、抵押贷款、药品零售，甚至宠物食品！一批新兴企业应运而生，它们当时的商业模式（如今我们已了然）仅仅是在线开店。这些企业有的蓬勃发展，有的折戟沉沙。老牌企业不得不建立线上阵地，以应对这些行业新秀的挑战。这种爆发式增长催生了对强大、企业级、以Web为核心的应用程序基础设施的迫切需求。

# Application Servers—The New Breed  

As the acceptance and adoption of Java on the server side became more established, and the demand for Web-centric application infrastructure rose, we saw an emergence of a new breed of infrastructure applications—application servers. Application servers provided the basic infrastructure required for developing and deploying multitiered enterprise applications.  

随着Java在服务器端的接受度和采用率日益稳固，以及对以Web为中心的应用基础设施需求的增长，我们见证了一类新型基础设施应用——应用服务器的兴起。应用服务器为开发和部署多层企业级应用提供了所需的基础设施。

These application servers had numerous benefits. One important benefit was that IT organizations no longer needed to develop their proprietary infrastructure to support their applications. Instead, they could now rely on the application server vendor to provide the infrastructure. This not only reduced the cost of their applications, but also reduced the time-to-market.  

这些应用服务器具有诸多优势。其中一个重要优势是IT组织不再需要自行开发专有基础设施来支撑应用程序，转而可以依赖应用服务器供应商提供的基础架构。这不仅降低了应用开发成本，还显著缩短了产品上市周期。

Each application server had its own benefits and disadvantages. Because there were no standards for application servers, no two application servers were completely alike. Some application servers were based on Java, and these allowed you to write only Java components to run on that server, while others used different languages for development.  

每个应用服务器都有其各自的优势与不足。由于缺乏统一的应用服务器标准，不同厂商的实现方案存在显著差异。部分应用服务器基于Java技术栈，仅支持运行Java组件开发；而另一些则采用其他编程语言作为开发技术方案。

# Convergence of Java Technologies  

In the area of Web applications, there were significant developments in Java as well. The Common Gateway Interface (CGI) approach for developing Web-centric applications was resource-intensive and did not scale well. With the introduction of servlet technology, Java developers had an elegant and efficient mechanism to write Web-centric applications that generated dynamic content. However, writing servlets still took some effort and Java expertise.  

在Web应用领域，Java同样取得了重大进展。采用通用网关接口（CGI）开发以Web为中心的应用程序存在资源消耗大、扩展性差的问题。随着Servlet技术的引入，Java开发者获得了一种优雅高效的机制来编写生成动态内容的Web应用。然而，编写Servlet仍需一定的工作量且要求具备Java专业技能。

Then, the Java Server Pages (JSP) technology was introduced, particularly for Web and graphic designers accustomed to Hypertext Markup Language (HTML) and  

随后，Java Server Pages (JSP) 技术应运而生，尤其适用于习惯使用超文本标记语言(HTML)的Web及图形设计师。

JavaScript scripting. JSP technology made it easier for Web front developers to write Web-centric applications. One need not know Java and servlet programming to develop pages in JSP.  

JavaScript脚本技术。JSP技术使得Web前端开发者能够更轻松地编写以Web为中心的应用程序。开发人员无需掌握Java和Servlet编程即可开发JSP页面。

JSP technology addresses the need for a scripting language for Web application clients. Web designers skilled at HTML and JavaScript can quickly learn JSP technology and use it to write Web applications. Of course, the Web server translates JSPs into servlets, but that happens “under the wraps.” Effectively, servlets and JSPs separate Web application development roles.  

JSP技术满足了Web应用客户端对脚本语言的需求。擅长HTML和JavaScript的网页设计师能快速掌握JSP技术，并用于编写Web应用程序。当然，Web服务器会将JSP转换为Servlet，但这一过程是"幕后"完成的。实际上，Servlet和JSP实现了Web应用开发角色的分离。

The standard approach for database access in Java applications is Java Database Connectivity (JDBC). The JDBC API (application programming interface) gives programmers the ability to make their Java applications independent of the database vendor. One can write a JDBC application that accesses a database using standard Structured Query Language (SQL). If the underlying database changes from one vendor's product to another, the JDBC application works without any code change, provided that the code is properly written and does not use any proprietary extensions from the first vendor. JDBC API is offered as part of the core APIs in the Java ™ 2 Platform, Standard Edition (J2SE™).  

Java应用程序中数据库访问的标准方法是Java数据库连接（JDBC）。JDBC API（应用程序编程接口）使开发人员能够编写独立于数据库厂商的Java应用程序。开发者可以编写使用标准结构化查询语言（SQL）访问数据库的JDBC应用。如果底层数据库从一个厂商产品更换为另一个，只要代码编写规范且未使用首个厂商的专有扩展，该JDBC应用程序无需任何代码修改即可继续运行。JDBC API作为Java™ 2平台标准版（J2SE™）的核心API提供。

J2SE (formerly known as Java Development Kit or JDK) is the foundation for all Java APIs. J2SE consists of a set of core APIs that define the Java programming language interfaces and libraries. Java developers use the J2SE as the primary API for developing Java applications. As requirements expand and the Java language matures over the years, the J2SE offers additional APIs as standard extensions.  

J2SE（原称Java Development Kit或JDK）是所有Java API的基础。J2SE包含一组核心API，这些API定义了Java编程语言的接口和类库。Java开发者将J2SE作为开发Java应用程序的主要API。随着需求扩展和Java语言多年来的成熟演进，J2SE还以标准扩展的形式提供了额外的API。

As Java established its permanent role on the server side, and the adoption of various Java APIs became widespread, Sun put together an initiative to unify standards for various Java technologies into a single platform. The initiative to develop standards for enterprise Java APIs was formed under the open Java Community Process (JCP). Enterprise Java APIs are a collection of various APIs that provide vendor-independent programming interfaces to access various types of systems and services. The enterprise Java APIs emerged as the Java ™ 2 Platform, Enterprise Edition (J2EE™).  

随着Java在服务器端确立了其永久地位，以及各种Java API的广泛采用，Sun公司发起了一项倡议，旨在将各类Java技术标准统一为单一平台。这一针对企业级Java API标准制定的倡议在开放的Java社区进程（JCP）下形成。企业级Java API是一系列API的集合，它们提供了与厂商无关的编程接口，用于访问各类系统和服务。这些企业级Java API最终演变为**Java™ 2平台企业版（J2EE™）**。

# The Rise of the J2EE Platform  

The Enterprise Java Beans™ (EJB™) technology is one of the prominent, promising technologies in the J2EE platform. The EJB architecture provides a standard for developing reusable Java server components that run in an application server. The EJB specification and APIs provide a vendor-independent programming interface for application servers. EJB components, called enterprise beans, provide for persistence, business processing, transaction processing, and distributed processing capabilities for enterprise applications. In short, the EJB technology offers portability of business components.  

Enterprise Java Beans™ (EJB™) 技术是 J2EE 平台中一项重要且前景广阔的技术。EJB 架构为开发可复用的 Java 服务器组件提供了标准，这些组件运行在应用服务器中。EJB 规范与 API 为应用服务器提供了厂商无关的编程接口。被称为企业级 Bean 的 EJB 组件，为企业应用提供了持久化、业务处理、事务处理及分布式处理能力。简而言之，EJB 技术实现了业务组件的可移植性。

Various application vendors, having come together with Sun under the open JCP to develop this standard, adopted and implemented the EJB specification into their application server products. Similar to JDBC application portability, EJB applications are portable from one application server vendor to another. Again, this is true if the application does not use any vendor-dependent feature of the application server. J2EE technologies are now a proven and established platform for distributed computing for the enterprise.  

多家应用供应商与Sun公司通过开放的JCP组织共同制定该标准后，纷纷在其应用服务器产品中采纳并实现了EJB规范。与JDBC应用的可移植性类似，EJB应用可在不同供应商的应用服务器之间迁移。需注意的是，该特性仅适用于未使用任何应用服务器厂商专有功能的场景。J2EE技术现已成为企业级分布式计算领域经实践验证的成熟平台。

Java Message Service (JMS) is another standard API in the J2EE platform. It brings the same kind of standardization to messaging as JDBC brought for databases. JMS provides a standard Java API for using message-oriented middleware (MOM) for point-to-point and publish/subscribe types of enterprise messaging. As with the other technologies, JMS brings vendor independence in the MOM products for Java.  

Java消息服务（JMS）是J2EE平台中的另一项标准API。它为消息传递带来了与JDBC为数据库提供的同等级别的标准化。JMS为使用面向消息的中间件（MOM）提供了标准Java API，支持点对点和发布/订阅类型的企业消息传递。与其他技术一样，JMS为Java的MOM产品带来了供应商独立性。

In each of these areas, Sun and other companies collaborated in coming up with an acceptable standard under the auspices of the open JCP. The JCP coordinated the activities to develop these standards. This cooperation is a foundation for the success of these APIs.  

在所有这些领域中，Sun公司及其他企业通过开放的JCP组织协作制定了可接受的标准。JCP负责协调这些标准的开发活动。这种合作模式为这些API的成功奠定了基础。

# J2EE Value Proposition  

The J2EE platform, built on the Java programming language and Java technologies, is the application architecture that is best suited for an enterprise-distributed environment. The J2EE platform is a standard that brings the following benefits to IT organizations, application developers, and product vendors:  

基于Java编程语言和Java技术构建的J2EE平台，是最适合企业分布式环境的应用程序架构。J2EE平台作为一项标准，为IT组织、应用程序开发者和产品供应商带来以下优势：

Vendors develop products that can run on any system that supports the J2EE platform. With virtually no extra effort, their products are available on a wide range of system platforms.   
Corporate IT developers benefit from the advantages of portable component technology. IT applications become vendor-independent and release the IT organizations from the clutches of vendor lock-in.   
IT developers can focus on supporting business process requirements rather than building in-house application infrastructure. The application servers handle the complex issues of multithreading, synchronization, transactions, resource allocation, and life-cycle management.   
IT organizations can take advantage of the best available products built on a standard platform. They can choose among products and select the most suitable and cost-effective development products, deployment products, and deployment platforms based on their requirements.   
Adopting the J2EE platform results in a significant productivity increase. Java developers can quickly learn the J2EE APIs.  

厂商开发的产品可运行于任何支持J2EE平台的系统。几乎无需额外工作，其产品就能覆盖广泛的系统平台。  

企业IT开发者能享受可移植组件技术带来的优势。IT应用实现厂商中立性，使IT组织摆脱供应商锁定的束缚。  

IT开发者可专注于支持业务流程需求，而非构建内部应用基础设施。应用服务器会处理**多线程**、同步、**事务**、资源分配和生命周期管理等复杂问题。  

IT组织能充分利用基于标准平台构建的最佳产品。他们可根据需求从各类产品中甄选最合适且最具成本效益的开发工具、**部署**产品和**部署**平台。  

采用J2EE平台能显著提升生产效率。Java开发者可快速掌握J2EE API。

Companies protect their investment by adopting the J2EE platform, since it is an industry-supported standard and not a vendor-defined lock-in architecture. • Development teams can build new applications and systems more rapidly. This decreases time-to-market and reduces the cost of development. A standard development platform for distributed computing ensures that robust applications are built on a proven platform. The J2EE platform provides a clear, logical, and physical partitioning of applications into various tiers, thus naturally addressing multitiered application requirements. Developers can either build their own J2EE component or procure it from the rapidly growing third-party components market. Vendors are able to offer their components individually, and customers are able to buy these software parts as needed.  

企业通过采用J2EE平台来保护其投资，因为这是一个行业支持的标准，而非供应商定义的锁定架构。  
• 开发团队能够更快地构建新应用和系统，从而缩短上市时间并降低开发成本。标准化的分布式计算开发平台确保稳健的应用程序构建在成熟的平台上。J2EE平台通过清晰、逻辑和物理的分层将应用程序划分为不同层级，天然满足多层应用需求。开发者既可自行构建J2EE组件，也可从快速增长的第三方组件市场采购。供应商能够单独提供其组件，客户则能按需购买这些软件部件。

# J2EE Platform  

The previous section described the core technology components of the J2EE platform, such as servlet, JSP, EJB, JDBC, and JMS. In this section, we take a look at the J2EE architecture model and describe other aspects of the J2EE platform that complete the platform definition.  

上一节介绍了J2EE平台的核心技术组件，如Servlet、JSP、EJB、JDBC和JMS。本节将探讨J2EE架构模型，并阐述构成平台完整定义的其他要素。

# J2EE Architecture  

The J2EE architecture is a multitiered architecture. See Figure 2.1.  

J2EE架构是一种多层架构。参见图2.1。

![](images/5b965b6a5fdc0a045e64cb5a204a2d9b7448ceb1f2cd80ed60778ff25127cf98.jpg)  
Figure 2.1. J2EE architecture  

图2.1 J2EE架构

The J2EE architecture consists of the following tiers:  

J2EE架构由以下层次组成：

• Client tier—  The client tier interacts with the user and displays information from the system to the user. The J2EE platform supports different types of clients, including HTML clients, Java applets, and Java applications. Web tier—  The Web tier generates presentation logic and accepts user responses from the presentation clients, which are typically HTML clients, Java applets, and other Web clients. Based on the received client request, The presentation tier generates the appropriate response to a client request that it receives. In the J2EE platform, servlets and JSPs in a Web container implement this tier. Business tier—  This tier handles the core business logic of the application. The business tier provides the necessary interfaces to the underlying business service components. The business components are typically implemented as EJB components with support from an EJB container that facilitates the component life cycle and manages persistence, transactions, and resource allocation. EIS tier—  This tier is responsible for the enterprise information systems, including database systems, transaction processing systems, legacy systems, and enterprise resource planning systems. The EIS tier is the point where J2EE applications integrate with non-J2EE or legacy systems.  

• **客户端层**——该层与用户交互，并向用户展示系统信息。J2EE平台支持多种客户端类型，包括HTML客户端、Java小程序及Java应用程序。  
• **Web层**——该层生成表示逻辑，并接收来自表示层客户端（通常是HTML客户端、Java小程序及其他Web客户端）的用户响应。根据接收到的客户端请求，表示层会生成相应的响应。在J2EE平台中，由Web容器中的Servlet和JSP实现该层。  
• **业务层**——该层处理应用程序的核心业务逻辑，为底层业务服务组件提供必要的接口。业务组件通常以EJB组件形式实现，并依托EJB容器支持，由容器管理组件生命周期、持久化、事务及资源分配。  
• **EIS层**——该层负责企业信息系统，包括数据库系统、事务处理系统、遗留系统及企业资源规划系统。EIS层是J2EE应用程序与非J2EE系统或遗留系统集成的接入点。

# Java 2 Standard Edition  

J2SE is the underlying base platform for J2EE, hence a brief discussion on the J2SE platform is relevant to the J2EE platform. The J2SE platform includes two deliverables:  

J2SE是J2EE的底层基础平台，因此简要讨论J2SE平台对J2EE平台具有相关性。J2SE平台包含两个交付成果：

Java 2 SDK, Standard Edition (J2SE SDK) Java 2 Runtime Environment, Standard Edition (JRE)  

Java 2 SDK标准版（J2SE SDK）  
Java 2运行时环境标准版（JRE）

J2SE SDK, formerly the JDK, is the Java programming language's core API set. J2SE provides the Java language functionality as well as the core libraries required for Java development. The core libraries are the classes within the java.\* packages. In addition, J2SE provides auxiliary interfaces and libraries as extensions. It makes these standard extensions available as javax.\* packages.  

J2SE SDK（原称JDK）是Java编程语言的核心API集合。J2SE不仅提供Java语言功能，还包含Java开发所需的核心类库，这些核心类库位于`java.*`包中。此外，J2SE以扩展形式提供辅助接口和类库，并通过`javax.*`包提供这些标准扩展。

J2SE includes tools and APIs for developing applications with graphical user interfaces (GUIs), database access, directory access, Common Object Request Broker Architecture (CORBA), fine-grained security, input/output functions, and many other functions. See Table 2-1 .  

J2SE 提供了用于开发图形用户界面（GUI）应用程序、数据库访问、目录服务、公共对象请求代理架构（CORBA）、细粒度安全控制、输入/输出功能及其他众多功能的工具和API。具体参见表2-1。

Figure 2.2 shows the various components of the J2SE platform.   

图2.2展示了J2SE平台的各个组件。


<html><body><table><tr><td colspan="2">Table 2-1.</td></tr><tr><td>Function</td><td>Package Name</td></tr><tr><td>Graphical user interface</td><td>java.awt.*, javax.swing.*</td></tr><tr><td>Databaseaccess</td><td>java.sql.*</td></tr><tr><td>Directory access</td><td>javax.naming.*</td></tr><tr><td>CORBA</td><td>jaVax.rmi.CORBA.*</td></tr><tr><td>Security</td><td>java.security.*</td></tr><tr><td>Input/output</td><td>java.io.*</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表2-1.</td></tr><tr><td>功能</td><td>包名</td></tr><tr><td>图形用户界面</td><td>java.awt.*, javax.swing.*</td></tr><tr><td>数据库访问</td><td>java.sql.*</td></tr><tr><td>目录访问</td><td>javax.naming.*</td></tr><tr><td>CORBA</td><td>jaVax.rmi.CORBA.*</td></tr><tr><td>安全</td><td>java.security.*</td></tr><tr><td>输入/输出</td><td>java.io.*</td></tr></table></body></html>

![](images/7aecf3de45f08559a9087d94f88a62f47262ff2d4f83430ab1dfcf93c6f96bce.jpg)  
Figure 2.2. J2SE platform  

图2.2 J2SE平台

# J2EE Application Components and Containers  

The J2EE component container supports application components in the J2EE platform. A container is a service that provides the necessary infrastructure and support for a component to exist and for the component to provide its own services to clients. A container usually provides its services to the components as a Java compatible runtime environment.  

J2EE组件容器为J2EE平台中的应用程序组件提供支持。容器是一种服务，它为组件的存在以及组件向客户端提供服务所需的基础设施和支撑环境。容器通常以兼容Java的运行时环境形式向组件提供服务。

The core application components in the J2EE platform are as follows:  

J2EE平台的核心应用组件如下：

Java application components—  standalone Java programs that run inside an application container. Applet components—  Java applets that run inside an applet container, and which are usually supported via a Web browser. Servlets and JSPs—  Web-tier components that run in a Web container. Servlets and JSPs provide mechanisms for dynamic content preparation, processing, and formatting related to presentation. EJB components—  Coarse-grained business components that are run inside an EJB container (usually bundled in an application server product). EJB components, or enterprise beans, come in two types: session beans and entity beans. Session beans are enterprise beans that are suitable for processing or workflow. Session beans come in two flavors: stateful and stateless. A stateful session bean retains client state between method invocations. A stateless session bean does not retain client-specific state between client-invoked methods. Stateless session beans are used when no state needs to be stored between method invocations, and they may offer performance benefits over stateful session beans, which must be used when some state needs to be retained between invocations. Session bean instances pertain to a single user session and are not shared between users.  

Java应用组件——运行在应用容器内的独立Java程序。  
Applet组件——运行在Applet容器中的Java Applet，通常通过Web浏览器支持。  
Servlet和JSP——运行在Web容器中的Web层组件，提供与呈现相关的动态内容准备、处理和格式化机制。  

EJB组件——运行在EJB容器（通常捆绑在应用服务器产品中）的粗粒度业务组件。EJB组件（即企业级Bean）分为两种类型：会话Bean和实体Bean。  

会话Bean适用于处理或工作流，分为两种形式：  
- **有状态会话Bean**：在方法调用之间保留客户端状态  
- **无状态会话Bean**：不会在客户端调用的方法之间保留特定状态  

无状态会话Bean适用于方法调用间无需存储状态的场景，相比有状态会话Bean可能具有性能优势。当需要在调用间保留某些状态时，则必须使用有状态会话Bean。会话Bean实例仅属于单个用户会话，不在用户间共享。

Entity beans are used when a business component needs to be persisted and shared among multiple users. Entity bean persistence can be managed in two ways: bean-managed persistence (BMP) and container-managed persistence (CMP). BMP is used when the bean developer implements all mechanisms for persisting the state in the bean. CMP is used when the bean developer does not implement the persistence mechanisms in the bean. Instead, the bean developer specifies the necessary mapping between the bean attributes and the persistent storage and lets the container do the job.  

当业务组件需要持久化并在多个用户间共享时，会使用实体Bean。实体Bean的持久化可通过两种方式管理：Bean管理的持久化（BMP）和容器管理的持久化（CMP）。当Bean开发者需自行实现所有状态持久化机制时采用BMP；当Bean开发者未在Bean中实现持久化机制时则采用CMP。此时开发者只需指定Bean属性与持久化存储间的映射关系，由容器完成具体操作。

The core focus of the J2EE patterns in this book is the design and architecture of applications using servlets, $\mathsf{\Gamma}]\mathsf{S P S},$ , and enterprise bean components.  

本书中的J2EE模式核心聚焦于使用Servlet、$\mathsf{\Gamma}]\mathsf{S P S},$及企业级Bean组件进行应用程序设计与架构。

# Standard Services  

The J2EE platform specifies the following standard services that every J2EE product supports. These services include APIs, which every J2EE product must also provide to application components so that the components may access the services.  

J2EE平台规定了所有J2EE产品必须支持的以下标准服务。这些服务包括API接口，每个J2EE产品都必须向应用组件提供这些API，以便组件能够访问相关服务。

HTTP—  Standard protocol for Web communications. Clients can access HTTP via the java.net package • HTTP over Secure Socket Layer (HTTPS)—  Same as HTTP, but the protocol is used over Secure Socket Layer for security. JDBC—  A standard API to access database resources in a vendor-independent manner. JavaMail—  An API that provides a platform-independent and protocol-independent framework to build mail and messaging applications in Java. Java Activation Framework (JAF)—  APIs for an activation framework that is used by other packages, such as JavaMail. Developers can use JAF to determine the type of an arbitrary piece of data, encapsulate access to it, discover the operations available on it, and instantiate the appropriate bean to perform these operations. For example, JavaMail uses JAF to determine what object to instantiate depending on the mime type of the object. Remote Method Invocation/Internet Inter-ORB Protocol (RMI/IIOP)—  Protocol that enables Remote Method Invocation (RMI) programmers to combine the benefits of using the RMI APIs and robust CORBA IIOP communications protocol to communicate with CORBA-compliant clients that have been developed using any language compliant with CORBA. Java Interface Definition Language (JavaIDL)—  A service that incorporates CORBA into the Java platform to provide interoperability using standard IDL defined by the Object Management Group. Runtime components include Java ORB (Object Request Broker) for distributed computing using IIOP communication.  

HTTP——用于Web通信的标准协议。客户端可通过`java.net`包访问HTTP。  
• HTTPS（基于安全套接层的HTTP）——与HTTP相同，但该协议在安全套接层上运行以确保安全性。  
JDBC——以厂商无关方式访问数据库资源的标准化API。  
JavaMail——提供平台无关且协议无关的框架API，用于构建Java邮件和消息应用。  
Java激活框架（JAF）——为其他组件（如JavaMail）提供支持的激活框架API。开发者可通过JAF确定任意数据的类型、封装对其的访问、发现可执行操作，并实例化相应Bean以执行这些操作。例如JavaMail利用JAF根据对象的MIME类型决定实例化对象。  
远程方法调用/互联网ORB间协议（RMI/IIOP）——该协议使RMI程序员能结合RMI API的优势与健壮的CORBA IIOP通信协议，与符合CORBA标准的客户端（使用任何CORBA兼容语言开发）进行通信。  
Java接口定义语言（JavaIDL）——将CORBA集成至Java平台的服务，通过对象管理组定义的标准IDL实现互操作性。运行时组件包含用于IIOP通信分布式计算的Java ORB（对象请求代理）。

• Java Transaction API (JTA)—  A set of APIs that allows transaction management. Applications can use the JTA APIs to start, commit, and abort transactions. JTA APIs also allow the container to communicate with the transaction manager, and allow the transaction manager to communicate with the resource manager. JMS—  An API to communicate with MOM to enable point-to-point and publish/subscribe messaging between systems. JMS offers vendor independence for using MOMs in Java applications.   
Java Naming and Directory Interface (JNDI)—  A unified interface to access different types of naming and directory services. JNDI is used to register and look up business components and other service-oriented objects in a J2EE environment. JNDI includes support for Lightweight Directory Access Protocol (LDAP), the CORBA Object Services (COS) Naming Service, and the Java RMI Registry.  

• **Java事务API（JTA）**——一套支持事务管理的API集合。应用程序可通过JTA API启动、提交和终止事务。JTA API还允许容器与事务管理器通信，并支持事务管理器与资源管理器交互。  
• **JMS**——用于与消息中间件（MOM）通信的API，实现系统间点对点及发布/订阅的消息传递。JMS为Java应用程序使用MOM提供了厂商无关性。  
• **Java命名和目录接口（JNDI）**——访问各类命名与目录服务的统一接口。在J2EE环境中，JNDI用于注册和查找业务组件及其他面向服务的对象。其支持包括轻量级目录访问协议（LDAP）、CORBA对象服务（COS）命名服务和Java RMI注册表。

# J2EE Platform Roles  

The J2EE platform uses a set of defined roles to conceptualize the tasks related to the various workflows in the development and deployment life cycle of an enterprise application. These role definitions provide a logical separation of responsibilities for team members involved in the development, deployment, and management of a J2EE application. See Figure 2.3.  

J2EE平台采用一组预定义角色来概念化企业应用开发和部署生命周期中各个工作流的相关任务。这些角色定义为参与J2EE应用开发、部署和管理的团队成员提供了职责的逻辑划分。参见图2.3。

![](images/e82346f8e4bd6dafe8167065014f3eb148fb6746a530d21ca21521b1375731d5.jpg)  
Figure 2.3. J2EE platform roles  

图2.3 J2EE平台角色

The J2EE roles are as follows:  

J2EE角色划分如下：

J2EE product provider—  Provides component containers, such as application servers and Web servers, that are built to conform to the J2EE specification. The product provider must also provide tools to deploy components into the component containers. These tools are typically used by the deployer. In addition, the product provider must provide tools to manage and monitor the applications in the container. The system administrator typically uses these latter tools. This role is fulfilled by the product vendors. Application component provider—  Provides business components built using the J2EE APIs. These components include components for Web applications as well as for EJB applications. This role is fulfilled by programmers, developers, Web designers, and so forth. Application assembler—  Assembles, or puts together, a set of components into a deployable application. The assembler obtains the application components from the component providers. The application  

J2EE产品提供商——提供符合J2EE规范的组件容器，如应用服务器和Web服务器。产品提供商还必须提供将组件部署到组件容器中的工具，这些工具通常由部署人员使用。此外，产品提供商需提供用于管理和监控容器中应用程序的工具，系统管理员通常使用后一类工具。该角色由产品供应商承担。  
应用组件提供商——提供基于J2EE API构建的业务组件，包括Web应用组件和EJB应用组件。该角色由程序员、开发人员、网页设计师等承担。  
应用组装者——将一组组件组装成可部署的应用程序。组装者从组件提供商处获取应用组件。

assembler packages the application and provides the necessary assembly  

汇编器将应用程序打包并提供必要的装配

and deployment instructions to the deployer. Application deployer—  Deploys the assembled application into a J2EE container. The deployer may deploy Web applications into containers—Web containers, EJB containers, and so on—using the tools provided by the J2EE product provider. The deployer is responsible for installation, configuration, and execution of the J2EE application. System administrator—  Has the responsibility of monitoring the deployed J2EE applications and the J2EE containers. The system administrator uses the management and monitoring tools provided by the J2EE product provider. Tool provider—  Provides tools used for development, deployment, and packaging of components.  

以及部署说明提供给部署人员。应用部署者——将组装好的应用程序部署到J2EE容器中。部署者可以使用J2EE产品供应商提供的工具，将Web应用程序部署到各类容器中——Web容器、EJB容器等。部署者负责J2EE应用程序的安装、配置和运行。系统管理员——负责监控已部署的J2EE应用程序和J2EE容器。系统管理员使用J2EE产品供应商提供的管理和监控工具。工具供应商——提供用于组件开发、部署和打包的工具。

# Deployment Descriptors  

An application assembler puts a J2EE application together for deployment, and at the same time provides the assembly and deployment instructions in special files called deployment descriptors. The J2EE specification defines deployment descriptors as the contract between the application assembler and the deployer. Deployment descriptors are XML documents that include all the necessary configuration parameters required to deploy the J2EE application or J2EE components. Such configuration parameters specify external resource requirements, security requirements, environment parameters, and other component-specific and application-specific parameters. The deployer may use a deployment tool provided by the J2EE product provider to inspect, modify, customize, and add configuration parameters in these deployment descriptors to tailor the deployment to the capabilities of the deployment environment.  

应用组装者将J2EE应用程序整合以进行部署，同时通过名为部署描述符的特殊文件提供组装与部署指令。J2EE规范将部署描述符定义为应用组装者与部署者之间的契约。这些部署描述符是XML文档，包含部署J2EE应用程序或J2EE组件所需的所有配置参数，具体涵盖外部资源需求、安全要求、环境参数，以及其他组件级和应用级的特定参数。部署者可使用J2EE产品供应商提供的部署工具，对这些部署描述符中的配置参数进行检查、修改、定制和补充，从而使部署适配目标运行环境的能力特性。

Deployment descriptors offer flexibility for the development and deployment of J2EE application components by allowing changes to configurations and dependencies as needed during the different application phases: the development, deployment, and administration phases. Much of this flexibility is due to descriptors defining parameters in a declarative fashion, rather than having the parameters be embedded in the program code.  

部署描述符通过允许在不同应用阶段（开发阶段、部署阶段和管理阶段）按需修改配置和依赖关系，为J2EE应用组件的开发和部署提供了灵活性。这种灵活性主要源于描述符以声明式方式定义参数，而非将参数硬编码在程序代码中。

# J2EE Patterns and J2EE Platform  

As you can see from the overview, the J2EE platform standardizes a number of different technologies to provide a robust platform for building distributed multitier enterprise class applications. The J2EE platform is built on the J2SE platform. Since the J2SE platform forms the foundation of the J2EE platform, a Java developer can learn the J2EE technologies with relative ease.  

从概述中可以看出，J2EE平台通过标准化多项技术，为构建分布式多层企业级应用提供了稳健的平台基础。J2EE平台构建于J2SE平台之上，由于J2SE平台构成了J2EE平台的底层支撑，Java开发者能够较为轻松地掌握J2EE技术体系。

However, there is a belief that learning a new technology by itself is sufficient to make us adept at designing systems based on that new technology. We respectfully disagree with this. We believe that in addition to learning the technology, we need other insights to build successful systems. Patterns can help facilitate the process of knowledge accumulation and knowledge transfer. Patterns help us to document and communicate proven solutions to recurring problems in different environments. Using patterns effectively, we can prevent the “re-invent the wheel” syndrome.  

然而，有一种观点认为仅需学习新技术本身就足以让我们精通基于该技术的系统设计。我们对此持保留意见。我们认为除了掌握技术本身，构建成功的系统还需要其他洞见。模式能够促进知识积累和知识转移的过程。模式帮助我们记录并传递针对不同环境中反复出现问题的成熟解决方案。通过有效运用模式，我们可以避免"重复造轮子"的问题。

Our J2EE patterns are derived from our experience with the J2EE platform and technologies. The J2EE patterns described in this book address different requirements spread across all the J2EE tiers. In our tiered approach (see “The Tiered Approach”), we have modeled the J2EE multiple tiers as five tiers: client, presentation, business, integration, and resource tiers. This model allows us to logically separate responsibilities into individual tiers. In our model, for example, we separate the EIS tier into an integration tier and a resource tier. By doing so, we make it easier to separately address the requirements of integration and resources. Thus, the tiers in our model are a logical separation of concerns.  

我们的J2EE模式源自于在J2EE平台和技术领域的实践经验。本书所述的J2EE模式针对分布在所有J2EE分层中的不同需求。在分层架构方法（参见“分层架构方法”）中，我们将J2EE多层结构建模为五个层次：客户端层、表示层、业务层、集成层和资源层。该模型使我们能够将职责逻辑性地划分到各个独立层级。例如在我们的模型中，我们将EIS层拆分为集成层和资源层，从而更便捷地分别处理集成需求与资源需求。因此，该模型中的层级划分实质上是关注点的逻辑分离。

We've categorized the J2EE patterns described in this book into three of these five tiers—presentation, business, and integration. In our opinion, the client and resource tiers are not direct concerns of the J2EE platform. The patterns related to servlets and JSP technologies are described in Chapter 7, “Presentation Tier Patterns.” The patterns related to enterprise beans and JNDI technologies, and those related to bridging the presentation and business tier components, are described in Chapter 8, “Business Tier Patterns.” Finally, the patterns related to JDBC and JMS technologies, aimed at bridging the business tier with the resource tier, are described in Chapter 9, “Integration Tier Patterns.”  

我们将本书描述的J2EE模式归类至五层架构中的三层——**表示层**、**业务层**和**集成层**。我们认为客户端层与资源层并非J2EE平台的直接关注点。  

- 与Servlet及JSP技术相关的模式详见第7章《表示层模式》  
- 涉及企业级Bean、JNDI技术以及连接表示层与业务层组件的模式收录于第8章《业务层模式》  
- 最后，关于JDBC和JMS技术、旨在桥接业务层与资源层的模式阐述于第9章《集成层模式》

Because our most intensive work has been in these core areas of the J2EE platform, we currently do not address patterns other than these aforementioned technologies. We feel that the developer community gains a huge benefit if we first document the patterns in these core areas. We also believe that this categorization allows us to be flexible, and as new patterns are observed, we will categorize and document them.  

由于我们的核心工作集中在J2EE平台的这些关键领域，目前我们仅针对上述技术相关的模式进行探讨。我们认为优先完善这些核心领域的模式文档能为开发者社区带来显著价值。这种分类方式也保持了灵活性，未来观察到新涌现的模式时，我们将对其进行归类并形成文档。

We believe that these patterns will prove useful to you as they did to us and our fellow architects. They may be reused as solutions to the problems you may encounter during your J2EE design and architecture experience. We are also aware that patterns evolve over time, and we expect that our patterns are no exception. The patterns presented here have been refined many times. They have been written and rewritten to make them better. This process of evolution will continue.  

我们相信这些模式将如它们对我们及同行架构师们一样，对您同样大有裨益。它们可作为解决方案被复用，以应对您在J2EE设计与架构实践中可能遇到的问题。我们也深知模式会随时间演进，我们的模式亦不例外。此处呈现的模式已历经多次精炼，通过反复推敲打磨才日臻完善——这种进化过程将持续下去。

# Summary  

While this chapter provided an overview of the J2EE platform, it also included a flurry of terminologies and acronyms. If you are interested in learning more, the following online resources are recommended:  

本章在概述J2EE平台的同时，也涉及了大量专业术语和缩写词。如需深入探究，推荐参阅以下在线资源：

The Story of the Java   
Platform—http://java.sun.com/nav/whatis/storyofjava.html   
Java Technology—An Early   
History—http://java.sun.com/features/1998/05/birthday.html   
Java Community   
Process—http://java.sun.com/aboutJava/communityprocess/   
J2SE Platform   
Documentation—http://java.sun.com/docs/index.html   
J2EE home page—http://java.sun.com/j2ee   
J2EE   
Blueprints—http://java.sun.com/j2ee/blueprints/index.html   
EJB home page—http://java.sun.com/products/ejb   
Servlets home   
page—http://www.java.sun.com/products/servlet   
JSP home page—http://www.java.sun.com/products/jsp   
JDBC home page—http://www.java.sun.com/products/jdbc   
JMS home page—http://www.java.sun.com/products/jms   
JNDI home page—http://java.sun.com/products/jndi   
Connector home page—http://java.sun.com/j2ee/connector  

Java平台发展史—http://java.sun.com/nav/whatis/storyofjava.html  
Java技术早期历史—http://java.sun.com/features/1998/05/birthday.html  
Java社区进程—http://java.sun.com/aboutJava/communityprocess/  
J2SE平台文档—http://java.sun.com/docs/index.html  
J2EE主页—http://java.sun.com/j2ee  
J2EE蓝图—http://java.sun.com/j2ee/blueprints/index.html  
EJB主页—http://java.sun.com/products/ejb  
Servlet主页—http://www.java.sun.com/products/servlet  
JSP主页—http://www.java.sun.com/products/jsp  
JDBC主页—http://www.java.sun.com/products/jdbc  
JMS主页—http://www.java.sun.com/products/jms  
JNDI主页—http://java.sun.com/products/jndi  
连接器主页—http://java.sun.com/j2ee/connector

# Part II: DESIGN CONSIDERATIONS, BAD PRACTICES, AND REFACTORINGS  

Part II includes the following three chapters:  

第二部分包含以下三个章节：

• Chapter 3—Presentation Tier Design Considerations and Bad Practices   
• Chapter 4—Business Tier Design Considerations and Bad Practices   
• Chapter 5—J2EE Refactorings  

• 第3章——表示层设计考量与不良实践  
• 第4章——业务层设计考量与不良实践  
• 第5章——J2EE重构技术

Chapter 3 and 4, as their names suggest, discuss various design considerations and bad practices.  

第3章和第4章，正如其名所示，探讨了各类设计考量与不良实践。

When applying the patterns from the catalog, developers will need to consider numerous adjunct design issues, such as the ones discussed in these chapters. These include issues affecting numerous aspects of the system, including security, data integrity, manageability, and scalability.  

在应用该模式目录中的模式时，开发者需要考虑诸多辅助设计问题，例如这些章节所讨论的内容。这些问题涉及系统多个层面的考量，包括安全性、数据完整性、可管理性以及可扩展性。

Many of these design issues could be captured in pattern form, as well, although they primarily focus on issues at a lower level of abstraction than those described in the J2EE Pattern Catalog. Instead of documenting each as a pattern, we have chosen to document them more informally, simply describing each as a design issue to be considered when implementing systems based on the pattern catalog. While a complete discussion of each issue is outside the scope of this book, we wanted to mention these concerns, and encourage the reader to investigate these issues.  

这些设计问题大多也能以模式形式呈现，尽管它们主要关注的是比《J2EE模式目录》所述更底层的抽象问题。我们选择以非正式方式记录它们，而非逐一编撰为模式，仅将其描述为基于该模式目录实现系统时需考量的设计问题。虽然完整探讨每个问题超出了本书范围，但我们仍希望提及这些要点，并鼓励读者深入研究。

Chapter 3 and 4 also highlight less than optimal ways to solve certain problems—solutions which we term bad practices. Each bad practice provides a brief problem summary accompanied by a list of solution references. The solution references are a list of pointers to other sections of the book with related material, suggesting preferred ways to solve these problems. Typically, these references are to a pattern in the catalog, to a refactoring, or to a combination of the two.  

第3章和第4章还重点介绍了一些解决特定问题的非最优方案——我们称之为**不良实践**。每个不良实践都附有简要的问题描述及对应的解决方案索引。这些索引指向书中其他相关内容的章节，推荐了解决这些问题的优选方案。通常，这些索引会关联到目录中的某个模式、重构方法，或两者的组合。

Chapter 5 presents refactorings for the J2EE Platform. The presentation format of this chapter is based on that in Martin Fowler's book Refactoring [Fowler], an excellent guide for those wishing to learn more about software design. Each refactoring identifies a simple problem and solution statement, offers motivations for improving the problem, and suggests mechanics for doing so.  

第5章介绍了针对J2EE平台的重构方法。本章的呈现格式基于Martin Fowler所著《重构》[Fowler]一书，该书是学习软件设计的绝佳指南。每个重构方案都包含简明的问题描述与解决方案，阐明改进动机，并提供具体实施步骤。

# Chapter 3. PRESENTATION TIER DESIGN CONSIDERATIONS AND BAD PRACTICES  

# Topics in This Chapter  

Presentation Tier Design Considerations Presentation Tier Bad Practices  

表现层设计考量 表现层反模式

# Presentation Tier Design Considerations  

When developers apply the presentation patterns that appear in the catalog in this book, there will be adjunct design issues to consider. These issues relate to designing with patterns at a variety of levels, and they may affect numerous aspects of a system, including security, data integrity, manageability, and scalability. We discuss these issues in this chapter.  

当开发人员应用本书目录中呈现的表示层模式时，还需考虑相关的设计问题。这些问题涉及多层次模式设计，可能影响系统的多个方面，包括安全性、数据完整性、可管理性和可扩展性。本章将对这些议题展开探讨。

Although many of these design issues could be captured in pattern form, we chose not to do so because they focus on issues at a lower level of abstraction than the presentation patterns in the catalog. Rather than documenting each issue as a pattern, we have chosen to document them more informally: We simply describe each issue as one that you should consider when implementing systems based on the pattern catalog.  

尽管这些问题大多能以模式形式表述，但我们选择不这样做，因为它们关注的抽象层级低于本目录中的表示层模式。我们未将每个问题单独记录为模式，而是采用更非正式的方式：仅将其描述为基于本模式目录实现系统时需考量的要点。

# Session Management  

The term user session describes a conversation that spans multiple requests between a client and a server. We rely on the concept of user session in the discussion in the following sections.  

术语**用户会话**描述了客户端与服务器之间跨越多个请求的对话。在后续章节的讨论中，我们将基于用户会话这一概念展开。

# Session State on Client  

Saving session state on the client involves serializing and embedding the session state within the view markup HTML page that is returned to the client.  

在客户端保存会话状态需要将序列化后的会话状态嵌入到返回给客户端的视图标记HTML页面中。

There are benefits to persisting session state on the client:  

将会话状态持久化在客户端具有以下优势：

It is relatively easy to implement.   
It works well when saving minimal amounts of state.  

实现起来相对简单。  
在保存少量状态时表现良好。

Additionally, this strategy virtually eliminates the problem of replicating state across servers in those situations that implement load balancing across physical machines.  

此外，该策略在跨物理机实现负载均衡的场景中，几乎彻底解决了服务器间状态复制的问题。

There are two common strategies for saving session state on the client—HTML hidden fields and HTTP cookies—and we describe these strategies below. A third strategy entails embedding the session state directly into the URIs referenced in each page (for example, <form action $\varepsilon$ someServlet?var1 $=$ x&var2=y method $=\mathrm{GET}>$ ). Although this third strategy is less common, it shares many of the limitations of the following two methods.  

客户端保存会话状态的两种常见策略是**HTML隐藏字段**和**HTTP Cookie**，下文将详述这两种方法。第三种策略则是将会话状态直接嵌入每个页面的URI中（例如 `<form action=someServlet?var1=x&var2=y method=GET>`）。尽管第三种策略较为少见，但它与前两种方法存在许多共同的局限性。

# HTML Hidden Fields  

Although it is relatively easy to implement this strategy, there are numerous drawbacks to using HTML hidden fields to save session state on the client. These drawbacks are especially apparent when saving large amounts of state. Saving large amounts of state negatively affects performance. Since all view markup now embeds or contains the state, it must traverse the network with each request and response.  

虽然实现这一策略相对容易，但使用HTML隐藏字段在客户端保存会话状态存在诸多弊端。当保存大量状态时，这些弊端尤为明显。保存大量状态会对性能产生负面影响。由于所有视图标记现在都嵌入或包含状态数据，这些数据必须随每个请求和响应在网络中传输。

Additionally, when you utilize hidden fields to save session state, the persisted state is limited to string values, so any object references must be “stringified”. It is also exposed in clear text in the generated HTML source, unless specifically encrypted.  

此外，当使用隐藏字段保存会话状态时，持久化状态仅限于字符串值，因此任何对象引用都必须进行“字符串化”处理。除非特别加密，否则这些状态会以明文形式暴露在生成的HTML源码中。

# HTTP Cookies  

Similar to the hidden fields strategy, it is relatively easy to implement the HTTP cookies strategy. This strategy unfortunately shares many of the same drawbacks as well. In particular, saving large amounts of state causes performance to suffer, because all the session state must traverse the network for each request and response.  

与隐藏字段策略类似，HTTP Cookies策略的实现相对简单。遗憾的是，该策略同样存在许多类似的缺陷。尤其是当保存大量状态时会导致性能下降，因为所有会话状态必须在每个请求和响应中通过网络传输。

We also run into size and type limitations when saving session state on the client. There are limitations on the size of cookie headers, and this limits the amount of data that can be persisted. Moreover, as with hidden fields, when you use cookies to save session state, the persisted state is limited to stringified values.  

在客户端保存会话状态时，我们同样会遇到大小和类型的限制。Cookie头部存在大小限制，这制约了可持久化数据的容量。此外，与隐藏字段类似，当使用Cookie保存会话状态时，持久化状态仅限于字符串化的值。

# Security Concerns of Client-Side Session State  

When you save session state on the client, security issues are introduced that you must consider. If you do not want your data exposed to the client, then you need to employ some method of encryption to secure the data.  

在客户端保存会话状态时，会引入必须考虑的安全问题。若您不希望数据暴露给客户端，则需要采用某种加密方法来保护数据安全。

Although saving session state on the client is relatively easy to implement initially, it has numerous drawbacks that take time and thought to overcome. For projects that deal with large amounts of data, as is typical with enterprise systems, these drawbacks far outweigh the benefits.  

尽管在客户端保存会话状态初期实现相对简单，但其存在诸多弊端，需要投入时间和精力去克服。对于处理海量数据的企业级系统项目而言，这些弊端远超过其优势。

# Session State in the Presentation Tier  

When session state is maintained on the server, it is retrieved using a session ID and typically persists until one of the following occurs:  

当会话状态由服务器维护时，会通过会话ID进行检索，通常将持续存在直至发生以下情况之一：

A predefined session timeout is exceeded. • The session is manually invalidated. The state is removed from the session.  

预定义的会话超时已过期。• 会话被手动置为无效。状态已从会话中移除。

Note that after a server shutdown, some in-memory session management mechanisms may not be recoverable.  

请注意，服务器关闭后，某些基于内存的会话管理机制可能无法恢复。

It is clearly preferable for applications with large amounts of session state to save their session state on the server. When state is saved on the server, you are not constrained by the size or type limitations of client-side session management. Additionally, you avoid raising the security issues associated with exposing session state to the client, and you do not have the performance impact of passing the session state across the network on each request.  

对于具有大量会话状态的应用程序，显然更适宜将会话状态保存在服务器端。当状态存储在服务器时，开发者既不受客户端会话管理的容量或类型限制约束，又能避免因向客户端暴露会话状态引发的安全问题，同时消除了每次请求时通过网络传输会话状态带来的性能损耗。

You also benefit from the flexibility offered by this strategy. By persisting your session state on the server, you have the flexibility to trade off simplicity versus complexity and to address scalability and performance.  

采用此策略还能获得灵活性优势。通过在服务器端持久化会话状态，您可灵活权衡简单性与复杂性，并应对可扩展性和性能问题。

If you save session state on the server, you must decide how to make this state available to each server from which you run the application. This issue is one that requires you to deal with the replication of session state among clustered software instances across load-balanced hardware, and it is a multidimensional problem. However, numerous application servers now provide a variety of out-of-the-box solutions. There are solutions available that are above the application server level. One such solution is to maintain a “sticky” user experience, where you use traffic management software, such as that available from Resonate [Resonate], to route users to the same server to handle each request in their session. This is also referred to as server affinity.  

若在服务器端保存会话状态，必须确保该状态对运行应用的每台服务器均可用。此问题涉及负载均衡硬件集群中各软件实例间的会话状态复制，属于多维难题。不过当前众多应用服务器已提供多种开箱即用的解决方案。此外还存在应用服务器层级之上的解决方案，例如通过流量管理软件（如Resonate[Resonate]提供的方案）维持"粘性"用户体验——将用户请求始终路由至同一台服务器处理，该技术亦称为**服务器亲和性**。

Another alternative is to store session state in either the business tier or the resource tier. Enterprise JavaBeans components may be used to hold session state in the business tier, and a relational database may be used in the resource tier. For more information on the business-tier option, please refer to “Using Session Beans”.  

另一种方案是将会话状态存储在业务层或资源层。在业务层可使用 Enterprise JavaBeans 组件保存会话状态，而在资源层则可使用关系型数据库。有关业务层方案的更多信息，请参阅《使用会话 Bean》。

# Controlling Client Access  

There are numerous reasons to restrict or control client access to certain application resources. In this section, we examine two of these scenarios.  

限制或控制客户端对特定应用资源的访问存在诸多必要性。本节将探讨其中两种典型场景。

One reason to restrict or control client access is to guard a view, or portions of a view, from direct access by a client. This issue may occur, for example, when only registered or logged-in users should be allowed access to a particular view, or if access to portions of a view should be restricted to users based on role.  

限制或控制客户端访问的一个原因是为了保护视图（或视图的某些部分）免受客户端的直接访问。例如，当仅允许已注册或登录用户访问特定视图时，或需要根据用户角色限制对视图部分内容的访问时，就可能出现这种情况。

After describing this issue, we discuss a secondary scenario relating to controlling the flow of a user through the application. The latter discussion points out concerns relating to duplicate form submissions, since multiple submissions could result in unwanted duplicate transactions.  

在阐述该问题后，我们进一步讨论了控制用户流程的次要场景。后续讨论指出需关注重复表单提交问题，因为多次提交可能导致不必要的事务重复。

# Guarding a View  

In some cases, a resource is restricted in its entirety from being accessed by certain users. There are several strategies that accomplish this goal. One is including application logic that executes when the controller or view is processed, disallowing access. A second strategy is to configure the runtime system to allow access to certain resources only via an internal invocation from another application resource. In this case, access to these resources must be routed through another presentation-tier application resource, such as a servlet controller. Access to these restricted resources is not available via a direct browser invocation.  

在某些情况下，某些资源会被完全限制特定用户访问。实现此目标有若干策略：其一是在控制器或视图处理时执行应用逻辑以禁止访问；其二是配置运行时系统，仅允许通过其他应用资源的内部调用来访问特定资源。这种情况下，必须通过另一个表示层应用资源（如Servlet控制器）路由访问这些受限资源。直接通过浏览器调用无法访问这些受限制资源。

One common way of dealing with this issue is to use a controller as a delegation point for this type of access control. Another common variation involves embedding a guard directly within a view. We cover controller-based resource protection in “Presentation Tier Refactorings” and in the pattern catalog, so we will focus here on view-based control strategies. We describe these strategies first, before considering the alternative strategy of controlling access through configuration.  

处理该问题的常见方式之一是使用控制器作为此类访问控制的委托点。另一种常见变体是在视图中直接嵌入守卫逻辑。我们已在《表示层重构》和模式目录中探讨了基于控制器的资源保护方案，因此本文将重点聚焦于基于视图的控制策略。在讨论通过配置实现访问控制的替代方案之前，我们将首先阐述这些视图控制策略。

# Embedding Guard Within View  

There are two common variations for embedding a guard within a view's processing logic. One variation blocks access to an entire resource, while the other blocks access to portions of that resource.  

在视图处理逻辑中嵌入守卫机制通常有两种常见变体。一种变体会阻止对整个资源的访问，而另一种则仅阻止对该资源部分内容的访问。

# Including an All-or-Nothing Guard per View  

In some cases, the logic embedded within the view processing code allows or denies access on an all-or-nothing basis. In other words, this logic prevents a particular user from accessing a particular view in its entirety. Typically, this type of guard is better encapsulated within a centralized controller, so that the logic is not sprinkled throughout the code. This strategy is reasonable to use when only a small fraction of pages need a guard. Typically, this scenario occurs when a nontechnical individual needs to rotate a small number of static pages onto a site. If the client must still be logged into the site to view these pages, then add a custom tag helper to the top of each page to complete the access check, as shown in Example 3.1.  

在某些情况下，视图处理代码中嵌入的逻辑会以全有或全无的方式允许或拒绝访问。换句话说，该逻辑会完全阻止特定用户访问特定视图。通常，这类防护逻辑更适合封装在集中式控制器中，以避免代码中四处散落此类逻辑。当仅有少量页面需要防护时，采用该策略是合理的。典型场景发生在非技术人员需要将少量静态页面轮换到站点时。若客户端仍需登录站点才能查看这些页面，则如示例3.1所示，在每个页面顶部添加自定义标签助手来完成访问检查。

# Example 3.1 Including an All-or-Nothing Guard per View  

<%@ taglib uri $=$ "/WEB-INF/corej2eetaglibrary.tld" prefix $\equiv$ "corePatterns" %>   
<corePatterns:guard/>   
<HTML>   
</HTML>  

<%@ taglib uri = "/WEB-INF/corej2eetaglibrary.tld" prefix ≡ "corePatterns" %>  
<corePatterns:guard/>  
<HTML>  
</HTML>

# Including a Guard for Portions of a View  

In other cases, the logic embedded within the view processing code simply denies access to portions of a view. This secondary strategy can be used in combination with the previously mentioned all-or-nothing strategy. To clarify this discussion, let's use an analogy of controlling access to a room in a building. The all-or-nothing guard tells users whether they can walk into the room or not, while the secondary guard logic tells users what they are allowed to see once they are in the room. Following are some examples of why you might want to utilize this strategy.  

在其他情况下，视图处理代码中嵌入的逻辑会直接拒绝对视图某些部分的访问。这种次级策略可以与前述的"全有或全无"策略结合使用。为便于理解，我们用一个建筑物房间的访问控制来类比："全有或全无"守卫决定用户能否进入房间，而次级守卫逻辑则决定用户进入房间后允许看到的内容。以下是可能需要采用该策略的若干场景示例。

# Portions of View Not Displayed Based on User Role  

A portion of the view might not be displayed based on the user's role. For example, when viewing her organizational information, a manager has access to a subview dealing with administering review materials for her employees. An employee might only see his own organizational information, and be restricted from the portions of the user interface that allow access to any review-related information, as shown in Example 3.2.  

根据用户角色的不同，视图的某些部分可能不会显示。例如，在查看组织信息时，经理可以访问用于管理下属员工评审材料的子视图。而普通员工仅能查看自己的组织信息，且无法访问用户界面中任何与评审相关的功能区域，如示例3.2所示。

# Example 3.2 Portions of View Not Displayed Based on User Role  

<%@ taglib uri $=$ "/WEB-INF/corej2eetaglibrary.tld" prefix $\equiv$ "corePatterns" %>  

<%@ taglib uri="/WEB-INF/corej2eetaglibrary.tld" prefix="corePatterns" %>

<corePatterns:guard role $=$ "manager">   
<b>This should be seen only by managers!</b>   
<corePatterns:guard/>   
</HTML>  

<corePatterns:guard role $="manager">  
<b>该内容仅限管理员查看！</b>  
<corePatterns:guard/>  
</HTML>

# Portions of View Not Displayed Based on System State or Error Conditions  

Depending on the system environment, the display layout may be modified. For example, if a user interface for administering hardware CPUs is used with a single-CPU hardware device, portions of the display that relate solely to multiple CPU devices may not be shown.  

根据系统环境的不同，显示布局可能会进行调整。例如，当用于管理硬件CPU的用户界面在单CPU硬件设备上运行时，与多CPU设备相关的显示部分可能不会呈现。

# Guarding by Configuration  

To restrict the client from directly accessing particular views, you can configure the presentation engine to allow access to these resources only via other internal resources, such as a servlet controller using a RequestDispatcher. Additionally, you can leverage the security mechanisms that are built into the Web container, based on the servlet specification, version 2.2 and later. Security constraints are defined in the deployment descriptor, called web.xml.  

为限制客户端直接访问特定视图，可配置呈现引擎仅允许通过其他内部资源（例如使用`RequestDispatcher`的Servlet控制器）访问这些资源。此外，可基于Servlet 2.2及以上版本规范，利用Web容器内置的安全机制。安全约束定义在名为`web.xml`的部署描述符中。

The basic and form-based authentication methods, also described in the Servlet specification, rely on this security information. Rather than repeat the specification here, we refer you to the current specification for details on these methods. (See http://java.sun.com/products/servlet/index.html.)  

**基础认证**和**表单认证**这两种方式（在Servlet规范中亦有描述）均依赖于此类安全信息。为避免重复规范内容，建议查阅现行规范以获取这些认证方法的详细说明。（参见：http://java.sun.com/products/servlet/index.html）

So that you understand what to expect when adding declarative security constraints to your environment, we present a brief discussion of this topic and how it relates to all-or-nothing guarding by configuration. Finally, we describe one simple and generic alternative for all-or-nothing protection of a resource.  

为使您了解在环境中添加声明式安全约束时的预期效果，我们将简要讨论该主题及其与通过配置实现的"全有或全无"防护机制的关系。最后，我们将描述一种简单通用的替代方案，用于实现对资源的"全有或全无"保护。

# Resource Guards via Standard Security Constraints  

Applications may be configured with a security constraint, and this declarative security may be used programmatically to control access based on user roles. Resources can be made available to certain roles of users and disallowed to others.  

应用程序可通过安全约束进行配置，这种声明式安全机制能以编程方式实现基于用户角色的访问控制。资源可被设置为仅对特定角色用户开放，而对其他角色禁用。

Moreover, as described in “Embedding Guard Within View”, portions of a view can be restricted based on these user roles as well. If there are certain resources that should be disallowed in their entirety for all direct browser requests, as in the all-or-nothing scenario described in the previous section, then those resources can be constrained to a security role that is not assigned to any users. Resources configured in this manner remain inaccessible to all direct browser requests, as long as the security role remains unassigned. See Example 3.3 for an excerpt of a web.xml configuration file that defines a security role to restrict direct browser access.  

此外，如“在视图中嵌入防护机制”所述，视图的某些部分也可以基于这些用户角色进行限制。如果某些资源需要完全禁止所有直接浏览器请求访问（如前文所述的全有或全无场景），则可将这些资源约束至一个未分配给任何用户的安全角色。只要该安全角色保持未分配状态，以此方式配置的资源对所有直接浏览器请求将始终保持不可访问。参见示例3.3中定义安全角色以限制直接浏览器访问的web.xml配置文件片段。

The role name is “sensitive” and the restricted resources are named sensitive1.jsp, sensitive2.jsp, and sensitive3.jsp. Unless a user or group is assigned the “sensitive” role, then clients will not be able to directly access these Java Server Pages (JSPs). At the same time, since internally dispatched requests are not restricted by these security constraints, a request that is handled initially by a servlet controller and then forwarded to one of these three resources will indeed receive access to these JSPs.  

角色名称为“sensitive”，受限制资源分别命名为sensitive1.jsp、sensitive2.jsp和sensitive3.jsp。除非为用户或组分配了“sensitive”角色，否则客户端将无法直接访问这些Java Server Pages（JSP）。同时，由于内部派发的请求不受这些安全约束限制，由Servlet控制器处理并转发至这三个资源之一的请求仍能正常访问这些JSP页面。

Finally, note that there is some inconsistency in the implementation of this aspect of the Servlet specification version 2.2 across vendor products. Servers supporting Servlet 2.3 should all be consistent on this issue.  

最后需注意，各厂商产品对Servlet规范2.2版本中该特性的**实现**存在不一致性。支持Servlet 2.3的服务器在此问题上应保持统一。

# Example 3.3 Unassigned Security Role Provides All-or-Nothing Control  

<security-constraint> <web-resource-collection> <web-resource-name>SensitiveResources </web-resource-name> <description $>\mathbb{A}$ Collection of Sensitive Resources </description> <url-pattern>/trade/jsp/internalaccess/ sensitive1.jsp $\scriptscriptstyle{1<}$ </url-pattern> <url-pattern>/trade/jsp/internalaccess/ sensitive2.jsp $\scriptscriptstyle{1<}$ </url-pattern> <url-pattern>/trade/jsp/internalaccess/ sensitive3.jsp $\scriptscriptstyle{1<}$ </url-pattern> <http-method>GET $<$ </http-method> <http-method>POST</http-method> </web-resource-collection> <auth-constraint> <role-name>sensitive</role-name> </auth-constraint>  

```xml
<security-constraint> 
    <web-resource-collection> 
        <web-resource-name>敏感资源</web-resource-name> 
        <description>敏感资源集合</description> 
        <url-pattern>/trade/jsp/internalaccess/sensitive1.jsp</url-pattern> 
        <url-pattern>/trade/jsp/internalaccess/sensitive2.jsp</url-pattern> 
        <url-pattern>/trade/jsp/internalaccess/sensitive3.jsp</url-pattern> 
        <http-method>GET</http-method> 
        <http-method>POST</http-method> 
    </web-resource-collection> 
    <auth-constraint> 
        <role-name>sensitive</role-name> 
    </auth-constraint>
```

# Resource Guards via Simple and Generic Configuration  

There is a simple and generic way to restrict a client from directly accessing a certain resource, such as a JSP. This method requires no configuration file modifications, such as those shown in Example 3.3. This method simply involves placing the resource under the /WEB-INF/ directory of the Web application. For example, to block direct browser access to a view called info.jsp in the securityissues Web application, we could place the JSP source file in the following subdirectory: /securityissues/WEB-INF/internalaccessonly/info.jsp.  

有一种简单通用的方法可以限制客户端直接访问特定资源（例如JSP），该方法无需修改配置文件（如示例3.3所示）。只需将资源放置在Web应用程序的`/WEB-INF/`目录下即可。例如，要阻止浏览器直接访问securityissues Web应用中名为`info.jsp`的视图，可将该JSP源文件置于以下子目录：`/securityissues/WEB-INF/internalaccessonly/info.jsp`。

Direct public access is disallowed to the /WEB-INF/ directory, its subdirectories, and consequently to info.jsp. On the other hand, a controller servlet can still forward to this resource, if desired. This is an all-or-nothing method of control, since resources configured in this manner are disallowed in their entirety to direct browser access.  

禁止直接通过公开途径访问 `/WEB-INF/` 目录及其子目录，因此也无法直接访问 `info.jsp`。但如有需要，控制器 Servlet 仍可转发至该资源。这是一种全有或全无的控制方式，因为以这种方式配置的资源将完全禁止浏览器直接访问。

For an example, please refer to “Hide Resource From a Client”.  

例如，请参考“向客户端隐藏资源”。

# Duplicate Form Submissions  

Users working in a browser client environment may use the Back button and inadvertently resubmit the same form they had previously submitted, possibly invoking a duplicate transaction. Similarly, a user might click the Stop button on the browser before receiving a confirmation page, and subsequently resubmit the same form. In most cases, we want to trap and disallow these duplicate submissions, and using a controlling servlet provides a control point for addressing this problem.  

在浏览器客户端环境中操作的用户可能会使用**后退**按钮，无意中重新提交之前已提交过的表单，从而可能触发重复事务。类似地，用户也可能在收到确认页面前点击浏览器的**停止**按钮，随后再次提交相同表单。大多数情况下，我们需要捕获并禁止这类重复提交行为，而通过使用控制型Servlet可为此问题提供管控节点。

This strategy addresses the problem of duplicate form submissions. A synchronizer token is set in a user's session and included with each form returned to the client. When that form is submitted, the synchronizer token in the form is compared to the synchronizer token in the session. The tokens should match the first time the form is submitted. If the tokens do not match, then the form submission may be disallowed and an error returned to the user. Token mismatch may occur when the user submits a form, then clicks the Back button in the browser and attempts to resubmit the same form.  

该策略用于解决重复提交表单的问题。系统会在用户会话中设置一个同步令牌，并将其包含在返回给客户端的每个表单中。当表单提交时，系统会比对表单中的同步令牌与会话中的同步令牌。首次提交表单时两者应当匹配。若令牌不匹配，则可能禁止表单提交并向用户返回错误。当用户提交表单后点击浏览器返回按钮并尝试重新提交同一表单时，就可能出现令牌不匹配的情况。

On the other hand, if the two token values match, then we are confident that the flow of control is exactly as expected. At this point, the token value in the session is modified to a new value and the form submission is accepted.  

另一方面，若两个令牌值匹配，则可确信控制流完全符合预期。此时会话中的令牌值将被更新为新值，表单提交请求即被接受。

You may also use this strategy to control direct browser access to certain pages, as described in the sections on resource guards. For example, assume a user bookmarks page A of an application, where page A should only be accessed from page B and C. When the user selects page A via the bookmark, the page is accessed out of order and the synchronizer token will be in an unsynchronized state, or it may not exist at all. Either way, the access can be disallowed if desired.  

您也可以采用此策略来控制浏览器对特定页面的直接访问，如资源防护章节所述。例如，假设用户将应用程序的页面A添加为书签，而页面A本应仅允许从页面B和C跳转访问。当用户通过书签直接访问页面A时，该访问属于非正常顺序跳转，此时同步令牌将处于未同步状态，甚至可能根本不存在。无论哪种情况，均可按需禁止此类访问。

Please refer to “Introduce Synchronizer Token in the “Presentation Tier Refactorings section for an example of this strategy.  

请参阅“表示层重构”章节中的“引入同步令牌”部分以获取该策略的示例。

# Validation  

It is often desirable to perform validation both on the client and on the server. Although client validation processing is typically less sophisticated than server validation, it provides high-level checks, such as whether a form field is empty. Server-side validation is often much more comprehensive. While both types of processing are appropriate in an application, it is not recommended to include only client-side validation. One major reason not to rely solely on client-side validation is that client-side scripting languages are user-configurable and thus may be disabled at any time.  

通常需要在客户端和服务器端同时执行验证。虽然客户端验证的处理逻辑通常不如服务器端验证复杂，但它能提供基础检查（例如表单字段是否为空）。服务器端验证往往更加全面。尽管两种验证方式在应用中各有适用场景，但仅依赖客户端验证是不推荐的。一个重要原因是：客户端脚本语言可由用户配置，因此可能随时被禁用。

Detailed discussion of validation strategies is outside the scope of this book. At the same time, we want to mention these issues as ones to consider while designing your systems, and hope you will refer to the existing literature in order to investigate further.  

关于验证策略的详细讨论超出了本书的范围。同时，我们希望提及这些问题作为系统设计时需要考量的要点，并建议您参考现有文献以进行深入研究。

# Validation on Client  

Input validation is performed on the client. Typically, this involves embedding scripting code, such as JavaScript, within the client view. As stated, client-side validation is a fine complement for server-side validation, but should not be used alone.  

输入验证在客户端执行。通常，这涉及在客户端视图中嵌入脚本代码（例如JavaScript）。如前所述，客户端验证是服务端验证的良好补充，但不应单独使用。

# Validation on Server  

Input validation is performed on the server. There are several typical strategies for doing server validation. These strategies are form-centric validation and validation based on abstract types.  

输入验证在服务器端执行。服务器验证存在几种典型策略，包括以表单为中心的验证和基于抽象类型的验证。

# Form-Centric Validation  

The form-centric validation strategy forces an application to include lots of methods that validate various pieces of state for each form submitted. Typically, these methods overlap with respect to the logic they include, such that reuse and modularity suffer. Since there is a validation method that is specific to each Web form that is posted, there is no central code to handle required fields or numeric-only fields. In this case, although there may be a field on multiple different forms that is considered a required field, each is handled separately and redundantly in numerous places in the application. This strategy is relatively easy to implement and is effective, but it leads to duplication of code as an application grows.  

以表单为中心的验证策略迫使应用程序包含大量方法，这些方法用于验证每个提交表单的各类状态。通常，这些方法在逻辑上存在重叠，导致复用性和模块化程度降低。由于每个提交的Web表单都有专属的验证方法，因此缺乏统一代码来处理必填字段或纯数字字段。这种情况下，即便多个不同表单中存在被视为必填的字段，每个字段仍需在应用程序的多个位置单独且冗余地处理。该策略实现相对简单且有效，但随着应用规模增长会导致代码重复。

To provide a more flexible, reusable, and maintainable solution, the model data may be considered at a different level of abstraction. This approach is considered in the following alternative strategy, “Validation Based on Abstract Types. An example of form-centric validation is shown in the listing in Example 3.4.  

为提供更灵活、可复用且可维护的解决方案，可在不同抽象层级考量模型数据。以下替代策略"基于抽象类型的验证"即采用此方法。示例3.4的代码清单展示了以表单为中心的验证范例。

# Example 3.4 Form-Centric Validation  

/\*\*If the first name or last name fields were left blank, then an error will be returned to client. With this strategy, these checks for the existence of a required field are duplicated. If this validation logic were abstracted into a separate component, it could be reused across forms (see Validation Based on Abstract Types strategy)\*\*/   
public Vector validate()   
{   
Vector errorCollection $=$ new Vector(); if ((firstname $==$ null) || (firstname.trim.length() $<1$ )) errorCollection.addElement("firstname required"); if ((lastname $==$ null) || (lastname.trim.length() $<~1~$ )) errorCollection.addElement("lastname required");   
return errorCollection;   
}  

/**若名字或姓氏字段留空，则向客户端返回错误。采用此策略时，这些必填字段存在性检查存在重复。若将验证逻辑抽象至独立组件，即可跨表单复用（参见基于抽象类型的验证策略）**/  
public Vector validate()  
{  
Vector errorCollection = new Vector(); if ((firstname == null) || (firstname.trim.length() < 1 )) errorCollection.addElement("firstname required"); if ((lastname == null) || (lastname.trim.length() < 1 )) errorCollection.addElement("lastname required");  
return errorCollection;  
}

# Validation Based on Abstract Types  

This strategy could be utilized on either the client or server, but is preferred on the server in a browser-based or thin-client environment.  

该策略可在客户端或服务器端实施，但在基于浏览器或瘦客户端环境中更推荐部署于服务器端。

The typing and constraints information is abstracted out of the model state and into a generic framework. This separates the validation of the model from the application logic in which the model is being used, thus reducing their coupling.  

类型与约束信息从模型状态中抽离，并封装至通用框架。这种设计将模型验证逻辑与使用该模型的应用逻辑解耦，从而降低二者的耦合度。

Model validation is performed by comparing the metadata and constraints to the model state. The metadata and constraints about the model are typically accessible from some sort of simple data store, such as a properties file. A benefit of this approach is that the system becomes more generic, because it factors the state typing and constraint information out of the application logic.  

模型验证通过将元数据和约束条件与模型状态进行比对来实现。关于模型的元数据和约束条件通常可从某种简单的数据存储（如属性文件）中获取。这种方法的优势在于系统变得更加通用，因为它将状态类型和约束信息从应用逻辑中解耦出来。

An example is to have a component or subsystem that encapsulates validation logic, such as deciding whether a string is empty, whether a certain number is within a valid range, whether a string is formatted in a particular way, and so on. When various disparate application components want to validate different aspects of a model, each component does not write its own validation code. Rather, the centralized validation mechanism is used. The centralized validation mechanism will typically be configured either programmatically, through some sort of factory, or declaratively, using configuration files.  

例如，可以设计一个组件或子系统来封装验证逻辑，包括判断字符串是否为空、数值是否在有效范围内、字符串是否符合特定格式等。当不同的应用组件需要验证模型的各个层面时，各组件无需自行编写验证代码，而是使用集中式验证机制。该机制通常通过编程方式（借助某种工厂类）或声明方式（使用配置文件）进行配置。

Thus, the validation mechanism is more generic, focusing on the model state and its requirements, independent of the other parts of the application. A drawback to using this strategy is the potential reduction in efficiency and performance. Also, more generic solutions, although often powerful, are sometimes less easily understood and maintained.  

因此，这种验证机制更为通用，专注于模型状态及其需求，与应用程序的其他部分无关。采用此策略的一个缺点是可能降低效率和性能。此外，更通用的解决方案虽然通常功能强大，但有时较难理解和维护。

An example scenario follows. An XML-based configuration file describes a variety of validations, such as “required field,” “all-numeric field,” and so on. Additionally, handler classes can be designated for each of these validations. Finally, a mapping links HTML form values to a specific type of validation. The code for validating a particular form field simply becomes something similar to the code snippet shown in Example 3.5.  

以下是一个示例场景。基于XML的配置文件描述了多种验证规则，例如“必填字段”、“全数字字段”等。此外，可以为每种验证指定对应的处理器类。最终，通过映射将HTML表单值与特定验证类型关联。验证特定表单字段的代码简化为类似示例3.5所示的代码片段。

# Example 3.5 Validation Based on Abstract Types  

//firstNameString $=$ "Dan"   
//formFieldName $=$ "form1.firstname"   
Validator.getInstance().validate(firstNameString, formFieldName);  

//firstNameString $=$ "Dan"   
//formFieldName $=$ "form1.firstname"   
Validator.getInstance().validate(firstNameString, formFieldName);

# Helper Properties—Integrity and Consistency  

JavaBean helper classes are typically used to hold intermediate state when it is passed in with a client request. JSP runtime engines provide a mechanism for automatically copying parameter values from a servlet request object into properties of these JavaBean helpers. The JSP syntax is as follows:  

JavaBean辅助类通常用于在客户端请求传入时保存中间状态。JSP运行时引擎提供了一种机制，可自动将Servlet请求对象中的参数值复制到这些JavaBean辅助类的属性中。其JSP语法如下：

<jsp:setProperty name $=$ "helper" property $=$ "\*"/>  

<jsp:setProperty name = "helper" property = "*"/>

This tells the JSP engine to copy all matching parameter values into the corresponding properties in a JavaBean called “helper,” shown in Example 3.6:  

这会通知JSP引擎将所有匹配的参数值复制到名为"helper"的JavaBean对应的属性中，如示例3.6所示：

# Example 3.6 Helper Properties - A Simple JavaBean Helper  

public class Helper private String first; private String last; public String getFirst() { return first; public void setFirst(String aString) first $=$ aString; public String getLast() { return last; public void setLast(String aString) { last $=$ aString;  

public class Helper private String first; private String last; public String getFirst() { return first; public void setFirst(String aString) first $=$ aString; public String getLast() { return last; public void setLast(String aString) { last $=$ aString;  

（注：根据用户指令，代码块保持原样不翻译）

How is a match determined, though? If a request parameter exists with the same name and same type as the helper bean property, then it is considered a match. Practically, then, each parameter is compared to each bean property name and the type of the bean property setter method.  

匹配是如何确定的呢？如果存在与辅助Bean属性同名且同类型的请求参数，则视为匹配。实际上，系统会将每个参数与Bean属性名及属性setter方法的类型逐一比对。

Although this mechanism is simple, it can produce some confusing and unwanted side effects. First of all, it is important to note what happens when a request parameter has an empty value. Many developers assume that a request parameter with an empty string value should, if matched to a bean property, cause that bean property to take on the value of an empty string, or null. The spec-compliant behavior is actually to make no changes to the matching bean property in this case, though. Furthermore, since JavaBean helper instances are typically reused across requests, such confusion can lead to data values being inconsistent and incorrect. Figure 3.1 shows the sort of problem that this might cause.  

虽然这种机制很简单，但可能会产生一些令人困惑且不希望的副作用。首先需特别注意：当请求参数值为空时会发生什么。许多开发者认为，若空字符串值的请求参数匹配到Bean属性，应使该属性赋值为空字符串或null。但规范兼容的实际行为是：这种情况下不会对匹配的Bean属性作任何修改。此外，由于JavaBean辅助实例通常会在多个请求间复用，此类混淆可能导致数据值不一致和错误。图3.1展示了可能引发的问题类型。

![](images/35503b0882b5a6efc9266414f55d3e2be6b81999c9d27b1d402d10ab4f90ea84.jpg)  
Figure 3.1. Helper properties  

图3.1 辅助属性

Request 1 includes values for the parameter named “first” and the one named “last,” and each of the corresponding bean properties is set. Request 2 includes a value only for the “last” parameter, causing only that one property to be set in the bean. The value for the “first” parameter is unchanged. It is not reset to an empty string, or null, simply because there is no value in the request parameter. As you can see in Figure 3.1, this may lead to inconsistencies if the bean values are not reset manually between requests.  

请求1包含名为"first"和"last"的参数值，对应的Bean属性均被设置。请求2仅包含"last"参数值，导致仅该属性在Bean中被设置。"first"参数的值保持不变——不会因为请求参数中缺少该值就被重置为空字符串或null。如图3.1所示，如果在请求之间未手动重置Bean值，这可能导致数据不一致问题。

Another related issue to consider when designing your application is the behavior of HTML form interfaces when controls of the form are not selected. For example, if a form has multiple checkboxes, it is not unreasonable to expect that unchecking every checkbox would result in clearing out these values on the server. In the case of the request object created based on this interface, however, there would simply not be a parameter included in this request object for any of the checkbox values. Thus, no parameter values relating to these checkboxes are sent to the server (see http://www.w3.org for full HTML specification).  

在设计应用程序时，另一个需要考虑的相关问题是HTML表单界面在控件未被选中时的行为。例如，若表单包含多个复选框，用户取消勾选所有复选框时，期望服务器端清除这些值是合理的。然而，基于该界面创建的请求对象中，根本不会包含任何复选框值的参数。因此，与这些复选框相关的参数值不会被发送至服务器（完整HTML规范参见http://www.w3.org）。

Since there is no parameter passed to the server, the matching bean property will remain unchanged when using the <jsp:setProperty> action, as described. So, in this case, unless the developer manually modifies these values, there is the potential for inconsistent and incorrect data values to exist in the application. As stated, a simple design solution to this problem is to reset all state in the JavaBean between requests.  

由于未向服务器传递任何参数，如所述，在使用`<jsp:setProperty>`动作时，匹配的Bean属性将保持不变。因此在这种情况下，除非开发者手动修改这些值，否则应用程序中可能存在不一致且错误的数据值。如前所述，针对此问题的简单设计解决方案是在请求之间重置JavaBean的所有状态。

# Presentation Tier Bad Practices  

Bad practices are less than optimal solutions that conflict with many of the patterns' recommendations. When we documented the patterns and best practices, we naturally discarded those practices that were less than optimal.  

不良实践是指那些与多数模式推荐方案相冲突的非最优解决方案。在记录模式和最佳实践时，我们自然摒弃了这些不够理想的实践方式。

In this part of the book, we highlight what we consider to be bad practices in the presentation tier.  

本书这一部分重点探讨了我们在表示层中认为的不良实践。

In each section, we briefly describe the bad practice and provide numerous references to design issues, refactorings, and patterns that provide further information and preferable alternatives. We do not provide an in-depth discussion of each bad practice, but rather present a brief synopsis as a starting point for further investigation.  

在每个章节中，我们会简要描述不良实践，并提供大量涉及设计问题、重构方案和模式的相关参考，这些内容能提供更深入的信息和更优的替代方案。我们不会对每个不良实践进行深入探讨，而是提供简要概述作为进一步研究的起点。

The “Problem Summary” section provides a quick description of a less than optimal situation, while the “Solution Reference” section includes references to:  

“问题概述”部分简要描述了当前存在的非理想状况，而“解决方案参考”部分则包含以下内容的引用：

· Patterns that provide information on context and trade-offs; Design considerations that provide related details; Refactorings that describe the journey from the less than optimal situation (bad practice) to a more optimal one, a best practice, or pattern.  

· 提供上下文和权衡信息的模式；包含相关细节的设计考量；描述从次优方案（不良实践）演进至更优方案（最佳实践或模式）的重构过程。

Consider this part of the book as a roadmap, using the references to locate further detail and description in other parts of the book.  

本书这部分内容可作为路线图，通过相关引用定位到书中其他部分的详细描述。

# Control Code in Multiple Views  

# Problem Summary  

Custom tag helpers may be included at the top of a JSP View to perform access control and other types of checks. If a large number of views include similar helper references, maintaining this code becomes difficult, since changes must be made in multiple places.  

自定义标签助手可置于JSP视图顶部，用于执行访问控制及其他类型检查。若大量视图包含相似的助手引用，代码维护将变得困难，因为修改需在多个位置同步进行。

# Solution Reference  

Consolidate control code, introducing a controller and associated Command helpers.  

整合控制代码，引入控制器及关联的Command辅助类。

<html><body><table><tr><td>Refactoring</td><td>See Introduce a Controller"</td></tr><tr><td>Refactoring</td><td>See Localize DisparateLogic"</td></tr><tr><td>Pattern</td><td>See Front Controller Command and Controller Strategy" 一</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见"引入控制器"</td></tr><tr><td>重构</td><td>参见"本地化分散逻辑"</td></tr><tr><td>模式</td><td>参见"前端控制器命令与控制器策略"</td></tr></table></body></html>

When there is a need to include similar control code in multiple places, such as when only a portion of a JSP View is to be restricted from a particular user, delegate the work to a reusable helper class.  

当需要在多处包含类似的控制逻辑时（例如仅需限制特定用户访问JSP视图的某部分），应将此类工作委托给可复用的辅助类处理。

<html><body><table><tr><td>Pattern</td><td>See "ViewHelper"</td></tr><tr><td>Design</td><td>See GuardingaView"</td></tr></table></body></html>  

<html><body><table><tr><td>模式</td><td>参见"ViewHelper"</td></tr><tr><td>设计</td><td>参见"GuardingaView"</td></tr></table></body></html>

# Exposing Presentation-Tier Data Structures to Business Tier  

# Problem Summary  

Presentation-tier data structures, such as HttpServletRequest, should be confined to the presentation tier. Sharing these details with the business tier, or any other tier, increases coupling between these tiers, dramatically reducing the reusability of the available services. If the method signature in the business service accepts a parameter of type HttpServletRequest, then any other clients to this service (even those outside of the Web space) must wrap their request state in an HttpServletRequest object. Additionally, in this case the business-tier services need to understand how to interact with these presentation tier-specific data structures, increasing the complexity of the business-tier code and increasing the coupling between the tiers.  

表示层的数据结构（如 `HttpServletRequest`）应严格限定在表示层使用。将这些细节暴露给业务层或其他层级会加剧各层之间的耦合，显著降低现有服务的可重用性。若业务服务的方法签名接受 `HttpServletRequest` 类型的参数，则意味着该服务的所有客户端（包括非 Web 环境下的调用方）都必须将请求状态封装为 `HttpServletRequest` 对象。更严重的是，业务层服务此时必须理解如何处理这些表示层特有的数据结构，这不仅增加了业务层代码的复杂度，还进一步强化了层级间的耦合关系。

# Solution Reference  

Instead of sharing data structures specific to the presentation tier with the business tier, copy the relevant state into more generic data structures and share those. Alternatively, extract and share the relevant state from the presentation tier-specific data structure as individual parameters.  

避免将与表示层相关的数据结构直接共享给业务层，而应将相关状态复制到更通用的数据结构中进行共享。另一种方案是从表示层专属数据结构中提取相关状态，以独立参数的形式进行共享。

Refactoring •See “Hide Presentation Tier-Specific Details From the BusinessTier”.  

重构 • 参见“向业务层隐藏表示层特定细节”。

# Exposing Presentation-Tier Data Structures to Domain Objects  

# Problem Summary  

Sharing request handling data structures, such as HttpServletRequest, with domain objects needlessly increases the coupling between these two distinct aspects of the application. Domain objects should be reusable components, and if their implementation relies on protocol or tier-specific details, their potential for reuse is reduced. Furthermore, maintaining and debugging tightly coupled applications is more difficult.  

将诸如 `HttpServletRequest` 这类请求处理数据结构与领域对象共享，会不必要地增加应用程序这两个不同层面之间的耦合度。领域对象应是可复用的组件，若其实现依赖于特定协议或分层细节，其复用潜力将大打折扣。此外，紧密耦合的应用程序在维护和调试时也会更加困难。

# Solution Reference  

Instead of passing an HttpServletRequest object as a parameter, copy the state from the request object into a more generic data structure and share this object with the domain object. Alternatively, extract the relevant state from the HttpServletRequest object and provide each piece of state as an individual parameter to the domain object.  

不再将 `HttpServletRequest` 对象作为参数传递，而是将请求对象的状态复制到更通用的数据结构中，并与领域对象共享该对象。或者，从 `HttpServletRequest` 对象中提取相关状态，并将每个状态片段作为独立参数提供给领域对象。

Refactoring • See “Hide Presentation Tier-Specific Details From the Business Tier”.  

重构 • 参见“向业务层隐藏表现层特定细节”。

# Allowing Duplicate Form Submissions  

# Problem Summary  

One of the limitations of the browser-client environment is the lack of control an application has over client navigation. A user might submit an order form that results in a transaction that debits a credit card account and initiates shipment of a  

浏览器-客户端环境的局限性之一在于应用程序对用户导航行为缺乏控制。用户可能在提交订单表单后触发一项事务，该事务会从信用卡账户扣款并启动货物配送流程。

product to a residence. If after receiving the confirmation page, the user clicks the Back button, then the same form could be resubmitted.  

产品配送至住宅地址。若用户在收到确认页面后点击返回按钮，则可能导致同一表单被重复提交。

# Solution Reference  

To address these issues, monitor and control the request flow.  

为解决这些问题，需监控并控制请求流量。

<html><body><table><tr><td>Refactoring</td><td>See IntroduceSynchronizer Token"</td></tr><tr><td>Refactoring</td><td>See Controlling Client Access</td></tr><tr><td>Design</td><td>See Synchronizer (orDeia avu) Token"</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见"引入同步令牌"</td></tr><tr><td>重构</td><td>参见"控制客户端访问"</td></tr><tr><td>设计</td><td>参见"同步令牌模式"</td></tr></table></body></html>

# Exposing Sensitive Resources to Direct Client Access  

# Problem Summary  

Security is one of the most important issues in enterprise environments. If there is no need for a client to have direct access to certain information, then this information must be protected. If specific configuration files, property files, JSPs, and class files are not secured appropriately, then clients may inadvertently or maliciously retrieve sensitive information.  

安全是企业环境中最为关键的议题之一。若客户端无需直接访问特定信息，则必须对这些信息实施保护。倘若未能妥善保护配置文件、属性文件、JSP及类文件，客户端可能无意或恶意地获取敏感数据。

# Solution Reference  

Protect sensitive resources, disallowing direct client access  

保护敏感资源，禁止客户端直接访问

<html><body><table><tr><td>Refactoring</td><td>See"Hide Resource From a Client"</td></tr><tr><td>Refactoring</td><td>See"ControllingClientAccess</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见"对客户端隐藏资源"</td></tr><tr><td>重构</td><td>参见"控制客户端访问"</td></tr></table></body></html>

# Assuming <jsp:setProperty> Will Reset Bean Properties  

# Problem Summary  

While the expected behavior of the <jsp:setProperty> standard tag is to copy request parameter values into JavaBean helper properties of the same name, its behavior when dealing with parameters that have empty values is often confusing. For example, a parameter with an empty value is ignored, although many  

标准标签`<jsp:setProperty>`的预期行为是将请求参数值复制到同名JavaBean辅助属性中，但在处理空值参数时其行为往往令人困惑。例如，具有空值的参数会被忽略，尽管许多

developers incorrectly assume that the matching JavaBean property will be assigned a null or empty string value.  

开发者错误地认为匹配的JavaBean属性会被赋予null或空字符串值。

# Solution Reference  

Take into account the less than intuitive nature of how properties are set when using the <jsp:setProperty $\mathrm{\textperthousand}$ tag, and initialize bean properties before use.  

考虑到使用 `<jsp:setProperty>` 标签设置属性时不够直观的特性，请在使用前初始化 Bean 的属性。

Design • See “Helper Properties—Integrity and Consistency”.  

设计 • 参见“辅助属性——完整性与一致性”。

# Creating Fat Controllers  

# Problem Summary  

Control code that is duplicated in multiple JSP views should, in many cases, be refactored into a controller. If too much code is added to a controller, though, it becomes too heavyweight and cumbersome to maintain, test, and debug. For example, unit testing a servlet controller, particularly a “fat controller,” is more complicated than unit testing individual helper classes that are independent of the HTTP protocol.  

在多个JSP视图中重复的控制代码，通常应重构至控制器层。然而若控制器承载过多代码，则会变得臃肿笨重，难以维护、测试和调试。例如，对Servlet控制器（尤其是"臃肿控制器"）进行单元测试，其复杂度远高于测试那些独立于HTTP协议的辅助类。

# Solution Reference  

A controller is typically the initial contact point for handling a request, but it should also be a delegation point, working in coordination with other control classes. Command objects are used to encapsulate control code to which the controller delegates. It is much easier to unit test these JavaBean command objects, independent of the servlet engine, than it is to test less modular code.  

控制器通常是处理请求的初始接触点，但它也应作为委托协调点，与其他控制类协同工作。命令对象用于封装控制器委托的控制逻辑。相较于测试模块化程度较低的代码，这些独立于Servlet引擎的JavaBean命令对象更易于进行单元测试。

<html><body><table><tr><td>Refactoring</td><td>See IntroduceaController"</td></tr><tr><td>Pattern</td><td>See "Front Controller-"Command and Controller Strategy"</td></tr><tr><td>Refactoring</td><td>See Localize ：DisparateLogic"</td></tr><tr><td>Pattern</td><td>See 'ViewHelper"</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见IntroduceaController</td></tr><tr><td>模式</td><td>参见"Front Controller-Command and Controller Strategy"</td></tr><tr><td>重构</td><td>参见Localize DisparateLogic</td></tr><tr><td>模式</td><td>参见ViewHelper</td></tr></table></body></html>

# Chapter 4. BUSINESS TIER DESIGN CONSIDERATIONS AND BAD PRACTICES  

# Topics in This Chapter  

Business Tier Design Considerations Business and Integration Tiers Bad Practices  

业务层设计考量 业务与集成层不良实践

# Business Tier Design Considerations  

When developers apply the business tier and integration tier patterns that appear in the catalog in this book, there may be adjunct design issues about which they may be concerned. These issues relate to designing with patterns at a variety of levels, and they may affect numerous aspects of a system. We discuss these issues in this chapter.  

当开发人员应用本书目录中出现的业务层和集成层模式时，可能会涉及一些他们关心的辅助设计问题。这些问题与多层次模式设计相关，并可能影响系统的诸多方面。本章将讨论这些议题。

The discussions in this chapter simply describe each issue as a design issue that you should consider when implementing systems based on the J2EE pattern catalog.  

本章的讨论仅将每个问题描述为设计考量点，在基于J2EE模式目录实现系统时应当予以关注。

# Using Session Beans  

Session beans are distributed business components with the following characteristics, per the EJB specification:  

会话Bean是符合EJB规范的分布式业务组件，具有以下特性：

• A session bean is dedicated to a single client or user.   
• A session bean lives only for the duration of the client's session.   
• A session bean does not survive container crashes.   
• A session bean is not a persistent object.   
• A session bean can time out.   
• A session bean can be transaction-aware. A session bean can be used to model stateful or stateless conversations between the client and the business tier components.  

• 会话Bean专用于单个客户端或用户。  
• 会话Bean仅在客户端会话期间存在。  
• 会话Bean无法在容器崩溃后继续存活。  
• 会话Bean不是持久化对象。  
• 会话Bean会超时失效。  
• 会话Bean可支持事务。会话Bean可用于建模客户端与业务层组件之间的有状态或无状态会话交互。

# Note  

In this section, we use the term "workflow" in the context of EJB to represent the logic associated with the enterprise beans communication. For example, workflow encompasses how session bean A calls session bean B, then entity bean C.  

本节中，我们使用EJB语境下的"workflow"术语来表示与企业级Bean通信相关的逻辑。例如，workflow包含会话Bean A如何调用会话Bean B，继而访问实体Bean C的过程。

# Session Bean—Stateless Versus Stateful  

Session beans come in two flavors—stateless and stateful. A stateless session bean does not hold any conversational state. Hence, once a client's method invocation on a stateless session beans is completed, the container is free to reuse that session bean instance for another client. This allows the container to maintain a pool of session beans and to reuse session beans among multiple clients. The container pools stateless session beans so that it can reuse them more efficiently by sharing them with multiple clients. The container returns a stateless session bean to the  

会话Bean分为两种类型——无状态和有状态。无状态会话Bean不保留任何会话状态。因此，一旦客户端对无状态会话Bean的方法调用完成，容器就可以将该会话Bean实例重用于其他客户端。这使得容器能够维护一个会话Bean池，并在多个客户端之间复用会话Bean。容器通过池化无状态会话Bean，可以更高效地将其共享给多个客户端复用。容器会将无状态会话Bean返回到

pool after the client completes its invocation. The container may allocate a different instance from the pool to subsequent client invocations.  

客户端完成调用后，实例将返回池中。容器可能为后续客户端调用从池中分配不同的实例。

A stateful session bean holds conversational state. A stateful session bean may be pooled, but since the session bean is holding state on behalf of a client, the bean cannot simultaneously be shared with and handle requests from another client.  

有状态会话Bean（stateful session bean）维护会话状态。虽然可对有状态会话Bean进行池化，但由于该Bean代表客户端持有状态，因此无法同时与其他客户端共享或处理其他客户端的请求。

The container does not pool stateful session beans in the same manner as it pools stateless session beans because stateful session beans hold client session state. Stateful session beans are allocated to a client and remain allocated to the client as long as the client session is active. Thus, stateful session beans need more resource overhead than stateless session beans, for the added advantage of maintaining conversational state.  

容器不会以管理无状态会话Bean的方式池化有状态会话Bean，因为有状态会话Bean持有客户端会话状态。有状态会话Bean会被分配给特定客户端，并在该客户端会话活跃期间持续保持分配状态。因此，相较于无状态会话Bean，有状态会话Bean需要更多的资源开销，以换取维护会话状态的附加优势。

Many designers believe that using stateless session beans is a more viable session bean design strategy for scalable systems. This belief stems from building distributed object systems with older technologies, because without an inherent infrastructure to manage component life cycle, such systems rapidly lost scalability characteristics as resource demands increased. Scalability loss was due to the lack of component life cycle, causing the service to continue to consume resources as the number of clients and objects increased.  

许多设计者认为，采用无状态会话Bean是实现可扩展系统更可行的会话Bean设计策略。这一观点源于使用传统技术构建分布式对象系统的经验——由于缺乏管理组件生命周期的固有基础设施，这类系统会随着资源需求增长迅速丧失可扩展性。其根本原因在于组件生命周期的缺失，导致服务在客户端和对象数量增加时持续消耗资源。

An EJB container manages the life cycle of enterprise beans and is responsible for monitoring system resources to best manage enterprise bean instances. The container manages a pool of enterprise beans and brings enterprise beans in and out of memory (called activation and passivation, respectively) to optimize invocation and resource consumption.  

EJB容器负责管理企业级Bean的生命周期，并监控系统资源以最优方式管理Bean实例。该容器维护一个企业级Bean池，通过将Bean调入调出内存（分别称为激活和钝化）来优化调用性能和资源消耗。

Scalability problems are typically due to the misapplication of stateful and stateless session beans. The choice of using stateful or stateless session beans must depend upon the business process being implemented. A business process that needs only one method call to complete the service is a non-conversational business process. Such processes are suitably implemented using a stateless session bean. A business process that needs multiple method calls to complete the service is a conversational business process. It is suitably implemented using a stateful session bean.  

可扩展性问题通常源于对有状态和无状态会话Bean的错误应用。选择使用有状态还是无状态会话Bean必须取决于所实现的业务流程。仅需单次方法调用即可完成服务的业务流程属于非会话式业务流程，这类流程适合采用无状态会话Bean实现。而需要多次方法调用才能完成服务的业务流程则属于会话式业务流程，这类流程适合采用有状态会话Bean实现。

However, some designers choose stateless session beans, hoping to increase scalability, and they may wrongly decide to model all business processes as stateless session beans. When using stateless session beans for conversational business processes, every method invocation requires the state to be passed by the client to the bean, reconstructed at the business tier, or retrieved from a persistent store. These techniques could result in reduced scalability due to the associated overheads in network traffic, reconstruction time, or access time respectively.  

然而，部分设计者为了追求可扩展性而选择无状态会话Bean，却可能错误地将所有业务流程都建模为无状态会话Bean。当采用无状态会话Bean处理会话式业务流程时，每次方法调用都需要客户端将状态传递给Bean，或在业务层重构状态，亦或是从持久化存储中检索状态。这些技术会分别因网络流量开销、重构时间或访问时间的增加，最终导致可扩展性降低。

# Session Beans as Business-Tier Facades  

In our patterns in the J2EE Pattern Catalog and best practices, one application of session beans is to use them as facades to the business tier. Session bean facades, or simply session facades, can be viewed as a coarse-grained controller layer for the business tier. Clients of the session beans are typically Business Delegates.  

在J2EE模式目录和最佳实践中，会话Bean的一种应用是将其作为业务层的门面。会话Bean门面（或简称会话门面）可视为业务层的粗粒度控制层。会话Bean的客户端通常是业务委托对象。

See “Session Facade”.   
See “Business Delegate”.   
See also “Mapping Each Use Case to a Session Bean”.  

参见“会话门面模式”。  
参见“业务委托模式”。  
另请参阅“将每个用例映射至会话Bean”。

# Storing State on the Business Tier  

Some design considerations for storing state on the Web server are discussed in “Session State in the Presentation Tier”.  

关于在Web服务器上存储状态的部分设计考量已在《表示层中的会话状态》章节中讨论。

Here we continue that discussion to explore when it is appropriate to store state in a stateful session bean instead of in an HttpSession. One of the considerations is to determine what types of clients access the business services in your system. If the architecture is solely a Web-based application, where all the clients come through a Web server either via a servlet or a JSP, then conversational state may be maintained in an HttpSession in the Web tier. This scenario is shown in Figure 4.1.  

我们继续探讨何时适合将有状态会话Bean中的状态存储在HttpSession中。其中一个考量因素是确定系统中哪些类型的客户端会访问业务服务。如果架构仅为基于Web的应用程序，所有客户端均通过Servlet或JSP从Web服务器接入，那么会话状态可维持在Web层的HttpSession中。该场景如图4.1所示。

![](images/4223c8d8dce42c0d723ddf238b376c3ddd6ae96e5dea1e513408d8da381d9720.jpg)  
Figure 4.1. Storing state in HttpSession  

图4.1 在HttpSession中存储状态

On the other hand, if your application supports various types of clients, including Web clients, Java applications, other applications, and even other enterprise beans, then conversational state may be maintained in the EJB layer using stateful session beans. This is shown in Figure 4.2.  

另一方面，若应用程序需支持多种客户端类型（包括Web客户端、Java应用、其他应用程序乃至其他企业级Bean），则可通过有状态会话Bean在EJB层维护会话状态，如图4.2所示。

![](images/1c4371a7b7000a71f031bdd69912886059b0ce45e5c53c8082dd33d11dce3471.jpg)  
Figure 4.2. Storing state in session beans  

图4.2 在会话Bean中存储状态

We have presented some basic discussion on the subject of state management here and in the previous chapter (see “Session State on Client”). A full-scale discussion is outside the scope of this book, since the problem is multi-dimensional and depends very much on the deployment environment, including:  

我们在本章及前一章节（参见“客户端会话状态”）中已对状态管理主题进行了基础性探讨。由于该问题具有多维性且高度依赖部署环境（包括：），全面讨论已超出本书范畴。

Hardware • Traffic management Clustering of Web container • Clustering of EJB container Server affinity • Session replication • Session persistence  

硬件  
• 流量管理  
Web容器集群化  
• EJB容器集群化  
服务器亲和性  
• 会话复制  
• 会话持久化

We touch on this issue because it is one that should be considered during development and deployment.  

我们提及此问题，是因为在开发和部署过程中应当予以考虑。

# Using Entity Beans  

Using entity beans appropriately is a question of design heuristics, experience, need, and technology. Entity beans are best suited as coarse-grained business components. Entity beans are distributed objects and have the following characteristics, per the EJB specification:  

合理使用实体Bean取决于设计启发、经验需求和技术考量。实体Bean最适合作为粗粒度的业务组件。根据EJB规范，实体Bean作为分布式对象具备以下特性：

• Entity beans provide an object view of persistent data.   
• Entity beans are transactional.   
• Entity beans are multiuser.   
• Entity beans are long-lived. Entity beans survive container crashes. Such crashes are typically transparent to the clients.  

• Entity Bean 为持久化数据提供对象视图  
• Entity Bean 具有事务性  
• Entity Bean 支持多用户并发访问  
• Entity Bean 是长生存期对象。即使容器崩溃，Entity Bean 仍能保持存活状态，这类故障对客户端通常是透明的

Summarizing this definition, the appropriate use of an entity bean is as a distributed, shared, transactional, and persistent object. In addition, EJB containers provide other infrastructure necessary to support such system qualities as scalability, security, performance, clustering, and so forth. All together, this makes for a very reliable and robust platform to implement and deploy applications with distributed business components.  

总结这一定义，实体Bean的适用场景是作为分布式、共享式、事务性和持久化的对象。此外，EJB容器还提供了支持可扩展性、安全性、性能、集群等系统特性所需的其他基础设施。这些特性共同构成了一个非常可靠且健壮的平台，用于实现和部署具有分布式业务组件的应用程序。

# Entity Bean Primary Keys  

Entity beans are uniquely identified by their primary keys. A primary key can be a simple key, made up of a single attribute, or it can be a composite key, made up of a group of attributes from the entity bean. For entity beans with a single-field primary key, where the primary key is a primitive type, it is possible to implement the entity bean without defining an explicit primary key class. The deployer can specify the primary key field in the deployment descriptor for the entity bean. However, when the primary key is a composite key, a separate class for the primary key must be specified. This class must be a simple Java class that implements the serializable interface with the attributes that define the composite key for the entity bean. The attribute names and types in the primary key class must match those in the entity bean, and also must be declared public in both the bean implementation class and primary key class.  

实体Bean通过其主键进行唯一标识。主键可以是简单键（由单个属性构成），也可以是复合键（由实体Bean的一组属性构成）。对于单字段主键的实体Bean（主键为基本类型），可以不定义显式的主键类，部署者只需在实体Bean的部署描述符中指定主键字段即可。然而，当主键为复合键时，必须指定一个独立的主键类。该类需实现`Serializable`接口，并以定义实体Bean复合键的属性作为其成员。主键类中的属性名称和类型必须与实体Bean中的对应属性完全匹配，且在Bean实现类和主键类中均需声明为`public`。

As a suggested best practice, the primary key class must implement the optional java.lang.Object methods, such as equals and hashCode.  

作为推荐的最佳实践，主键类必须实现可选的 `java.lang.Object` 方法，例如 `equals` 和 `hashCode`。

Override the equals() method to properly evaluate the equality of two primary keys by comparing values for each part of the composite key. Override the Object.hashCode() method to return a unique number representing the hash code for the primary key instance. Ensure that the hash code is indeed unique when you use your primary key attribute values to compute the hash code.  

重写 `equals()` 方法，通过比较复合键的每个部分值来正确评估两个主键的相等性。重写 `Object.hashCode()` 方法以返回表示主键实例哈希码的唯一数值。在使用主键属性值计算哈希码时，必须确保该哈希码确实唯一。

# Business Logic in Entity Beans  

A common question in entity bean design is what kind of business logic it should contain. Some designers feel that entity beans should contain only persistence logic and simple methods to get and set data values. They feel that entity beans should not contain business logic, which is often misunderstood to mean that only code related to getting and setting data must be included in the entity bean.  

在实体Bean设计中，一个常见问题是它应当包含何种业务逻辑。部分设计者认为实体Bean应仅包含持久化逻辑及简单的数据存取方法，主张实体Bean不应承载业务逻辑——这种观点常被误解为实体Bean只能包含与数据读写相关的代码。

Business logic generally includes any logic associated with providing some service. For this discussion, consider business logic to include all logic related to processing, workflow, business rules, data, and so forth. The following is a list of sample questions to explore the possible results of adding business logic into an entity:  

业务逻辑通常包含与提供服务相关的所有逻辑。在本文讨论中，业务逻辑涵盖处理流程、工作流、业务规则、数据操作等相关逻辑。以下是探讨将业务逻辑添加至实体时可能产生结果的示例问题列表：

Will the business logic introduce entity-entity relationships? • Will the entity bean become responsible for managing workflow of user interaction? Will the entity bean take on the responsibilities that should belong in some other business component? Will the entity bean include code related to data access logic, such as Java Database Connectivity (JDBC) code when implemented using bean-managed persistence?  

业务逻辑是否会引入实体间关系？  
• 实体Bean是否会负责管理用户交互的工作流？  
• 实体Bean是否会承担本应属于其他业务组件的职责？  
• 当采用Bean管理持久化实现时，实体Bean是否会包含与数据访问逻辑相关的代码（例如Java Database Connectivity (JDBC)代码）？

A “yes” answer to any of these questions helps identify whether introducing business logic into the entity bean can have an adverse impact. It is desirable to investigate the design to avoid inter-entity-bean dependencies as much as possible, since such dependences create overheads that may impede overall application performance.  

若对任一问题回答"是"，则表明将业务逻辑引入实体Bean可能产生负面影响。建议审查设计以尽可能避免实体Bean间的依赖关系，此类依赖会产生可能阻碍整体应用性能的开销。

In general, the entity bean should contain business logic that is self-contained to manage its data and its dependent objects' data. Thus, it may be necessary to identify, extract, and move business logic that introduces   
entity-bean-to-entity-bean interaction from the entity bean into a session bean by applying the Session Facade pattern. The Composite Entity pattern and some of the refactorings discuss the issues related to entity bean design.  

通常，实体Bean应包含自包含的业务逻辑，以管理其数据及其依赖对象的数据。因此，可能需要通过应用**会话门面模式**（Session Facade Pattern），将那些引发实体Bean间交互的业务逻辑识别、提取并迁移至会话Bean中。**组合实体模式**（Composite Entity Pattern）及部分重构方案会探讨与实体Bean设计相关的议题。

If any workflow associated with multiple entity beans is identified, then such workflow can be suitably implemented in a session bean instead of in an entity bean. Such workflow can be consolidated into a session facade.  

若识别出与多个实体Bean关联的工作流，则此类工作流应适宜地实现在会话Bean而非实体Bean中。此类工作流可整合至会话门面模式中。

See “Merge Session Beans”. See “Eliminate Inter-Entity Bean Communication”.   
• See “Move Business Logic to Session”.   
• See “Session Facade”. See “Composite Entity”.  

参见“合并会话Bean”。参见“消除实体Bean间通信”。  
• 参见“将业务逻辑移至会话层”。  
• 参见“会话门面”。参见“组合实体”。

For bean-managed persistence in entity beans, data access code is best implemented outside entity beans.  

对于实体Bean中由Bean管理持久化的场景，数据访问代码的最佳实践是在实体Bean外部实现。

See “Separate Data Access Code”.   
See “Data Access Object”.  

参见“分离数据访问代码”。  
参见“数据访问对象”。

# Caching Enterprise Bean Remote References and Handles  

When clients use an enterprise bean, they may need to cache some reference to an enterprise bean for future use. You will encounter this when using business delegates (see “Business Delegate”), where a delegate connects to a session bean and invokes the necessary business methods on the bean on behalf of the client. When the client uses the business delegate for the first time, the delegate needs to perform a lookup using the EJB Home object to obtain a remote reference to the session bean. For subsequent requests, the business delegate can avoid lookups by caching a remote reference or its handle as necessary. The EJB Home handle can also be cached to avoid an additional Java Naming and Directory Interface (JNDI) lookup for the enterprise bean home. For more details on using an EJB Handle or the EJB Home Handle, please refer to the current EJB specification.  

当客户端使用企业级Bean时，可能需要缓存对企业级Bean的某些引用以供后续使用。在使用业务委托模式（参见“业务委托”）时会出现这种情况——业务委托会连接会话Bean并代表客户端调用该Bean上必要的业务方法。客户端首次使用业务委托时，委托需要通过EJB Home对象执行查找操作以获取会话Bean的远程引用。对于后续请求，业务委托可根据需要缓存远程引用或其句柄来避免重复查找。同时也可缓存EJB Home句柄，从而避免为企业级Bean主接口执行额外的JNDI（Java命名和目录接口）查找。关于EJB句柄与EJB Home句柄的使用细节，请参阅当前EJB规范。

# Business and Integration Tiers Bad Practices  

# Mapping Object Model Directly to Entity Bean Model  

# Problem Summary  

One of the common practices in designing an EJB application is to map the object model directly into entity beans; that is, each class in the object model is transformed into an entity bean. This results in a large number of fine-grained entity beans.  

设计EJB应用程序的常见实践之一是将对象模型直接映射到实体Bean，即对象模型中的每个类都转换为一个实体Bean。这会导致大量细粒度的实体Bean。

The container and network overhead increases as the number of enterprise beans increases. Such mapping also transforms object relationships into entity-bean-to-entity-bean relationships. This is best avoided, since entity-bean-to-entity-bean relationships introduce severe performance implications.  

随着企业级Bean数量的增加，容器和网络开销也会相应增长。此类映射还会将对象关系转化为实体Bean间的关联关系。这种设计应当尽量避免，因为实体Bean间的关联会引发严重的性能问题。

# Solution Reference  

Identify the parent-dependent object relationships in the object model and design them as coarse-grained entity beans. This results in fewer entity beans, where each entity bean composes a group of related objects from the object model.  

识别对象模型中的父子依赖关系，并将其设计为粗粒度实体Bean。这样可以减少实体Bean的数量，每个实体Bean将由对象模型中一组相关对象组合而成。

<html><body><table><tr><td>Refactoring</td><td>See"EliminateInter-EntityBean nCommunication"</td></tr><tr><td>Pattern</td><td>See"CompositeEntity"</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见"消除实体Bean间通信"</td></tr><tr><td>模式</td><td>参见"组合实体"</td></tr></table></body></html>

Consolidate related workflow operations into session beans to provide a uniform coarse-grained service access layer.  

将相关的工作流操作整合到会话Bean中，以提供统一的粗粒度服务访问层。

<html><body><table><tr><td>Refactoring</td><td>See"MergeSessionBeans</td></tr><tr><td>Pattern</td><td>See"SessionFacade"</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见"MergeSessionBeans</td></tr><tr><td>模式</td><td>参见"SessionFacade"</td></tr></table></body></html>

# Mapping Relational Model Directly to Entity Bean Model  

# Problem Summary  

When designing an EJB model, it is bad practice to model each row in a table as an entity bean. While entity beans are best designed as coarse-grained objects, this mapping results in a large number of fine-grained entity beans, and it affects scalability.  

在设计EJB模型时，将表中每一行建模为实体Bean是一种不良实践。虽然实体Bean最适合设计为粗粒度对象，但这种映射会导致大量细粒度实体Bean的产生，从而影响系统的可扩展性。

Such mapping also implements inter-table (i.e., primary key/foreign key) relationships as entity-bean-to-entity-bean relationships.  

此类映射还将表间（即主键/外键）关系实现为实体Bean间的关联关系。

# Solution Reference  

Design your enterprise bean application using an object-oriented approach instead of relying on the preexisting relational database design to produce the EJB model.  

采用面向对象的设计方法构建企业级Bean应用，而非依赖现有关系型数据库设计来生成EJB模型。

<html><body><table><tr><td>Bad</td><td></td></tr><tr><td>Practice</td><td>BeanModel"</td></tr></table></body></html>  

<html><body><table><tr><td>不良</td><td></td></tr><tr><td>实践</td><td>BeanModel"</td></tr></table></body></html>

Avoid inter-entity relationships by designing coarse-grained business objects by identifying parent-dependent objects.  

通过识别父级依赖对象来设计粗粒度业务对象，避免实体间关系。

<html><body><table><tr><td>Refactoring</td><td>See EliminateInter-Entity Bean Communication</td></tr><tr><td>Refactoring</td><td>See Move Business LogictoSession</td></tr><tr><td>Pattern</td><td>See CompositeE Entity"</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见EliminateInter-Entity Bean Communication</td></tr><tr><td>重构</td><td>参见Move Business LogictoSession</td></tr><tr><td>模式</td><td>参见CompositeE Entity"</td></tr></table></body></html>

# Mapping Each Use Case to a Session Bean  

# Problem Summary  

Some designers implement each use case with its own unique session bean. This creates fine-grained controllers responsible for servicing only one type of interaction. The drawback of this approach is that it may result in a large number of session beans and significantly increase the complexity of the application.  

部分设计者会为每个用例单独实现一个专属的会话Bean。这种做法会形成细粒度的控制器，每个控制器仅负责处理单一类型的交互。该方法的缺点在于可能导致会话Bean数量激增，从而显著提升应用程序的复杂度。

# Solution Reference  

Apply the Session Facade pattern to aggregate a group of the related interactions into a single session bean. This results in fewer session beans for the application, and leverages the advantages of applying the Session Facade pattern.  

采用会话门面模式将一组相关交互聚合到单个会话Bean中。这可以减少应用程序中的会话Bean数量，并充分发挥会话门面模式的应用优势。

<html><body><table><tr><td>Refactoring</td><td>See MergeSessionBeans</td></tr><tr><td>Pattern</td><td>See"SessionFacade"</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见MergeSessionBeans</td></tr><tr><td>模式</td><td>参见"SessionFacade"</td></tr></table></body></html>

# Exposing All Enterprise Bean Attributes via Getter/Setter Methods  

# Problem Summary  

Exposing each enterprise bean attribute using getter/setter methods is a bad practice. This forces the client to invoke numerous fine-grained remote invocations and creates the potential to introduce a significant amount of network chattiness across the tiers. Each method call is potentially remote and carries with it a certain network overhead that impacts performance and scalability.  

通过getter/setter方法暴露每个企业级Bean属性是一种不良实践。这会迫使客户端发起大量细粒度的远程调用，并可能导致跨层级间产生大量网络通信。每个方法调用都可能是远程操作，随之而来的网络开销会影响系统性能和可扩展性。

# Solution Reference  

Use a value object to transfer aggregate data to and from the client instead of exposing the getters and setters for each attribute.  

使用值对象在客户端与服务器间传输聚合数据，而非为每个属性暴露getter和setter方法。

<html><body><table><tr><td>Pattern</td><td>See"ValueObject"</td></tr><tr><td></td><td></td></tr></table></body></html>  

<html><body><table><tr><td>模式</td><td>参见"ValueObject"</td></tr><tr><td></td><td></td></tr></table></body></html>

# Embedding Service Lookup in Clients  

# Problem Summary  

Clients and presentation tier objects frequently need to look up the enterprise beans.   
In an EJB environment, the container uses JNDI to provide this service.  

客户端和表示层对象经常需要查找企业级Bean。  
在EJB环境中，容器通过JNDI提供这项服务。

Putting the burden of locating services on the application client can introduce a proliferation of lookup code in the application code. Any change to the lookup code propagates to all clients that look up the services. Also, embedding lookup code in  

将服务定位的负担强加于应用客户端会导致应用代码中充斥大量查找代码。任何对查找逻辑的修改都会波及所有依赖该服务的客户端。此外，将查找代码嵌入

clients exposes them to the complexity of the underlying implementation and introduces dependency on the lookup code.  

客户端会暴露底层实现的复杂性，并引入对查找代码的依赖。

# Solution Reference  

Encapsulate implementation details of the lookup mechanisms using a Service Locator.  

使用服务定位器封装查找机制的**实现**细节。

<html><body><table><tr><td>Pattern</td><td>See Service Locator"</td></tr></table></body></html>  

<html><body><table><tr><td>模式</td><td>参见服务定位器</td></tr></table></body></html>

Encapsulate the implementation details of business-tier components, such as session and entity beans, using Business Delegates. This simplifies client code since they no longer deal with enterprise beans and services. Business Delegates may in turn use the Service Locator.  

使用**业务委托(Business Delegate)**封装业务层组件的实现细节（如会话Bean和实体Bean）。该模式能简化客户端代码，使其无需直接处理企业级Bean和服务。业务委托可进一步结合**服务定位器(Service Locator)**实现功能调用。

<html><body><table><tr><td>Refactoring</td><td>See"IntroduceBusinessDelegate</td></tr><tr><td>Pattern</td><td>See"BusinessDelegate"</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见"引入业务委托模式</td></tr><tr><td>模式</td><td>参见"业务委托模式"</td></tr></table></body></html>

# Using Entity Bean as Read-Only Object  

# Problem Summary  

Any entity bean method is subject to transaction semantics based on its transaction isolation levels specified in the deployment descriptor. Using an entity bean as a read-only object simply wastes expensive resources and results in unnecessary update transactions to the persistent store. This is due to the invocation of the ejbStore() methods by the container during the entity bean's life cycle. Since the container has no way of knowing if the data was changed during a method invocation, it must assume that it has and invoke the ejbStore() operation. Thus, the container makes no distinction between read-only and read-write entity beans. However, some containers may provide read-only entity beans, but these are vendor proprietary implementations.  

任何实体Bean方法都需遵循部署描述符中指定的事务隔离级别所定义的事务语义。将实体Bean用作只读对象会浪费昂贵资源，并导致对持久化存储执行不必要的事务更新。这是由于容器在实体Bean生命周期中调用了`ejbStore()`方法。由于容器无法判断方法调用期间数据是否被修改，它必须假定数据已变更并执行`ejbStore()`操作。因此，容器对只读与读写实体Bean不做区分。但某些容器可能提供只读实体Bean，这些属于厂商专有实现。

# Solution Reference  

Encapsulate all access to the data source using Data Access Object pattern. This provides a centralized layer of data access code and also simplifies entity bean code.  

采用数据访问对象模式封装所有数据源访问操作。这既提供了集中化的数据访问代码层，又简化了实体Bean的代码实现。

<html><body><table><tr><td>attern</td><td>See"DataAccessObject"</td></tr></table></body></html>  

<html><body><table><tr><td>模式</td><td>参见"DataAccessObject"</td></tr></table></body></html>

Implement access to read-only functionality using a session bean, typically as a Session Facade that uses a DAO.  

通过会话Bean（通常作为使用DAO的会话门面）实现只读功能的访问。

Pattern • See “Session Facade”.  

模式 • 参见“会话门面”。

For obtaining a list of value objects, Value List Handler pattern may be implemented.  

要获取值对象列表，可实施**Value List Handler**模式。

Pattern • See “Value List Handler”.  

模式 • 参见“值列表处理器”。

For obtaining a complex data model from the business tier, the Value Object Assembler pattern may be implemented.  

为从业务层获取复杂数据模型，可采用**值对象组装器模式**实现。

Pattern • See “Value Object Assembler”.  

模式 • 参见“值对象装配器”。

# Using Entity Beans as Fine-Grained Objects  

# Problem Summary  

Entity beans are meant to represent coarse-grained transactional persistent business components. Using an entity bean to represent fine-grained objects increases the overall network communication and container overhead. This impacts application performance and scalability.  

实体Bean用于表示粗粒度的事务性持久化业务组件。若使用实体Bean表示细粒度对象，会增加整体网络通信和容器开销，从而影响应用性能和可扩展性。

A fine-grained object is best thought of as an object that has little meaning without its association to another object (typically a coarse-grained parent object). For example, an item object can be thought of as a fined-grained object because it has little value until it is associated with an order object. In this example, the order object is the coarse-grained object and the item object is the fine-grained (dependent) object.  

细粒度对象最好理解为一种脱离与其他对象（通常是粗粒度的父对象）关联就几乎没有意义的对象。例如，商品对象可视为细粒度对象，因为只有与订单对象关联时它才具有价值。在此例中，订单对象是粗粒度对象，而商品对象是细粒度（依赖型）对象。

# Solution Reference  

When designing enterprise beans based on a preexisting RDBMS schema,  

在基于既有RDBMS模式设计企业级Bean时，

Bad Practice • See “Mapping Relational Model Directly to Entity Bean Model”.  

不良实践 • 参见“将关系模型直接映射至Entity Bean模型”。

When designing enterprise beans using an object model,  

在设计企业级Bean时采用对象模型，

Bad Practice  • See “Mapping Object Model Directly to Entity Bean Model”.  

不良实践 • 参见“将对象模型直接映射至Entity Bean模型”

Design coarse-grained entity beans and session beans. Apply the following patterns and refactorings that promote coarse-grained enterprise beans design.  

设计粗粒度的实体Bean和会话Bean。应用以下模式和重构技术来促进粗粒度企业级Bean的设计。

<html><body><table><tr><td>Pattern</td><td>See "CompositeEntity"</td></tr><tr><td>Pattern</td><td>See "SessionFacade"</td></tr><tr><td>Refactoring</td><td>See "EliminateInter-Entity BeanCommunication'</td></tr><tr><td>Refactoring</td><td>See "MoveBusinessLogictoSession"</td></tr><tr><td>Refactoring</td><td>See "BusinessLogicinEntityBeans</td></tr><tr><td>Refactoring</td><td>See"MergeSessionBeans</td></tr></table></body></html>  

<html><body><table><tr><td>模式</td><td>参见"CompositeEntity"</td></tr><tr><td>模式</td><td>参见"SessionFacade"</td></tr><tr><td>重构</td><td>参见"EliminateInter-Entity BeanCommunication"</td></tr><tr><td>重构</td><td>参见"MoveBusinessLogictoSession"</td></tr><tr><td>重构</td><td>参见"BusinessLogicinEntityBeans"</td></tr><tr><td>重构</td><td>参见"MergeSessionBeans"</td></tr></table></body></html>

# Storing Entire Entity Bean-Dependent Object Graph  

# Problem Summary  

When a complex tree structure of dependent objects is used in an entity bean, performance can degrade rapidly when loading and storing an entire tree of dependent objects. When the container invokes the entity bean's ejbLoad() method, either for the initial load or for reloads to synchronize with the persistent store, loading the entire tree of dependent objects can prove wasteful. Similarly, when the container invokes the entity bean's ejbStore() method at any time, storing the entire tree of objects can be quite expensive and unnecessary.  

当实体Bean中使用复杂的依赖对象树结构时，加载和存储整个依赖对象树的性能会急剧下降。容器调用实体Bean的`ejbLoad()`方法时（无论是初始加载还是为与持久化存储同步而重新加载），加载整个依赖对象树可能造成资源浪费。同理，容器随时调用实体Bean的`ejbStore()`方法时，存储整个对象树可能产生高昂开销且并无必要。

# Solution Reference  

Identify the dependent objects that have changed since the previous store operation and store only those objects to the persistent store.  

识别自上次存储操作以来发生变更的依赖对象，并仅将这些对象存储至持久化存储中。

Pattern • See “Composite Entity” and “Store Optimization (Dirty Marker) Strategy”.  

模式 • 参见“组合实体”与“存储优化（脏标记）策略”。

Implement a strategy to load only data that is most accessed and required. Load the remaining dependent objects on demand.  

实现一种策略，仅加载访问最频繁且必需的数据。按需加载其余依赖对象。

Pattern • See “Composite Entity” and “Lazy Loading Strategy”.  

模式 • 参见“组合实体”和“延迟加载策略”。

By applying these strategies, it is possible to prevent loading and storing an entire tree of dependent objects.  

通过应用这些策略，可以避免加载和存储整个依赖对象树。

# Exposing EJB-related Exceptions to Non-EJB Clients  

# Problem Summary  

Enterprise beans can throw business application exceptions to clients. When an application throws an application exception, the container simply throws the exception to the client. This allows the client to gracefully handle the exception and possibly take another action. It is reasonable to expect the application developer to understand and handle such application-level exceptions.  

企业级 Bean 可以向客户端抛出业务应用异常。当应用抛出应用异常时，容器会直接将异常抛给客户端。这使得客户端能够优雅地处理异常，并可能采取其他操作。我们有理由期望应用开发者理解并处理这类应用层级的异常。

However, despite employing such good programming practices as designing and using application exceptions, the clients may still receive EJB-related exceptions, such as a java.rmi.RemoteException. This can happen if the enterprise bean or the container encounters a system failure related to the enterprise bean.  

然而，即便采用了诸如设计并使用应用异常等良好的编程实践，客户端仍可能收到与EJB相关的异常，例如`java.rmi.RemoteException`。当企业级Bean或容器遇到与企业级Bean相关的系统故障时，便可能发生此类情况。

The burden is on the application developer, who may not even be aware of or knowledgeable about EJB exceptions and semantics, to understand the implementation details of the non-application exceptions that may be thrown by business tier components. In addition, non-application exceptions may not provide relevant information to help the user rectify the problem.  

应用开发者需要承担理解业务层组件可能抛出的非应用异常实现细节的负担，而这些开发者甚至可能并不了解或熟悉EJB异常及其语义。此外，非应用异常可能无法提供帮助用户解决问题的相关信息。

# Solution Reference  

Decouple the clients from the business tier and hide the business-tier implementation details from clients, using business delegates. Business delegates intercept all service exceptions and may throw an application exception. Business delegates are plain Java objects that are local to the client. Typically, business delegates are developed by the EJB developers and provided to the client developers.  

通过业务委托（Business Delegate）模式解耦客户端与业务层，并向客户端隐藏业务层的实现细节。业务委托会拦截所有服务异常，并可能抛出应用级异常。业务委托是客户端的本地普通Java对象（POJO），通常由EJB开发者开发并交付给客户端开发者使用。

<html><body><table><tr><td>Refactoring</td><td>See"IntroduceBusinessDelegate</td></tr><tr><td>Pattern</td><td>See"BusinessDelegate</td></tr></table></body></html>  

<html><body><table><tr><td>重构</td><td>参见"引入业务委托模式</td></tr><tr><td>模式</td><td>参见"业务委托模式</td></tr></table></body></html>

# Using Entity Bean Finder Methods to Return a Large Results Set  

# Problem Summary  

Frequently, applications require the ability to search and obtain a list of values. Using an EJB finder method to look up a large collection of entity beans will return a collection of remote references. Consequently, the client has to invoke a method on each remote reference to get the data. This is a remote call and can become very expensive, especially impacting performance, when the caller invokes remote calls on each entity bean reference in the collection.  

应用中经常需要搜索并获取值列表。使用EJB查找方法查询大量实体Bean集合时，将返回一组远程引用。因此，客户端必须对每个远程引用调用方法以获取数据。这种远程调用成本极高，尤其当调用者对集合中的每个实体Bean引用发起远程调用时，会显著影响性能。

# Solution Reference  

Implement queries using session beans and DAOs to obtain a list of value objects instead of remote references. Use a DAO to perform searches instead of EJB finder methods.  

通过会话Bean和DAO实现查询以获取值对象列表而非远程引用。使用DAO执行搜索而非EJB查找方法。

<html><body><table><tr><td>Pattern</td><td>See "Value List Handler"</td></tr><tr><td>Pattern</td><td>See"DataAccessObject"</td></tr></table></body></html>  

<html><body><table><tr><td>模式</td><td>参见"Value List Handler"</td></tr><tr><td>模式</td><td>参见"DataAccessObject"</td></tr></table></body></html>

# Client Aggregates Data from Business Components  

# Problem Summary  

The application clients (in the client or presentation tier) typically need the data model for the application from the business tier. Since the model is implemented by business components—such as entity beans, session beans, and arbitrary objects in the business tier—the client must locate, interact with, and extract the necessary data from various business components to construct the data model.  

应用客户端（位于客户端层或表示层）通常需要从业务层获取应用程序的数据模型。由于该模型由业务组件（如实体Bean、会话Bean以及业务层中的任意对象）实现，客户端必须定位、交互并从各类业务组件中提取必要数据以构建数据模型。

These client actions introduce network overhead due to multiple invocations from the client into the business tier. In addition, the client becomes tightly coupled with the application model. In applications where there are various types of clients, this coupling problem multiplies: A change to the model requires changes to all clients that contain code to interact with those model elements comprised of business components.  

这些客户端操作由于需要从客户端多次调用业务层而引入了网络开销。此外，客户端会与应用程序模型形成紧耦合。在存在多种客户端类型的应用中，这种耦合问题会成倍放大：对模型的任何修改，都需要同步调整所有包含与业务组件构成模型元素交互代码的客户端。

# Solution Reference  

Decouple the client from model construction. Implement a business-tier component that is responsible for the construction of the required application model.  

将客户端与模型构建解耦。实现一个负责构建所需应用模型的业务层组件。

Pattern • See “Value Object Assembler”.  

模式 • 参见“值对象装配器”。

# Using Enterprise Beans for Long-Lived Transactions  

# Problem Summary  

Enterprise beans (pre-EJB 2.0) are suitable for synchronous processing. Furthermore, enterprise beans do well if each method implemented in a bean produces an outcome within a predictable and acceptable time period.  

企业级Bean（EJB 2.0之前版本）适用于同步处理场景。此外，若Bean中实现的每个方法都能在可预测且可接受的时间范围内产生结果，则企业级Bean表现优异。

If an enterprise bean method takes a significant amount of time to process a client request, or if it blocks while processing, this also blocks the container resources, such as memory and threads, used by the bean. This can severely impact performance and deplete system resources.  

如果企业级Bean方法处理客户端请求耗时过长，或在处理过程中发生阻塞，这将同时阻塞该Bean占用的容器资源（如内存和线程），从而严重影响系统性能并耗尽资源。

An enterprise bean transaction that takes a long time to complete potentially locks out resources from other enterprise bean instances that need those resources, resulting in performance bottlenecks.  

长时间运行的企业级Bean事务可能会锁定其他需要相同资源的企业级Bean实例，从而导致性能瓶颈。

# Solution Reference  

Implement asynchronous processing service using a message-oriented middleware (MOM) with a Java Message Service (JMS) API to facilitate long-lived transactions.  

使用基于Java消息服务(JMS) API的消息导向中间件(MOM)实现异步处理服务，以支持长事务处理。

Pattern • See “Service Activator”.  

模式 • 参见“服务激活器”。

# Stateless Session Bean Reconstructs Conversational State for Each Invocation  

# Problem Summary  

Some designers choose stateless session beans to increase scalability. They may inadvertently decide to model all business processes as stateless session beans even though the session beans require conversational state. But, since the session bean is stateless, it must rebuild conversational state in every method invocation. The state may have to be rebuilt by retrieving data from a database. This completely defeats the purpose of using stateless session beans to improve performance and scalability and can severely degrade performance.  

部分设计者选择无状态会话Bean来提升可扩展性。他们可能无意中将所有业务流程都建模为无状态会话Bean，即便这些业务流程需要维护会话状态。但由于会话Bean的无状态特性，每次方法调用时都必须重建会话状态。这种状态重建可能需要通过数据库检索数据来完成，这完全违背了使用无状态会话Bean提升性能和扩展性的初衷，并可能导致性能严重下降。

# Solution Reference  

Analyze the interaction model before choosing the stateless session bean mode. The choice of stateful or stateless session bean depends on the need for maintaining conversational state across method invocations in stateful session bean versus the cost of rebuilding the state during each invocation in stateless session bean.  

在选择无状态会话Bean模式前，需先分析交互模型。有状态会话Bean与无状态会话Bean的选择取决于以下权衡：前者需要维护跨方法调用的会话状态，后者则需承担每次调用时重建状态的开销。

<html><body><table><tr><td>Pattern</td><td>See SessionFacade"," StatelessSessionFacadeStrategy",and Stateful SessionFacadeStrategy"</td></tr><tr><td>Design</td><td>See Session Bean-StatelessVersus Stateful" and Storing Stateonthe Business Tier"</td></tr></table></body></html>  

<html><body><table><tr><td>模式</td><td>参见SessionFacade、StatelessSessionFacadeStrategy和StatefulSessionFacadeStrategy</td></tr><tr><td>设计</td><td>参见Session Bean-StatelessVersus Stateful及StoringStateontheBusinessTier</td></tr></table></body></html>

# Chapter 5. J2EE REFACTORINGS  

# Topics in This Chapter  

Presentation Tier Refactorings Business and Integration Tier Refactorings General Refactorings  

表现层重构 业务与集成层重构 通用重构

This chapter discusses refactoring for the presentation, business, and integration tiers.  

本章讨论针对表示层、业务层和集成层的重构。

# Presentation Tier Refactorings  

The refactorings in this section apply to the presentation tier.  

本节的重构适用于表示层。

# Introduce a Controller  

Control logic is scattered throughout the application, typically duplicated in multiple Java Server Page (JSP) views.  

控制逻辑分散在整个应用程序中，通常会在多个JSP视图中重复出现。

Extract control logic into one or more controller classes that serve as the initial contact point for handling a client request.  

将控制逻辑抽取到一个或多个控制器类中，这些类作为处理客户端请求的初始接触点。

![](images/4e7de366262bc881dcb522ec6f4c091c26dfe034bfecba56853da4543d040238.jpg)  
Figure 5.1. Introduce a controller  

图5.1 引入控制器

# Motivation  

Control code that is duplicated in multiple JSPs also needs to be maintained in each JSP. Extracting this code into one or more centralized controller class improves the modularity, reusability, and maintainability of the application.  

在多个JSP中重复的控制代码需要在每个JSP中单独维护。将这些代码提取到一个或多个集中式控制器类中，可提升应用程序的模块化、可复用性和可维护性。

# Mechanics  

• Use the Front Controller pattern as a guide for applying Extract Class [Fowler] to create a controller class, moving duplicate control logic from individual JSPs into this controller.  

• 以**前端控制器模式**为指导，运用[Fowler]的**提取类**重构方法创建控制器类，将分散在各JSP中的重复控制逻辑移至该控制器中。

o See “Front Controller”. o Remember that the controller is a delegation point for controlling the request handling. Partition the code with an eye toward modularity and reuse. Do not necessarily embed all the control code directly within a single controller, but rather consider creating helper components to which it may delegate. See “Creating Fat Controllers”.   
Control code may also be encapsulated in command objects that work in   
coordination with the controller, utilizing the Command pattern [GoF]. o See “Front Controller”, “Command and Controller Strategy.”  

参见“前端控制器”。  
需谨记控制器是请求处理流程的委托控制点。代码划分应着眼于模块化和可复用性，**避免将所有控制逻辑直接嵌入单一控制器**，而应考虑创建可委托的辅助组件。详见“避免臃肿控制器”。  

控制逻辑还可封装为与控制器协同工作的命令对象，此时需采用[GoF]中的**命令模式**。相关参考：“前端控制器”、“命令与控制器策略”。

# Example  

Assume we have the structure shown in Example 5.1 in many of our JSPs.  

假设我们的多个JSP中都存在示例5.1所示的结构。

# Example 5.1 Introduce a Controller – JSP Structure  

<HTML>   
<BODY> <control:grant_access/>   
</BODY> </HTML>  

<HTML>   
<BODY> <control:grant_access/>   
</BODY> </HTML>

The three vertical dots represent the body of each JSP, which is not being shown in this example. While this body portion differs for each JSP, the helper at the top of the page, implemented as a custom tag, is the same. This helper is responsible for controlling access to this page. It is an “all-or-nothing” type of control, meaning that a client is either granted access to the whole page or is denied access entirely.  

三个垂直圆点表示每个JSP的主体部分，本例中未予展示。虽然这部分内容因JSP而异，但页面顶部以自定义标签形式实现的辅助组件是相同的。该组件负责控制对此页面的访问权限，属于“全有或全无”型控制机制——即客户端要么获得整个页面的访问权限，要么被完全拒绝访问。

If we change the design and introduce a controller, as described in the mechanics, then each of our JSPs will no longer include the <control:grant_access/ $>$ tag, as seen in Example 5.1.  

若按照机制说明更改设计并引入控制器，则如示例5.1所示，各JSP页面将不再包含`<control:grant_access/>`标签。

Instead, we have a centralized controller that manages this behavior, handling the access control check that we removed from each JSP. Example 5.2 is a snippet of code from the controller, which is implemented as a servlet.  

取而代之的是，我们采用了一个集中式控制器来管理这一行为，处理从各个JSP中移除的访问控制检查。示例5.2展示了该控制器（以Servlet形式实现）的代码片段。

# Example 5.2 Introduce a Controller - Controller Structure  

if (grantAccess())   
{ dispatchToNextView();   
else   
{ dispatchToAccessDeniedView();  

if (grantAccess())   
{ dispatchToNextView();   
else   
{ dispatchToAccessDeniedView();

Of course, there are some cases where helpers are suitable for control code. For example, if only a small fraction of our JSPs need this type of access control, then it is not unreasonable to include a custom tag helper in each of these few pages to accomplish this goal. Another reason we might use custom tags in individual JSPs is to control access to specific subviews of a composite view (see “Composite View”).  

当然，在某些情况下，辅助类确实适合用于控制代码。例如，如果仅有少量JSP页面需要此类访问控制，那么在这些少数页面中分别引入自定义标签辅助类来实现该目标并非不合理。另一个可能促使我们在独立JSP中使用自定义标签的原因是：需要控制对组合视图中特定子视图的访问（参见"组合视图"模式）。

If we are already using a controller, then we still might want to add this behavior in this centralized place, since the number of pages we want to protect might grow over time. To handle the case of an existing controller, we simply extract control code from our views and add it to the existing controller. In effect, we are moving methods (using Move Method [Fowler]) instead of extracting a new class.  

若已存在控制器，我们仍可能希望将此类行为集中添加于此，因为需保护的页面数量可能随时间增长。针对已有控制器的场景，只需从视图中提取控制逻辑并整合至现有控制器即可。实际上，我们是通过**移动方法**[Fowler]而非提取新类来实现重构。

# Introduce Synchronizer Token  

Clients make duplicate resource requests that should be monitored and controlled, or clients access certain views out of order by returning to previously bookmarked pages.  

客户端会发起重复的资源请求，这些请求应当被监控和管控；或者客户端通过返回之前收藏的页面，以非预期顺序访问某些视图。

Use a shared token to monitor and control the request flow and client access to certain resources.  

使用共享令牌来监控和控制请求流及客户端对特定资源的访问。

![](images/2e0bfcbaaf5a031b6dacaa5e1b566875a67d1dca99012ba4ff93e1a61ca18b79.jpg)  
Figure 5.2. Introduce synchronizer token  

图5.2 引入同步器令牌

# Motivation  

There are a number of scenarios in which control of an incoming request is desired. One of the most common reasons is the desire to control duplicate request submissions from a client. Such duplicate submissions may occur when the user clicks the Back or Stop browser buttons and resubmits a form.  

在多种场景下都需要对传入请求进行控制。最常见的原因之一是需要防止客户端重复提交请求。当用户点击浏览器的后退或停止按钮并重新提交表单时，就可能发生此类重复提交情况。

While this issue is mainly one of controlling the order or flow of the requests, there is also the issue of controlling access based on permissions. For introducing permission-based control, see “Hide Resource From a Client” .  

虽然该问题主要涉及控制请求的顺序或流程，但还存在基于权限的访问控制问题。有关引入基于权限的控制，请参阅“向客户端隐藏资源”。

# Mechanics  

Create one or more helper classes responsible for generating and comparing one-time-use, unique tokens.  

创建一个或多个辅助类，负责生成和比较一次性使用的唯一令牌。

o Alternatively, this logic may be added to already existing control components.   
o The component managing this activity (typically a controller, but possibly a JSP) delegates to these helpers, managing the temporary storage of a fresh token for each client submission.   
o A copy of the token is stored per user on the server and on the client browser. The token is typically stored on the client browser as a hidden field and on the server in a user session.  

- 或者，该逻辑可被添加至现有控制组件中  
- 管理该活动的组件（通常为控制器，也可能是JSP）委托这些辅助类处理工作，负责为每个客户端提交管理临时存储的新令牌  
- 服务器端和客户端浏览器会为每个用户存储令牌副本。令牌通常以隐藏字段形式存储在客户端浏览器中，在服务器端则存储于用户会话中

# When Is a Token Generated and  

# Stored? When Is a Token Checked?  

A synchronizer token is compared for a match before processing an arriving request. A new token value is generated and stored after processing this request, but before the response is prepared and sent to the client.  

在处理到达的请求前，会先比对同步器令牌是否匹配。在处理完该请求后、但在准备响应并发送给客户端之前，系统会生成并存储新的令牌值。

For more information, see “Introduce Synchronizer Token” and Figure 5.3.  

更多信息请参阅“引入同步令牌”及图5.3。

![](images/604efba730da7f867a26f5303e6b8badc1127e295d3b7eab2a1ede22d66b0e7c.jpg)  
Figure 5.3. Synchronizer token life cycle  

图5.3 同步器令牌生命周期

Add logic to check whether the token arriving with the client request matches the token in the user session.  

添加逻辑以校验客户端请求携带的令牌是否与用户会话中的令牌匹配。

o The token arriving from the client in the current request should be the same token that the server sent to the client with its last response. Thus a match of these two values confirms that this is not a duplicate submission, while a mismatch suggests this possibility. As stated, a mismatch might also occur for other reasons, such as a user navigating directly to a bookmarked page, but a duplicate request submission is the most common reason. (See Presentation  

客户端在当前请求中携带的令牌应当与服务器最近一次响应下发的令牌保持一致。两者匹配可确认非重复提交，若出现不匹配则存在该可能性。需说明的是，不匹配也可能由其他原因导致（例如用户直接访问书签页面），但重复请求提交仍是最常见原因。（参见Presentation）

Tier Design Considerations - Controlling Client Access” for more information.)  

分层设计考量——控制客户端访问（详见相关说明）

• A controller typically manages token generation and comparison. Consider introducing a controller, if one does not already exist.  

• 控制器通常负责管理令牌生成与比对。若当前不存在控制器，建议引入该组件。

o See “Introduce a Controller” .   
o Without a controller to centralize management of token generation and comparison, this behavior must be referenced from each JSP.   
o Typically, the JSP delegates to a helper component, implemented as either a JavaBean or custom tag (see “View Helper” ), which encapsulates the responsibilities token management.  

o 参见“引入控制器”章节。  
o 若缺乏用于集中管理令牌生成与比对的控制器，则必须从每个JSP页面引用此行为。  
o 通常JSP会委托给辅助组件（实现为JavaBean或自定义标签，参见“视图助手”模式），该组件封装了令牌管理的职责。

The source code excerpts in Introduce Synchronizer Token are reprinted with permission under the Apache Software License, Version 1.1. See page 425 to view the terms of this license.  

《引入同步令牌模式》中的源代码摘录已根据 Apache 软件许可证 1.1 版授权转载。该许可证条款详见第 425 页。

# Example  

The Struts presentation framework applies several of the J2EE patterns and refactorings. It introduces this exact type of request flow control, and we use excerpts from this open source framework in our example.  

Struts表现层框架应用了多种J2EE模式和重构技术。它引入了这种精确类型的请求流控制机制，我们在示例中采用了该开源框架的代码片段。

Instead of creating a separate utility class to encapsulate the token generation and matching logic, Struts simply adds this functionality to a preexisting class that is part of its control mechanism. The class is called Action, and it is a common superclass for all actions. Actions are Command objects that extend the controller functionality. This is an application of the Front Controller pattern, Command and Controller strategy.  

Struts并未创建单独的实用工具类来封装令牌生成与匹配逻辑，而是直接将此功能集成到其控制机制中已有的类中。这个类名为`Action`，它是所有动作的公共父类。动作作为命令对象扩展了控制器功能，这是**前端控制器模式**与**命令控制器策略**的具体应用。

As shown in Example 5.3, the saveToken() method, which is part of the Action class, generates and stores token values.  

如示例5.3所示，Action类中的saveToken()方法负责生成并存储令牌值。

# Example 5.3 Generate and Store Token  

/\*\* Save a new transaction token in the   
$\star$ user's current session, creating a new session if necessary.   
$\star$   
$\star$ @param request The servlet request we are processing   
\*/   
protected void saveToken(HttpServletRequest request)   
HttpSession session $=$ request.getSession();   
String token $=$ generateToken(request);  

/** 在用户当前会话中保存新的事务令牌，必要时创建新会话  
 *  
 * @param request 当前处理的servlet请求  
 */  
protected void saveToken(HttpServletRequest request)   
HttpSession session = request.getSession();   
String token = generateToken(request);

if (token ! $=$ null) session.setAttribute(TRANSACTION_TOKEN_KEY, token);  

if (token != null) session.setAttribute(TRANSACTION_TOKEN_KEY, token);

Copyright (c) 1999 The Apache Software Foundation. All rights reserved.  

版权所有 (c) 1999 年 Apache 软件基金会。保留所有权利。

This method generates a unique token, calculated using the session ID and the current time, and stores this value into the user session.  

该方法生成一个唯一令牌，通过会话ID和当前时间计算得出，并将该值存储到用户会话中。

At some point (usually immediately) prior to generating the HTML display for the client responsible for submitting a request that we do not want to duplicate (this display typically includes a form to be posted back to the server), a one-time token value is set, as previously described, by making the following method invocation:  

在生成针对提交请求的客户端（通常不希望重复提交的请求）的HTML显示之前（通常立即执行，该显示通常包含一个将回发至服务器的表单），会按照前述方式通过以下方法调用来设置一次性令牌值：

saveToken(request);  

保存Token(request);

Additionally, the JSP responsible for generating this HTML display also includes logic that delegates to a helper class to generate a hidden field that includes this token value. Thus, the page sent to the client, which typically includes a form that will be submitted back to the server, includes a hidden field of the following form:  

此外，负责生成该HTML显示的JSP还包含将逻辑委托给辅助类的代码，以生成包含此令牌值的隐藏字段。因此，发送给客户端的页面（通常包含将提交回服务器的表单）会包含如下形式的隐藏字段：

<input type $=$ "hidden" name $=$ "org.apache.struts.taglib.html.TOKEN" value $=$ "8d2c392e93a39d299ec45a22">  

<input type="hidden" name="org.apache.struts.taglib.html.TOKEN" value="8d2c392e93a39d299ec45a22">

The value attribute of this hidden field is the value of the token that was generated by the saveToken() method.  

该隐藏字段的value属性即为saveToken()方法生成的令牌值。

When the client submits the page that includes this hidden field, the controller delegates to a Command object (again, a subclass of the Action class) that compares the token value in the user session with the value in the request object parameter that came from the hidden field in the page. The Command object uses the method shown in Example 5.4, also excerpted from its superclass (the Action class again), to compare the values.  

当客户端提交包含此隐藏字段的页面时，控制器会委托给一个Command对象（同样是Action类的子类），该对象将用户会话中的令牌值与来自页面隐藏字段的请求对象参数值进行比对。Command对象使用示例5.4所示的方法（同样摘录自其超类Action）来比较这些值。

# Example 5.4 Check For a Valid Token  

大\*  

大\*

$\star$ Return <code>true</code> if there is a transaction $\star$ token stored in the user's current session, and $\star$ the value submitted as a request request parameter $\star$ with this action matches it.  

$\star$ 如果用户当前会话中存储有事务 $\star$ 令牌，且 $\star$ 通过该操作提交的请求参数值 $\star$ 与之匹配，则返回 <code>true</code>。

\* Returns <code>false</code> under any of the following circumstances: <ul> <li>No session associated with this request</li>   
\* <li>No transaction token saved in the session</li>   
\* <li>No transaction token included as a request parameter</li> <li>The included transaction token value does not   
$\star$ match the transaction token in the user's session</li> </ul>   
$\star$   
\* @param request The servlet request we are processing   
\*/   
protected boolean isTokenValid(HttpServletRequest request) { // Retrieve the saved transaction token from our // session HttpSession session $=$ request.getSession(false); if (session $==$ null) return (false); String saved $=$ (String) session.getAttribute(TRANSACTION_TOKEN_KEY); if (saved $==$ null) return (false); // Retrieve the transaction token included in this // request String token $=$ (String) request.getParameter(Constants.TOKEN_KEY); if (token $==$ null) return (false); // Do the values match? return (saved.equals(token));  

\* 在以下任一情况下返回<code>false</code>：<ul><li>当前请求未关联任何会话</li>  
\* <li>会话中未保存事务令牌</li>  
\* <li>请求参数中未包含事务令牌</li><li>请求中包含的事务令牌值  
$\star$ 与用户会话中的事务令牌不匹配</li></ul>  
$\star$  
\* @param request 正在处理的servlet请求  
\*/  
protected boolean isTokenValid(HttpServletRequest request) { // 从会话中获取已保存的事务令牌 HttpSession session $=$ request.getSession(false); if (session $==$ null) return (false); String saved $=$ (String) session.getAttribute(TRANSACTION_TOKEN_KEY); if (saved $==$ null) return (false); // 获取本次请求中包含的事务令牌 String token $=$ (String) request.getParameter(Constants.TOKEN_KEY); if (token $==$ null) return (false); // 校验令牌值是否匹配 return (saved.equals(token));

Copyright (c) 1999 The Apache Software Foundation. All rights reserved.  

版权所有 (c) 1999 阿帕奇软件基金会。保留所有权利。

If there is a match, then we are certain that this request submission is not a duplicate. If the tokens do not match, then we are able to take appropriate action to deal with this potentially duplicate form submission.  

若匹配成功，则可确定该请求提交并非重复操作。若令牌不匹配，我们便能采取适当措施处理这一潜在的重复表单提交。

# Localize Disparate Logic  

Business logic and presentation formatting are intermingled within a JSP view.  

业务逻辑与展示层格式化代码混杂在JSP视图层中。

Extract business logic into one or more helper classes that can be used by the JSP or by a controller.  

将业务逻辑抽取到一个或多个辅助类中，这些类可供JSP或控制器调用。

Figure 5.4 shows logic being extracted from a view and into helpers.  

图5.4展示了从视图抽取逻辑并转移到辅助类的过程。

![](images/e663911730b2e3aa347cb0efa27543a5e9c06ae8bba875f7f5faaa5be8292b9e.jpg)  
Figure 5.4. Localize Disparate Logic: Factor Back  

图5.4 分散逻辑本地化：逆向重构

Figure 5.5 shows logic being extracted from a view and into a controller, a command object, and helpers.  

图5.5展示了从视图层抽离逻辑并将其转移至控制器、命令对象和辅助类的过程。

![](images/5bf360af24191b0bb43ececf8bcefbef2d32730a8b44caaebe84e2b1f4094ea4.jpg)  
Figure 5.5. Localize Disparate Logic: Factor Forward  

图5.5 分散逻辑本地化：前向因子化

# Motivation  

To create cleaner abstractions, increase cohesion and reduce coupling, which improves modularity and reusability. Well-partitioned, modular applications also provide better separation of developer roles, since Web developers own formatting code, while software developers own business logic.  

通过创建更清晰的抽象、增强内聚性并降低耦合度，从而提升模块化与可复用性。合理划分的模块化应用还能实现开发者角色的更好分离——Web开发者负责格式化代码，而软件开发人员则专注于业务逻辑的实现。

# Mechanics  

Use the View Helper pattern as a guide for applying Extract Class [Fowler] to create new helper classes, moving business logic from the JSP into these helpers. Delegate to these helper classes from the JSP. o See “View Helper” . o The initial contact point for handling the client request could be the view, as shown in the Factor Back diagram in Figure 5.4. See “Dispatcher View” . • Consider introducing a controller, if one does not already exist. o See “Introduce a Controller” . o As shown in the Factor Forward diagram in Figure 5.5, the controller may use a command helper. o The initial contact point for handling the client request could be the controller, as shown in the Factor Forward diagram. See “Service to Worker” .  

以**视图助手模式**为指导，运用**提取类**[Fowler]原则创建新的助手类，将业务逻辑从JSP迁移至这些助手类中。通过JSP调用这些助手类完成逻辑委托。  
- 参见“视图助手”章节  
- 如图5.4的**回撤因子图**所示，视图可作为处理客户端请求的初始接触点  
- 参见“分发器视图”章节  

• 若当前不存在控制器，建议引入控制器机制  
  - 参见“引入控制器”章节  
  - 如图5.5的**前推因子图**所示，控制器可采用命令助手模式  
  - 如图中前推因子图所示，控制器可作为处理客户端请求的初始接触点  
  - 参见“服务到工作者”章节

# Example  

We start with the sample code listed in Example 5.5. It is a JSP that includes lots of scriptlet code, intermingling business logic with the view.  

我们从示例5.5列出的示例代码开始。这是一个包含大量脚本片段代码的JSP，将业务逻辑与视图混杂在一起。

# Example 5.5 JSP with Scriptlet Code  

<html>   
<head><title>Employee List</title></head>   
<body>   
<%-- Display All employees belonging to a department and earning at most the given salary --%>  

<html>  
<head><title>员工列表</title></head>  
<body>  
<%-- 显示属于某部门且薪资不超过给定值的所有员工 --%>

# <%  

// Get the department for which the employees are // to be listed  

// 获取需要列出员工的部门

String deptidStr $=$ request.getParameter( Constants.REQ_DEPTID);   
// Get the max salary constraint   
String salaryStr $=$ request.getParameter( Constants.REQ_SALARY);   
// validate parameters   
// if salary or department not specified, go to   
// error page   
if ( (deptidStr $==$ null) || (salaryStr $==$ null ) )   
{ request.setAttribute(Constants.ATTR_MESSAGE, "Insufficient query parameters specified" $^+$ "(Department and Salary)"); request.getRequestDispatcher("/error.jsp"). forward(request, response);   
}   
// convert to numerics   
int deptid $\begin{array}{r l}{\mathbf{\eta}}&{{}=\mathbf{\eta}}\ {\mathbf{\eta}}&{{}=\mathbf{\eta}}\end{array}\begin{array}{r l}\end{array}}\end{array}0$ ;   
float salary $\qquad=\quad0$ ;   
try   
{ deptid $=$ Integer.parseInt(deptidStr); salary $=$ Float.parseFloat(salaryStr);   
}   
catch(NumberFormatException e)   
{ request.setAttribute(Constants.ATTR_MESSAGE, "Invalid Search Values" $^+$ "(department id and salary )"); request.getRequestDispatcher("/error.jsp"). forward(request, response);   
// check if they within legal limits   
if ( salary $<~0$ )   
{ request.setAttribute(Constants.ATTR_MESSAGE, "Invalid Search Values" $^+$ "(department id and salary )"); request.getRequestDispatcher("/error.jsp"). forward(request, response);  

String deptidStr $=$ request.getParameter(Constants.REQ_DEPTID);  
// 获取最高薪资限制  
String salaryStr $=$ request.getParameter(Constants.REQ_SALARY);  
// 验证参数  
// 若薪资或部门未指定，则跳转至错误页面  
if ((deptidStr $==$ null) || (salaryStr $==$ null))  
{ request.setAttribute(Constants.ATTR_MESSAGE, "查询参数不足" $^+$ "(需指定部门和薪资)"); request.getRequestDispatcher("/error.jsp").forward(request, response);  
}  
// 转换为数值类型  
int deptid $\begin{array}{r l}{\mathbf{\eta}}&{{}=\mathbf{\eta}}\ {\mathbf{\eta}}&{{}=\mathbf{\eta}}\end{array}\begin{array}{r l}\end{array}}\end{array}0$;  
float salary $\qquad=\quad0$;  
try  
{ deptid $=$ Integer.parseInt(deptidStr); salary $=$ Float.parseFloat(salaryStr);  
}  
catch(NumberFormatException e)  
{ request.setAttribute(Constants.ATTR_MESSAGE, "无效的搜索值" $^+$ "(部门ID和薪资)"); request.getRequestDispatcher("/error.jsp").forward(request, response);  
// 检查是否在合法范围内  
if (salary $<~0$)  
{ request.setAttribute(Constants.ATTR_MESSAGE, "无效的搜索值" $^+$ "(部门ID和薪资)"); request.getRequestDispatcher("/error.jsp").forward(request, response);

%>  

%>

<h3><center> List of employees in department # < $\Rsh$ deptid%> earning at most $<\frac{\circ}{\circ}=$ salary %>. </h3>   
<% Iterator employees $=$ new EmployeeDelegate(). getEmployees(deptid);   
%>   
<table border $=$ "1" <tr> <th> First Name </th> <th> Last Name </th> <th> Designation </th> <th> Employee Id </th> <th> Tax Deductibles </th> <th> Performance Remarks </th> <th> Yearly Salary</th> </tr>   
<% while ( employees.hasNext() ) { EmployeeVO employee $=$ (EmployeeVO) employees.next(); // display only if search criteria is met if ( employee.getYearlySalary() $<=$ salary ) {   
%> <tr> <td> <%=employee.getFirstName()%></td> <td> <%=employee.getLastName()%></td> <td> <% $=$ employee.getDesignation()%></td> <td> <% $=$ employee.getId()%></td> <td> <%=employee.getNoOfDeductibles()%></td> <td> <% $=$ employee.getPerformanceRemarks()%> </td> <td> <% $=$ employee.getYearlySalary()%></td> </tr>   
<%  

<h3><center> 部门编号 # < $\Rsh$ deptid%> 中薪资不超过 $<\frac{\circ}{\circ}=$ salary %> 的员工列表 </h3>  
<% Iterator employees $=$ new EmployeeDelegate(). getEmployees(deptid);   
%>  
<table border $=$ "1" <tr> <th> 名 </th> <th> 姓 </th> <th> 职位 </th> <th> 员工编号 </th> <th> 税收减免项 </th> <th> 绩效评语 </th> <th> 年薪</th> </tr>  
<% while ( employees.hasNext() ) { EmployeeVO employee $=$ (EmployeeVO) employees.next(); // 仅显示符合搜索条件的记录 if ( employee.getYearlySalary() $<=$ salary ) {   
%> <tr> <td> <%=employee.getFirstName()%></td> <td> <%=employee.getLastName()%></td> <td> <% $=$ employee.getDesignation()%></td> <td> <% $=$ employee.getId()%></td> <td> <%=employee.getNoOfDeductibles()%></td> <td> <% $=$ employee.getPerformanceRemarks()%> </td> <td> <% $=$ employee.getYearlySalary()%></td> </tr>  
<%

%> </table>  

%> </table>

<%@ include file $=$ "/jsp/trace.jsp" %> <P> <B>Business logic and presentation formatting are intermingled within this JSP view. </B>  

<%@ include file $=$ "/jsp/trace.jsp" %> <P> <B>业务逻辑与展示层格式在此JSP视图中混杂耦合。</B>

</body> </html>  

</body> </html>

This JSP generates an HTML table that lists employees at a certain salary level. The JSP encapsulates formatting and business logic, as shown in Figure 5.6.  

该JSP生成一个HTML表格，用于列出特定薪资级别的员工。如图5.6所示，该JSP封装了格式化和业务逻辑。

# Figure 5.6. View with intermingled business logic and formatting code  

![](images/7e36157bf73904e29a2745cad8efdae44d672a1624b20e679a62e8d4cdcd9e4f.jpg)  

As Example 5.6 shows, we apply the View Helper pattern, changing the design and extracting scriptlet code from the JSP view.  

如示例5.6所示，我们应用了视图助手模式，通过改变设计将脚本代码从JSP视图中抽离出来。

# Example 5.6 JSP with Scriptlet Code Extracted  

<%@ taglib uri $=$ "/WEB-INF/corepatternstaglibrary.tld" prefix $\varepsilon$ "corepatterns" %>   
<html>   
<head><title>Employee List</title></head>   
<body>   
<corepatterns:employeeAdapter />   
<h3><center>List of employees in <corepatterns:department attribute $=$ "id"/> department - Using Custom Tag Helper Strategy </h3>   
<table border $=$ "1" > <tr> <th> First Name </th> <th> Last Name </th> <th> Designation </th> <th> Employee Id </th> <th> Tax Deductibles </th> <th> Performance Remarks </th> <th> Yearly Salary</th> </tr> <corepatterns:employeelist id $\varepsilon$ "employeelist_key"> <tr> <td><corepatterns:employee attribute $=$ "FirstName"/></td> <td><corepatterns:employee attribute $=$ "LastName"/></td> <td><corepatterns:employee attribute $=$ "Designation"/> </td> <td><corepatterns:employee attribute $=$ "Id"/></td> <td><corepatterns:employee attribute $=$ "NoOfDeductibles"/></td> <td><corepatterns:employee attribute $=$ "PerformanceRemarks"/></td> <td><corepatterns:employee attribute $=$ "YearlySalary"/></td> <td> </tr> </corepatterns:employeelist>   
</table>   
</body>   
</html>  

<%@ taglib uri="/WEB-INF/corepatternstaglibrary.tld" prefix="corepatterns" %>  
<html>  
<head><title>员工列表</title></head>  
<body>  
<corepatterns:employeeAdapter />  
<h3><center><corepatterns:department attribute="id"/> 部门员工列表 - 采用自定义标签辅助策略</h3>  
<table border="1">  
<tr>  
<th>名</th>  
<th>姓</th>  
<th>职位</th>  
<th>员工编号</th>  
<th>税务抵扣项</th>  
<th>绩效评语</th>  
<th>年薪</th>  
</tr>  
<corepatterns:employeelist id="employeelist_key">  
<tr>  
<td><corepatterns:employee attribute="FirstName"/></td>  
<td><corepatterns:employee attribute="LastName"/></td>  
<td><corepatterns:employee attribute="Designation"/></td>  
<td><corepatterns:employee attribute="Id"/></td>  
<td><corepatterns:employee attribute="NoOfDeductibles"/></td>  
<td><corepatterns:employee attribute="PerformanceRemarks"/></td>  
<td><corepatterns:employee attribute="YearlySalary"/></td>  
</tr>  
</corepatterns:employeelist>  
</table>  
</body>  
</html>

Additionally, we have written two custom tag helpers to encapsulate our business and presentation formatting processing logic by adapting the data model into the rows and columns of our HTML table.  

此外，我们还编写了两个自定义标签助手，通过将数据模型适配到HTML表格的行列结构中，封装了业务与展示层的格式化处理逻辑。

The two helpers are the <corepatterns:employeelist> tag and the <corepatterns:employee> tag.  

这两个辅助工具是 `<corepatterns:employeelist>` 标签和 `<corepatterns:employee>` 标签。

Figure 5.7 shows that we have moved from the design represented by the left side of the arrow to the one represented on the right side.  

图5.7表明，我们已从箭头左侧所示的设计方案演进至右侧所示的设计方案。

![](images/1386b919150265e340ed4c05053c833aa211477da36bf49febfb764c81a411c5.jpg)  

Business logic has been extracted into helper classes instead of being embedded directly within the JSP. These helpers handle a variety of tasks, including content retrieval, access control, and adapting model state for display. In the second case, the helper actually encapsulates some of the presentation processing logic, such as formatting a result set into an HTML table. See also “Remove Conversions from View” . This helps us meet our goal of extracting as much programming logic from the view as possible, thus using the JSP to ask the helper for the completed table, instead of including scriptlet code in the JSP to generate the table.  

业务逻辑已被提取至辅助类中，而非直接嵌入JSP页面。这些辅助类处理多种任务，包括内容检索、访问控制以及适配模型状态以用于展示。在第二种场景中，辅助类实际封装了部分呈现处理逻辑，例如将结果集格式化为HTML表格。另请参阅“从视图移除转换逻辑”。这有助于实现我们尽可能从视图层抽离编程逻辑的目标，从而让JSP通过调用辅助类获取已完成的表格，而非在JSP中编写脚本代码来生成表格。

Helper components may be implemented as JavaBeans or custom tags (see “View Helper” ). JavaBean helpers are well suited to encapsulating content retrieval logic and storing the results, while custom tag helpers are well suited to the aforementioned task of converting the model for display, such as creating a table from a result set. There is quite a bit of overlap, though, so other factors, such as developer experience and manageability issues, may affect the decision about how to implement a helper.  

辅助组件可选用JavaBean或自定义标签实现（参见“视图助手”模式）。JavaBean助手擅长封装内容检索逻辑并存储结果，而自定义标签助手则更适用于前文所述的模型转换显示任务，例如将结果集渲染为表格。两者功能存在显著重叠，因此开发者经验、可维护性等因素也会影响具体实现方式的选择。

Applying the second bullet of the mechanics, we simply delegate the work to the helpers, as shown in Figure 5.8.  

根据机制的第二要点，我们只需将工作委托给辅助类，如图5.8所示。

![](images/cc5820d3366423026501a6e0edba6232d39c82eab19ed01635cc962d4bda2fbe.jpg)  
Figure 5.7. Extracting business logic into helper   
Figure 5.8. Delegate work to helpers  

图5.7 将业务逻辑提取至辅助类  
图5.8 将工作委托给辅助类

The JSP view uses the helper classes to perform the view processing and generation. Typically, a controller is used in front of the JSP as the initial contact point for client requests (see “Front Controller” and “Introduce a Controller”). The controller dispatches to the view, but prior to doing so, the controller may also delegate work to the helper components (see “Service to Worker” ). Having introduced a controller, we have made the transition shown in Figure 5.9.  

JSP视图通过辅助类完成视图处理与生成。通常会在JSP前端配置控制器作为客户端请求的初始接入点（参见"前端控制器"和"引入控制器"模式）。控制器在调度至视图前，可能将工作委托给辅助组件（参见"服务至工作者"模式）。引入控制器后，系统架构已实现图5.9所示的演进。

![](images/46988e445aea82c2efe6ed5875dcef41925c392b2731575ceec4f5176787df45.jpg)  
Figure 5.9. Introducing a controller  

图5.9 控制器引入

# Hide Presentation Tier-Specific Details From the Business Tier  

Request handling and/or protocol-related data structures are exposed from the presentation tier to the business tier.  

请求处理和/或协议相关的数据结构从表示层暴露到了业务层。

Remove all references to request handling and protocol-related presentation tier data structures from the business tier. Pass values between tiers using more generic data structures.  

移除业务层中所有涉及请求处理及协议相关表示层数据结构的引用。应使用更通用的数据结构在层间传递值。

![](images/56055fbf329c147ac71cbf42af76022e7a73bf93eb81ff917e74ff96ada75c9c.jpg)  
Figure 5.10. Hide presentation tier-specific details from the business tier  

图5.10 对业务层隐藏表示层特定细节

# Motivation  

Implementation details specific to one tier should not be introduced in another tier. The service API exposed by the business tier to the presentation tier will likely be used by other clients as well. If the service API accepts parameters with types, such as HttpServletRequest, then every client to the service is forced to package its data in a servlet request data structure. This drastically reduces the service's reusability.  

特定分层的实现细节不应引入其他分层。业务层向表示层暴露的服务接口很可能被其他客户端调用。若该服务接口接收诸如`HttpServletRequest`这类类型参数，则每个服务客户端都被迫将其数据封装为Servlet请求数据结构，这将严重降低服务的可复用性。

# Mechanics  

Replace all references to presentation-tier data structures in the business tier with references to more generic data structures and types. o These are typically business-tier methods accepting parameters with types such as HttpServletRequest that might be replaced with parameters of more generic types, such as String, int, or UserInfo. Modify client code in the presentation tier that invokes these methods. o Pieces of the presentation tier data structure may be passed to the business tier methods as individual arguments. For example, if the HttpServletRequest has parameters x, y, and z, a method in the business tier, instead of accepting the HttpServletRequest as a parameter, might accept these three arguments individually as Strings. One drawback of passing fine-grained, individual arguments is that this strategy more tightly couples the details of the presentation tier with the business service API. Thus, if the state required by the service changes, then the service API must change. O o A slightly more flexible alternative is to copy the relevant state from the presentation tier data structure into a more generic data structure, such as a value object, which is passed into the business tier. In this case the service API continues to accept this object, even if its implementation details change.   
• Alternatively, implement a strategy of overlaying interface types, if a presentation-tier framework, such as the popular Struts project [Struts], is used. o When handling a request, frameworks typically create numerous data structures. For example, typically a framework will transparently complete the step of copying the relevant state from the HttpServletRequest data structure to a more generic data structure, massaging request parameters into a framework-specific data type. While this data type may fulfill the same basic role as a value object, it is a framework-specific data type. Thus, passing this data structure into the business tier introduces coupling between the request-handling framework and the business services. In this case, one could still take the approach just described and copy the framework-specific data structure into a generic structure before passing it to the business tier. Instead, a more efficient solution is to simply create a generic type of interface that mirrors the methods of the framework-specific type. If this interface type is overlaid onto the framework-specific object, then this object can be shared with the business tier without any coupling to the specific framework.   
o For example, if the framework instantiates a subclass of a.framework.StateBean called my.stuff.MyStateBean, it will be of type StateBean:   
o   
o //Note:Instance creation is typically done via a factory   
o //Note:Parameters not shown for simplicity   
o a.framework.StateBean bean $=$ new my.stuff.MyState  
o Bean(...);   
o If the business tier accepted this bean as a parameter, the type would be StateBean:   
o   
o public void aRemoteBizTierMethod(a.framework.StateBean   
o bean)   
o Instead of passing the bean of type StateBean into the business tier, introduce a new Interface called my.stuff.MyStateVO, implemented by my.stuff.MyStateBean:   
o   
o public class MyStateBean extends a.framework.StateBean   
o implements MyStateVO   
o Now the business tier can include the following method signature:   
o   
o public void aRemoteBizTierMethod(my.stuff.MyStateVO   
o bean)   
o There is no need to copy parameters into a more generic value object, and the framework type is no longer exposed across tiers.  

将业务层中所有对表示层数据结构的引用替换为对更通用数据结构和类型的引用。  
- 这些通常是业务层方法接收的参数类型（如`HttpServletRequest`），可替换为更通用的类型参数（如`String`、`int`或`UserInfo`）。需同步修改表示层中调用这些方法的客户端代码。  
- 表示层数据结构的部分内容可作为独立参数传递给业务层方法。例如，若`HttpServletRequest`包含参数x、y和z，业务层方法可不接收`HttpServletRequest`参数，而是分别接收这三个`String`类型参数。  
  - 传递细粒度独立参数的缺点是：该策略会强化表示层细节与业务服务API的耦合。若服务所需状态变更，则服务API必须同步变更。  

- 更灵活的替代方案是将表示层数据结构中的相关状态复制到更通用的数据结构（如值对象）中，再传递至业务层。此时即使实现细节变更，服务API仍可继续接收该对象。  

- 若使用表示层框架（如流行的Struts项目[Struts]），可采用接口类型覆盖策略：  
  - 框架处理请求时通常会创建多个数据结构。例如，框架会透明化地完成从`HttpServletRequest`复制相关状态到通用数据结构的过程，并将请求参数转换为框架特定数据类型。虽然该数据类型与值对象功能相似，但其本质仍是框架特定类型。若将其传入业务层，会导致请求处理框架与业务服务产生耦合。  
  - 此时仍可采用前述方案——在传递至业务层前，将框架特定数据结构复制为通用结构。但更高效的解决方案是：创建一个与框架特定类型方法镜像的通用接口类型。若将该接口类型覆盖到框架特定对象上，则可在不耦合具体框架的情况下与业务层共享此对象。  

示例：  
若框架实例化`a.framework.StateBean`的子类`my.stuff.MyStateBean`，其类型为`StateBean`：  
```java
//注：实例通常通过工厂创建  
//注：为简化省略参数  
a.framework.StateBean bean = new my.stuff.MyStateBean(...);  
```  
若业务层将该Bean作为参数接收，其类型为`StateBean`：  
```java
public void aRemoteBizTierMethod(a.framework.StateBean bean)  
```  
替代方案是引入新接口`my.stuff.MyStateVO`，并由`my.stuff.MyStateBean`实现：  
```java
public class MyStateBean extends a.framework.StateBean  
    implements MyStateVO  
```  
此时业务层方法可定义为：  
```java
public void aRemoteBizTierMethod(my.stuff.MyStateVO bean)  
```  
该方案无需将参数复制到通用值对象中，且框架类型不会跨层暴露。

Finally, on a separate note, remember that you can further reduce the coupling among the logically unrelated parts of the application by applying this refactoring to presentation-tier domain objects, as well. o Visually, we are describing something similar to Figure 5.11.  

最后需要特别说明的是，请记住通过对表示层领域对象同样实施此重构，您可以进一步降低应用程序中逻辑无关部分之间的耦合度。从视觉上看，我们描述的效果类似于**图5.11**所示。

![](images/2b849a6c3722ec7b0708151543338113be66384e2173aa2abf179f4986df3479.jpg)  
Figure 5.11. Hiding presentation tier-specific details from domain objects  

图5.11 对领域对象隐藏表示层特定细节

o The same motivation and mechanics apply to this situation, since we don't want to reduce the reusability of our basic domain objects, such as Customer objects.   
o This localizes all references to protocol-related data structures in and around the request handling components, such as the controller. An example of decoupling the HttpServletRequest from a domain object is shown in Example 5.7 and Example 5.8 in the “Example” section.  

o 同样的动机和机制适用于此场景，因为我们不希望降低基础领域对象（例如 Customer 对象）的可复用性。  
o 这种做法将所有与协议相关的数据结构引用集中在请求处理组件（例如控制器）及其周边。在“示例”章节的示例 5.7 和示例 5.8 中，展示了如何将 HttpServletRequest 从领域对象解耦的范例。

# Example  

The Customer class in Example 5.7 accepts an HttpServletRequest instance as a parameter, which greatly reduces the generic nature of this domain object. If a non-web client wanted to use this Customer class, it would somehow need to first generate an HttpServletRequest object, which is inappropriate.  

示例5.7中的`Customer`类接收`HttpServletRequest`实例作为参数，这极大削弱了该领域对象的通用性。若需供非Web客户端使用，则需强制生成`HttpServletRequest`对象，这种设计显然不合理。

# Example 5.7 Tight Coupling between a Domain Object and HttpServletRequest object  

/\*\* The following excerpt shows a domain object that is too tightly coupled with HttpServletRequest \*\*/   
public class Customer   
{ public Customer ( HttpServletRequest request ) { firstName $=$ request.getParameter("firstname"); lastName $=$ request.getParameter("lastname ");   
}  

/** 以下代码片段展示了一个与HttpServletRequest过度耦合的领域对象 */  
public class Customer  
{ public Customer ( HttpServletRequest request ) { firstName $=$ request.getParameter("firstname"); lastName $=$ request.getParameter("lastname ");   
}

Instead of exposing the HttpServletRequest object to a general Customer object, simply decouple the two, as shown in Example 5.8 :  

无需将 `HttpServletRequest` 对象直接暴露给通用的 `Customer` 对象，只需将两者解耦即可，如示例 5.8 所示：

# Example 5.8 Reduced Coupling between a Domain Object and HttpServletRequest object  

// Domain Object not coupled with HttpServletReques   
public class Customer public Customer ( String first, String last ) { firstName $=$ first; lastName $=$ last;  

// 领域对象不与HttpServletRequest耦合  
public class Customer public Customer ( String first, String last ) { firstName $=$ first; lastName $=$ last;

# Remove Conversions from View  

Portions of the model are converted for display within a view component. Extract all conversion code from view and encapsulate it in one or more helper classes.  

模型的部分内容会被转换为视图组件内的显示形式。将所有转换代码从视图中提取出来，并将其封装到一个或多个辅助类中。

![](images/a84475f4580745a0ef20796a683ccfcc9c035b85eaca3f034fc1c825d1c0faa3.jpg)  
Figure 5.12. Remove conversions from view  

图 5.12 从视图中移除转换

# Motivation  

Directly embedding logic that converts the model for display in the JSP view reduces the application's modularity and reusability. Since such conversions might occur in  

直接在JSP视图中嵌入用于模型转换的显示逻辑会降低应用的模块化和可复用性。由于此类转换可能发生在

multiple JSPs, the code would need to be duplicated, creating a copy-and-paste type of reuse that is a maintenance headache.  

多个JSP页面中，代码将不得不重复出现，形成一种复制粘贴式的复用，这会带来维护上的噩梦。

# Mechanics  

Apply Extract Class [Fowler] to move the converting and adapting logic from   
individual JSPs into helper classes. o An example is adapting a database result set into an HTML table via some application code.   
Invoke these helpers from the JSPs to process the conversions and   
adaptations as desired. o The conversion is performed by the helper class to which the JSP delegates.  

应用**提取类**[Fowler]模式，将转换与适配逻辑从各个JSP移至辅助类中。  
例如通过应用程序代码将数据库结果集适配为HTML表格。  
从JSP调用这些辅助类以按需执行转换与适配操作。  
具体转换由JSP所委托的辅助类完成。  

（注：严格遵循技术术语不翻译原则，保留JSP/Fowler等专有名词，采用"辅助类"对应"helper classes"，"委托"对应"delegates"等标准译法）

# Example  

In this example, we examine logic that converts a collection of items, such as a result set, into an HTML table. While this is indeed formatting logic in one sense, it is also conversion code, generating a table of results from an intermediate model. The implementation of this dynamic conversion is reusable if it is encapsulated in a custom tag instead of being embedded directly within a JSP.  

本例探讨了将一组条目（例如结果集）转换为HTML表格的逻辑。虽然从某种角度看这确实是格式化逻辑，但它同时也是转换代码——通过中间模型生成结果表格。若将此动态转换逻辑封装在自定义标签而非直接嵌入JSP中，其实现便可复用。

Example 5.9 is an example of a JSP that includes this type of conversion logic embedded directly in its source.  

示例5.9展示了一个JSP实例，该页面直接将此类转换逻辑内嵌在其源代码中。

# Example 5.9 Conversion Logic Embedded Within View  

<html>   
<head><title>Employee List</title></head>   
<body>   
<h3><head><center> List of employees</h3>   
<% String firstName $=$ (String)request.getParameter("firstName"); String lastName $=$ (String)request.getParameter("lastName"); if ( firstName $==$ null ) // if none specific, fetch all firstName $=$ ""; if ( lastName $==$ null ) lastName $=$ "";  

<html>  
<head><title>员工列表</title></head>  
<body>  
<h3><head><center>员工名单</h3>  
<% String firstName $=$ (String)request.getParameter("firstName"); String lastName $=$ (String)request.getParameter("lastName"); if ( firstName $==$ null ) // 若未指定则获取全部  
firstName $=$ ""; if ( lastName $==$ null ) lastName $=$ "";

EmployeeDelegate empDelegate $=$ new EmployeeDelegate(); Iterator employees $=$ empDelegate.getEmployees( EmployeeDelegate.ALL_DEPARTMENTS); %> <table border $=$ "1" <tr> <th> First Name </th> <th> Last Name </th> <th> Designation </th> </tr> <% while ( employees.hasNext() ) { EmployeeVO employee $=$ (EmployeeVO) employees.next(); if ( employee.getFirstName(). startsWith(firstName) && employee.getLastName(). startsWith(lastName) ) %> <tr> <td><% $=$ employee.getFirstName().toUpperCase() %></td> <td> <% $=$ employee.getLastName().toUpperCase() %></td> <td> <% $=$ employee.getDesignation()%></td> </tr> <% %> </table>  

EmployeeDelegate empDelegate = new EmployeeDelegate();  
Iterator employees = empDelegate.getEmployees(EmployeeDelegate.ALL_DEPARTMENTS); %>  
<table border="1">  
<tr>  
<th>名</th>  
<th>姓</th>  
<th>职位</th>  
</tr>  
<% while (employees.hasNext()) {  
EmployeeVO employee = (EmployeeVO) employees.next();  
if (employee.getFirstName().startsWith(firstName) && employee.getLastName().startsWith(lastName)) %>  
<tr>  
<td><%= employee.getFirstName().toUpperCase() %></td>  
<td><%= employee.getLastName().toUpperCase() %></td>  
<td><%= employee.getDesignation() %></td>  
</tr>  
<% } %>  
</table>

The first step is to extract this logic into helper classes. Custom tag helpers make the most sense in this case, since we want to remove as much scriptlet code from the JSP as possible (see See “Note on Helpers:” .). The JSP is then modified to delegate to these helpers to complete the processing. Example 5.10 shows how the JSP might look after these steps.  

第一步是将该逻辑提取到辅助类中。这种情况下**自定义标签助手**最为适用，因为我们需要尽可能移除JSP中的脚本代码（参见“**关于助手的说明**”）。随后修改JSP，将这些处理逻辑委托给助手类完成。示例5.10展示了完成这些步骤后JSP的可能形态。

# Example 5.10 Logic Extracted into Helper Classes  

<html>   
<head><title>Employee List - Refactored </title>   
</head>   
<body>   
<h3> <center>List of employees</h3>   
<corepatterns:employeeAdapter />   
<table border $=$ "1" <tr> <th> First Name </th> <th> Last Name </th> <th> Designation </th> </tr>   
<corepatterns:employeelist id $\equiv$ "employeelist" match $\equiv$ "FirstName, LastName">   
<tr> <td><corepatterns:employee attribute $=$ "FirstName" case $=$ "Upper" /> </td> <td><corepatterns:employee attribute $=$ "LastName" case $=$ "Upper" /></td> <td><corepatterns:employee attribute $=$ "Designation" /> </td> <td> </tr>   
</corepatterns:employeelist>   
</table>  

<html>   
<head><title>员工列表 - 重构版</title>   
</head>   
<body>   
<h3> <center>员工名单</h3>   
<corepatterns:employeeAdapter />   
<table border $=$ "1" <tr> <th> 名 </th> <th> 姓 </th> <th> 职位 </th> </tr>   
<corepatterns:employeelist id $\equiv$ "employeelist" match $\equiv$ "FirstName, LastName">   
<tr> <td><corepatterns:employee attribute $=$ "FirstName" case $=$ "Upper" /> </td> <td><corepatterns:employee attribute $=$ "LastName" case $=$ "Upper" /></td> <td><corepatterns:employee attribute $=$ "Designation" /> </td> <td> </tr>   
</corepatterns:employeelist>   
</table>

Now let us examine another type of conversion. In some cases, portions of the model are converted to HTML via XSL transformations. This can also be accomplished using custom tag helpers. Once again, this allows us to extract the logic from the JSP itself, providing us with more modular and reusable components. Here is an example of a JSP that uses custom tag helpers to perform its conversions, instead of performing such conversions inline:  

现在让我们研究另一种转换类型。在某些情况下，模型部分会通过XSL转换生成HTML。这也可以通过自定义标签助手实现。这种方式再次让我们能够将逻辑从JSP中抽离，从而提供更具模块化和可复用性的组件。以下是一个使用自定义标签助手执行转换的JSP示例（而非在代码中直接进行转换）：

The Jakarta taglibs [JakartaTaglibs] XSL apply tag is used to generate the entire output of this page. It could be used to simply generate component pieces of the page in the same manner. The tag invocation relies on the fact that a bean exists in a page scope called “model,” with a property named $\"{\times}\mathsf{m}$ .” In other words, there is an instance of a bean in a page scope that has a method with the following signature:  

Jakarta标签库[JakartaTaglibs]中的XSL apply标签用于生成本页面的完整输出。该标签同样可用于以相同方式生成页面的局部组件。标签调用的前提是页面作用域中存在一个名为"model"的Bean，且该Bean具有名为"$\"{\times}\mathsf{m}$"的属性。换言之，页面作用域中存在一个Bean实例，该实例包含以下签名的方法：

# public String getXml()  

It is worth noting that these types of conversions can be performed entirely independent of JSP. Depending on numerous factors, such as the storage format of the content and existence of various legacy technologies, one might choose this route.  

值得注意的是，这类转换可以完全独立于JSP执行。根据内容存储格式和遗留技术存在等诸多因素，开发者可能会选择此方案。

# Hide Resource From a Client  

Certain resources, such as JSP views, should not be directly accessible to a client browser.  

某些资源（例如JSP视图）不应被客户端浏览器直接访问。

Hide certain resources via container configuration or by using a control component.  

通过容器配置或使用控制组件来隐藏特定资源。

![](images/b04f6466b78e4007cbbca822754407af146363b1fb3223551c1ab9ea07a075f8.jpg)  
Figure 5.13. Restricted via container configuration  

图 5.13. 通过容器配置实现访问限制

# Motivation  

Control of an incoming request is often desired. This refactoring describes permission-based control and protection.  

对传入请求的控制通常是必要的。本次重构描述了基于权限的控制与保护机制。

If the order or flow of the client requests must be controlled, then apply Introduce Synchronizer Token (see “Introduce Synchronizer Token” ).  

若需控制客户端请求的顺序或流程，则应用**引入同步令牌**（参见“引入同步令牌”）。

# Mechanics  

Restrict access to certain resources (such as Web resources, servlets, among others) via configuration, by moving these resources into a subdirectory of the /WEB-INF/ subdirectory of the Web application. o For example, to block direct browser access to a view called info.jsp, in the securityissues Web application, we could place the JSP source file in the following subdirectory: /securityissues/WEB-INF/internalaccessonly/ info.jsp. Restrict access using a control component. Introduce a controller (see “Introduce a Controller” ) may be applied and the controller can manage access to protected resources. o Additionally, each resource to be protected can manage its own access control, meaning it would delegate to a helper class to perform this processing. • Create one or more helper classes. o Depending on the implementation, either the controller or each JSP itself delegates to these helper classes to check whether the resource should be served.  

通过配置将特定资源（如Web资源、Servlet等）移至Web应用程序的`/WEB-INF/`子目录下以限制访问。例如，若要阻止浏览器直接访问`securityissues` Web应用中的`info.jsp`视图，可将该JSP源文件置于以下子目录：`/securityissues/WEB-INF/internalaccessonly/info.jsp`。  

采用控制组件限制访问。可应用**引入控制器**模式（参见“引入控制器”章节），由控制器管理对受保护资源的访问。  
○ 此外，每个需保护的资源可自行管理访问控制，即委托辅助类执行此处理逻辑。  

• 创建一个或多个辅助类  
○ 根据具体实现，控制器或各JSP自身会委托这些辅助类来校验资源是否应被返回。

# Example  

# Restricted by Container Configuration  

We can make a JSP called info.jsp inaccessible to our client, except via a controller, by moving the JSP under the /WEB-INF/ directory.  

我们可以通过将JSP文件移至`/WEB-INF/`目录下，使得名为`info.jsp`的页面无法被客户端直接访问，而必须通过控制器才能调用。

If we have a Web application called corepatterns, then we might start with the following configuration under our server root directory:  

如果我们有一个名为 `corepatterns` 的 Web 应用程序，那么可以在服务器根目录下采用如下初始配置：

By default, this allows direct client access to this resource, as shown in the following URL:  

默认情况下，这将允许客户端直接访问该资源，如下列URL所示：

http://localhost:8080/corepatterns/secure_page.jsp  

http://localhost:8080/corepatterns/secure_page.jsp

To restrict direct access, we can simply move the JSP file to a subdirectory of the /WEB-INF/ directory, giving us the following under our server root:  

要限制直接访问，我们只需将JSP文件移至`/WEB-INF/`目录的子目录下，最终在服务器根目录下形成如下结构：

/corepatterns/WEB-INF/privateaccess/secure_page.jsp  

/corepatterns/WEB-INF/privateaccess/secure_page.jsp

The /WEB-INF/ directory hierarchy is accessible only indirectly via internal requests, such as those coming through a controller and a RequestDispatcher. Thus, a browser client can only access this file now using a URL similar to the following:  

/WEB-INF/ 目录层次结构只能通过内部请求间接访问，例如通过控制器和 RequestDispatcher 转发的请求。因此，浏览器客户端现在只能通过类似以下形式的 URL 访问该文件：

http://localhost:8080/corepatterns/controller?view $=$ /corepatterns/WEB-INF/priva teaccess/secure_page.jsp  

http://localhost:8080/corepatterns/controller?view=$/corepatterns/WEB-INF/priva teaccess/secure_page.jsp

Note:The above URL is for example purposes only and is not a recommended way to pass path information to the server. The view query parameter should not expose the server's directory structure. It does so in this example only to clarify the example's intent.  

注意：上述URL仅作示例用途，并非向服务器传递路径信息的推荐方式。视图查询参数不应暴露服务器的目录结构。本例中如此操作仅为阐明示例意图。

If this request is handled by a servlet controller, then it can forward the request to secure_page.jsp, using the RequestDispatcher.  

如果该请求由Servlet控制器处理，则可通过RequestDispatcher将其转发至secure_page.jsp。

On the other hand, if an attempt is made to access the resource directly, as follows, http://localhost:8080/corepatterns/WEB-INF/privateaccess/secure_page.jsp the server responds that the requested resource is not available, as shown in Figure 5.15.  

另一方面，如果尝试直接访问资源（如下所示）http://localhost:8080/corepatterns/WEB-INF/privateaccess/secure_page.jsp，服务器会返回如图5.15所示的提示：请求的资源不可用。

# Figure 5.15. Screen shot: Restricting direct browser access via simple file configuration  

![](images/cc01f6abd18033c1ed2f5c8ca9da6f2e574bf53c0ec8a247ceb406c06cbc1f86.jpg)  

# Restricted by Using a Control Component  

Another option for restricting access is to delegate to a control component, as shown in Figure 5.14 and Example 5.11.  

另一种限制访问的方式是将权限委托给控制组件，如图5.14和示例5.11所示。

![](images/3a86876856c5a26dc6ddc937090626c5ba441ae0e70a50e854d9b26b02e0841f.jpg)  
Figure 5.14. Restricted by using a control component  

图5.14 受控组件使用限制

# Example 5.11 Controlling Access Using a Control Component  

<%@ taglib uri $=$ "/WEB-INF/corepatternstaglibrary.tld" prefix $\equiv$ "corepatterns" %>   
<corepatterns:guard/>   
<html>   
<head><title>Hide Resource from Client</title></head>   
<body>   
<h2>This view is shown to the client only if the   
control component allows access. The view delegates   
the control check to the guard tag at the top of the   
page.</h2>   
</body>   
</html>  

<%@ taglib uri $=$ "/WEB-INF/corepatternstaglibrary.tld" prefix $\equiv$ "corepatterns" %>  
<corepatterns:guard/>  
<html>  
<head><title>对客户端隐藏资源</title></head>  
<body>  
<h2>该视图仅在控制组件允许访问时向客户端显示。视图将权限检查委托给页面顶部的guard标签处理。</h2>  
</body>  
</html>

# Business and Integration Tier Refactorings  

# Wrap Entities With Session  

Entity beans from the business tier are exposed to clients in another tier.   
Use a Session Facade to encapsulate the entity beans.  

业务层的实体Bean会暴露给其他层的客户端。  
应使用会话门面模式对实体Bean进行封装。

![](images/0fcb60cda6d97068d0f738bc458dfa802ce3fb30e5ebd089d691dc677729c50c.jpg)  
Figure 5.16. Wrap Entities With Session  

图 5.16 使用会话包装实体

# Motivation  

Entity beans are coarse-grained distributed persistent objects. Exposing the entity bean to clients in a different tier results in network overhead and performance degradation. Each client invocation on the entity bean is a remote network method call, which is expensive.  

实体Bean属于粗粒度的分布式持久化对象。将其暴露给不同层级的客户端会导致网络开销与性能下降。每次对实体Bean的客户端调用都是代价高昂的远程网络方法调用。

Entity beans mandate container-managed transaction. Exposing the entity bean to the clients may put the burden on the client developer to understand, design, and demarcate transactions when dealing with multiple entity beans. The client developer has to obtain a user transaction from the transaction manager and code the interaction with entity beans to occur within the context of that transaction. Since the client implements the transaction management, it is not possible to use the benefits of container-managed transaction demarcation.  

实体Bean强制要求采用容器管理事务。将实体Bean直接暴露给客户端时，客户端开发者需要承担理解、设计和划分事务的责任，尤其是在处理多个实体Bean的情况下。开发者必须从事务管理器获取用户事务，并编写与实体Bean交互的代码以确保操作在该事务上下文中执行。由于事务管理由客户端实现，因此无法利用容器管理事务划分的优势。

# Mechanics  

Move the business logic to interact with the entity beans out of the application client. o Use Extract Class [Fowler] to extract the logic from the client. Use a session bean as a facade to the entity beans. o This session bean can contain the entity bean interaction logic and associated workflow logic. o See “Session Facade” for details. Implement session beans to provide a consolidated uniform access layer to the entity beans by applying the Session facade pattern. o The number of interactions between the client and the entity beans is now moved into the Session facade in the business tier. o Thus, the number of remote method invocations from the client is reduced. Implement transaction logic in session beans if using bean-managed transactions. For container-managed transactions, specify the transaction attributes for the session bean in the deployment descriptor. o Since the session bean interacts with the entity beans, the client is no longer responsible for demarcating transactions. o Thus, all transaction demarcation is now delegated to either the session bean or the container, depending on whether the designer has chosen user-managed or container-managed transactions.  

将业务逻辑从应用客户端中剥离，改为与实体Bean交互。  
- 运用[Fowler]的**提取类**方法将逻辑从客户端抽离  
- 使用会话Bean作为实体Bean的门面  
  - 该会话Bean可包含实体Bean交互逻辑及相关工作流逻辑  
  - 详见**会话门面**模式说明  

通过应用**会话门面**模式实现会话Bean，为实体Bean提供统一的整合访问层：  
- 客户端与实体Bean之间的交互调用被转移至业务层的会话门面中  
- 从而减少客户端的远程方法调用次数  

若采用Bean管理事务，则在会话Bean中实现事务逻辑；若采用容器管理事务，则需在部署描述符中指定会话Bean的事务属性：  
- 由于会话Bean负责与实体Bean交互，客户端不再承担事务边界划分职责  
- 根据设计者选择用户管理事务或容器管理事务，所有事务边界划分工作现均委托给会话Bean或容器处理

# Introduce Business Delegate  

Session beans in the business tier are exposed to clients in other tiers.  

业务层中的会话Bean（Session Bean）会向其他层中的客户端公开。

Use a business delegate to decouple the tiers and to hide the implementation details.  

使用业务委托模式解耦各层并隐藏实现细节。

# Figure 5.17. Introduce Business Delegate  

![](images/ad89b93d8a4171c463777b85d4b44eac0bb795761e959f3dfc4fd73677246448.jpg)  

# Motivation  

Session beans are used to implement facades for entity beans, as discussed in “Wrap Entities With Session” . Session beans provide coarse-grained interfaces to business services. But, exposing the session bean directly to the application client creates a tight coupling between the application client code and the session bean.  

如“用会话封装实体”章节所述，会话Bean用于为实体Bean实现门面模式。会话Bean为业务服务提供粗粒度接口。但直接将会话Bean暴露给应用客户端会导致应用客户端代码与会话Bean之间产生紧耦合。

Exposing the session bean to the application client increases the prevalence of session bean calls throughout the client code. Thus, any change to the session bean interface impacts every point in the application client code where the session bean is called, and thus creates highly brittle code. The clients also are exposed to service level exceptions encountered when dealing with enterprise beans. This effect is further exaggerated if you consider applications with different types of clients, where each such client uses the session bean interface to obtain some service.  

将会话 Bean 直接暴露给应用客户端会导致会话 Bean 调用在客户端代码中过度扩散。因此，对会话 Bean 接口的任何修改都会影响到应用客户端代码中所有调用该 Bean 的位置，从而产生高度脆弱的代码。客户端还会直接遭遇处理企业 Bean 时产生的服务级异常。如果考虑到具有不同类型客户端的应用程序（其中每个客户端都通过会话 Bean 接口获取服务），这种影响会被进一步放大。

# Mechanics  

For each session bean that is directly exposed to clients across the tier,   
introduce a business delegate. o Business delegates are plain Java classes that encapsulate the business tier details and intercept service level exceptions on behalf of the client. o See “Business Delegate”.   
Implement each Business Delegate to deal with its session bean, typically as   
a facade. A business delegate is designed with a one-to-one relationship with   
its session facade.   
o Business delegates reduce the coupling between the client tier and the business services (session beans) by hiding the implementation details.   
o The clients deal with the business delegates by invoking methods on them locally.  

对于每个直接跨层暴露给客户端的会话Bean，  
引入业务委托类。业务委托类是纯Java类，封装业务层细节并代表客户端拦截服务级异常。详见“业务委托模式”。  

每个业务委托类应作为其会话Bean的外观（Facade）进行实现。业务委托类与会话外观保持一对一关系设计。  

- 业务委托类通过隐藏实现细节，降低客户端层与业务服务（会话Bean）之间的耦合度  
- 客户端通过本地方法调用的方式与业务委托类交互

Encapsulate code related to lookup services and caching in business delegates.  

将查找服务和缓存相关的代码封装在业务委托类中。

o Business delegates can use a service locator to look up business services.   
o See “Service Loctor”  

o 业务委托可通过服务定位器查找业务服务  
o 参见“服务定位器模式”

# Merge Session Beans  

Create a one-to-one mapping between session bean and entity bean.  

在会话Bean与实体Bean之间建立一对一映射关系。

Map coarse-grained business services to session beans. Eliminate or combine session beans that act solely as entity bean proxies into session beans that represent coarse-grained business services.  

将粗粒度业务服务映射至会话Bean。移除或整合仅作为实体Bean代理的会话Bean，将其转化为代表粗粒度业务服务的会话Bean。

# Motivation  

A one-to-one mapping of a session bean to an entity bean does not yield any benefits. Such mapping only introduces a layer of session beans acting as proxies. Typically this happens when developers create session beans to front entity beans, rather than to represent coarse-grained services.  

会话Bean与实体Bean的一对一映射不会带来任何收益。这种映射只会引入一层充当代理的会话Bean。通常发生在开发者创建会话Bean作为实体Bean的前端，而非用于表示粗粒度服务时。

Some designers interpret “Wrap Entities With Session” to mean that every entity bean should be protected by its own session bean. This is not a correct interpretation, since it results in design of session beans as proxies rather than as facades. The drawbacks of exposing the entity beans to clients is discussed in “Wrap Entities With Session”.  

部分设计者将"用会话封装实体"误解为每个实体Bean都应配备专属会话Bean保护。这种理解存在偏差，会导致会话Bean被设计成代理而非门面模式。"用会话封装实体"章节已详细探讨了直接向客户端暴露实体Bean的缺陷。

In Figure 5.18, different clients are servicing different interactions. Each interaction involves one or more entity beans. With a one-to-one mapping of a session bean to an entity bean, the client has to interact with each session bean fronting an entity bean. Since the session bean is essentially a proxy to the entity, this scenario is similar to exposing the entity bean directly to the client.  

在图5.18中，不同客户端正处理不同的交互操作。每个交互涉及一个或多个实体Bean。若采用会话Bean与实体Bean的一对一映射方式，客户端必须通过每个实体Bean对应的会话Bean进行交互。由于会话Bean本质上是实体Bean的代理，这种场景与直接将实体Bean暴露给客户端类似。

![](images/59162154ddfe68c644302f7ed86e87c32075ff93270d14595460c8f3dbd574b2.jpg)  
Figure 5.18. Merge Session Beans  

图 5.18. 合并会话Bean

# Mechanics  

Implement session beans as facades to entity beans. Thus, each session bean provides a coarse-grained business service interface to the clients.  

将会话Bean实现为实体Bean的门面。这样，每个会话Bean为客户端提供一个粗粒度的业务服务接口。

• Consolidate fine-grained session beans or a set of session beans that are proxies to entity beans into a single session bean.  

• 将细粒度的会话Bean或作为实体Bean代理的一组会话Bean整合为单个会话Bean。

o Session beans represent coarse-grained business service.   
o Entity beans represent coarse-grained, transactional persistent data.   
o See “Session Facade” .  

- **会话Bean**表示粗粒度的业务服务  
- **实体Bean**表示粗粒度的、支持事务的持久化数据  
- 参见**“会话门面”模式**

Consolidate a set of related interactions that involve one or more entity beans into a single session facade instead of implementing each interaction using a unique session bean.  

将涉及一个或多个实体Bean的相关交互操作整合到单个会话门面中，而非为每个交互使用独立的会话Bean实现。

o This results in a fewer number of session beans that provide a uniform coarse-grained business service access to entity beans.   
o The number of Session facades is related to the grouping of interactions and not to the number of entity beans.  

o 这导致提供统一粗粒度业务服务访问实体Bean的会话Bean数量减少。  
o 会话门面的数量与交互分组相关，而非实体Bean的数量。

# Eliminate Inter-Entity Bean Communication  

Inter-entity bean relationships introduce overhead in the model.  

实体Bean间的关联关系会在模型中引入额外开销。

Reduce or eliminate the inter-entity bean relationships by using coarse-grained entity bean (Composite Entity) with dependent objects.  

通过使用包含依赖对象的粗粒度实体Bean（组合实体），减少或消除实体Bean间的关联关系。

# Figure 5.19. Eliminate Inter-Entity Bean Communication  

![](images/af5cd36719d94845803782a3610bf6e21d6143d26f2265e377738c6a823c042e.jpg)  

# Motivation  

Entity beans have significantly more overhead than plain Java objects. Calls to entity bean methods are remote and incur network overhead. Also, entity beans must interact with an external data source.  

实体Bean比普通Java对象具有显著更高的开销。对实体Bean方法的调用是远程的，会产生网络开销。此外，实体Bean必须与外部数据源进行交互。

Even if two entity beans are in the same container, remote method invocation semantics apply (the container is involved in the communication) when one entity bean calls the other bean. Some container implementations may optimize such calls, because they recognize that the call comes from an object within the same container, but this is vendor-specific and cannot be relied upon.  

即使两个实体Bean位于同一容器中，当一个实体Bean调用另一个Bean时，仍适用远程方法调用语义（容器会介入通信过程）。某些容器实现可能会优化此类调用，因为它们能识别调用源自同一容器内的对象，但这属于供应商特定行为，不可依赖。

Another issue is the inability for the entity bean to demarcate a transaction. When using entity beans, you are only allowed to have container-managed transactions. This means that, depending on the transaction attribute of the entity bean method, the container may start a new transaction, participate in the current transaction, or do neither. When a client invokes a method on an entity bean, the transaction includes the chain of dependent entity beans and binds them into the transaction's context. This reduces the performance throughput of the entity beans as a whole, because any transaction may lock multiple entity beans and possibly introduce deadlock situations.  

另一个问题是实体Bean无法自行划分事务边界。使用实体Bean时，只能采用容器管理的事务机制。这意味着根据实体Bean方法的事务属性，容器可能启动新事务、加入当前事务或不参与事务。当客户端调用实体Bean方法时，事务会涵盖所有关联的实体Bean链，并将其绑定到事务上下文中。这会整体降低实体Bean的性能吞吐量，因为任何事务都可能锁定多个实体Bean，甚至可能引发死锁情况。

# Mechanics  

Design and implement entity beans as coarse-grained objects with root and dependent objects.  

将实体Bean设计并实现为包含根对象与依赖对象的粗粒度对象。

o Transform an entity-bean-to-entity-bean relationship into an entity-bean-to-dependent-object relationship.   
o Dependent objects are not entity beans. Rather, they are objects contained within an entity bean. A relationship between an entity bean and its dependent objects is a local relationship with no network overhead.   
o Optimize load and store operations for Composite Entity using the Lazy Loading Strategy and Store Optimization (Dirty Marker) Strategy respectively.   
o See “Composite Entity” .  

将实体Bean到实体Bean的关系转换为实体Bean到依赖对象的关系。  
依赖对象并非实体Bean，而是包含在实体Bean内部的对象。实体Bean与其依赖对象之间的关系属于本地关系，不存在网络开销。  
分别通过**延迟加载策略**和**存储优化（脏标记）策略**来优化组合实体的加载与存储操作。  
参见《组合实体》章节。

Extract and move business logic related to working with other entities from the entity bean into a session bean.  

将实体Bean中与其他实体交互相关的业务逻辑抽取并迁移至会话Bean。

o Use Extract Method [Fowler] and/or Move Method [Fowler] to move such business logic into a session bean, applying the Session facade pattern.   
o See “Session Facade” .  

o 运用**提炼方法**[Fowler]和/或**搬移方法**[Fowler]将此类业务逻辑移至会话Bean，应用会话门面模式。  
o 参见“会话门面”章节。

# Move Business Logic to Session  

Inter-entity bean relationships introduce overhead in the model.  

实体Bean间的关联关系会在模型中引入额外开销。

Encapsulate the workflow related to inter-entity bean relationships in a session bean (Session Facade).  

将会话Bean（会话门面）中与实体Bean间关系相关的工作流进行封装。

![](images/322c3878f8a94cb5b8ec388fba135433568389e8def2bd85cab600e8417f2f6c.jpg)  
Figure 5.20. Move Business Logic to Session  

图5.20 将业务逻辑迁移至会话层

# Motivation  

In “Eliminate Inter-Entity Bean Communication” , we discussed the problems associated with direct inter-entity-bean dependencies. The problem is that an entity may contain business logic that deals with other entity beans. This creates a direct or indirect dependency on another entity bean. The same problems discussed in Eliminate Inter-Entity Bean Communication apply to this scenario too.  

在《消除实体Bean间通信》一文中，我们探讨了直接实体Bean间依赖关系带来的问题。其核心在于，某个实体可能包含涉及其他实体Bean的业务逻辑，从而形成对其他实体Bean的直接或间接依赖。前文所述的所有问题在此场景中同样适用。

# Mechanics  

Extract and move business logic related to working with other entities from   
the entity bean into a session bean. o Use Extract Method [Fowler] and/or Move Method [Fowler] to move such business logic into a session bean applying the Session facade pattern. o See “Session Facade” . o See “Wrap Entities With Session” .  

将实体Bean中与其他实体交互相关的业务逻辑抽取并迁移至会话Bean。  
- 运用**提取方法**[Fowler]和/或**搬移方法**[Fowler]重构手法，将此类业务逻辑移至采用会话门面模式的会话Bean中。  
- 参见**“会话门面”**模式。  
- 参见**“用会话封装实体”**实践。

# General Refactorings  

# Separate Data Access Code  

Data access code is embedded directly within a class that has other unrelated responsibilities.  

数据访问代码被直接嵌入到承担其他无关职责的类中。

Extract the data access code into a new class and move the new class logically and/or physically closer to the Data Source.  

将数据访问代码提取到新类中，并将新类在逻辑和/或物理上更靠近数据源放置。

# Figure 5.21. Separate Data Access Code  

![](images/fd3ce9125963193d45b25be68a43e8ca732adbb77b3ba23227ab45af05539f2d.jpg)  

# Motivation  

Create cleaner abstractions, increase cohesion, and reduce coupling, thus improving modularity and reusability.  

创建更清晰的抽象，提高内聚性并降低耦合度，从而提升模块化与可复用性。

# Mechanics  

Identify and extract the data access logic from the controller object. o Use Extract Class [Fowler] to create a new class and move data access code from the original class into the new Data Access Object (DAO) class. o Consider including the DAO as part of the name of the new class in order to flag its role as a Data Access Object. o See “Data Access Object” .  

识别并提取控制器对象中的数据访问逻辑。  
o 运用[Fowler]的提取类重构方法创建新类，将数据访问代码从原类移至新建的**数据访问对象**（DAO）类中  
o 建议在新类名中加入"DAO"标识以明确其数据访问对象职责  
o 参见《数据访问对象》模式说明  

（注：严格遵循技术术语一致性，保留"DAO"、"Fowler"等专有名词不翻译，采用中文技术社区通用译法）

Use the new DAO from the controller to access data. For related information on application partitioning, see “Refactor Architecture by Tiers” .  

在控制器中使用新的DAO访问数据。有关应用分层的更多信息，请参阅《按层级重构架构》。

# Example  

Consider an example where a servlet has embedded data access code to access some user information. Applying the first two bullets, assume we change the design, as shown in Figure 5.22.  

假设某个Servlet中嵌入了用于访问用户信息的数据访问代码。应用前两条原则修改设计后，结果如图5.22所示。

![](images/f276a5dbd324308cda9ca89527786c3627dde237434ff5be7ab0e90d68bf76f8.jpg)  
Figure 5.22. Separate Data Access Code – Servlet example  

图 5.22 数据访问代码分离——Servlet示例

We now have two classes: one for the servlet, which acts as a controller, and the other a new object called “UserDAO,” which acts as a data access object to access user information. The UserDAO encapsulates all Java Database Connectivity (JDBC) code and decouples the servlet from the implementation details. The servlet code is much simpler as a result.  

现在我们有两个类：一个是作为控制器的Servlet，另一个是名为“UserDAO”的新对象，它作为数据访问对象来操作用户信息。UserDAO封装了所有Java数据库连接（JDBC）代码，并将Servlet与实现细节解耦。因此，Servlet代码变得更为简洁。

Consider another example where the persistence logic is embedded in an enterprise bean using bean-managed persistence. Combining the persistence code with the enterprise bean code creates brittle, tightly coupled code. When the persistence  

再看一个例子：某企业级Bean采用Bean托管持久化方式，将持久化逻辑内嵌其中。这种将持久化代码与企业级Bean代码混写的做法会导致代码脆弱且高度耦合。当持久化...

code is part of the enterprise bean, any change to the persistence store requires changing the bean's persistence code. Such coupling has a negative impact on enterprise bean code maintenance. This is another example of how this refactoring can help.  

该代码是企业级Bean的组成部分，对持久化存储的任何修改都需要变更Bean的持久化代码。这种耦合关系会对企业级Bean的代码维护产生负面影响。这再次体现了本次重构的价值所在。

Applying this refactoring, we change the design as shown in Figure 5.23.  

应用此重构后，我们按图5.23所示修改了设计方案。

![](images/14ad79cc55895003639ebba797f8ddc92182d9610f87a382189316cf91e234a5.jpg)  
Figure 5.23. Separate Data Access Code – Enterprise bean example  

图5.23 分离数据访问代码——Enterprise Bean示例

# Refactor Architecture by Tiers  

Increasing architectural sophistication requires changing the localization of data access logic and processing logic.  

随着架构复杂度的提升，需要改变数据访问逻辑与处理逻辑的定位关系。

Move Data Access code logically and/or physically closer to the actual Data Source.   
Move processing logic out of the client and presentation tiers into the business tier.  

将数据访问代码在逻辑和/或物理上移至更接近实际数据源的位置。  
将处理逻辑从客户端层和表示层移至业务层。

# Figure 5.24. Refactor Architecture by Tiers  

![](images/a210f3704072ae789e6fc90e3660ad80bfabfae64c4a3ce28b0778acf703a225.jpg)  

# Motivation  

“Separate Data Access Code” demonstrates refactoring data access logic, while this refactoring discusses other types of business logic in an application.  

“分离数据访问代码”展示了重构数据访问逻辑的过程，而本次重构则讨论应用程序中其他类型的业务逻辑。

The J2EE platform offers clear separation of concerns into the roles of servlets, JSPs, and EJB components to provide maximum benefits in terms of scalability, flexibility, transactions, security, and so forth.  

J2EE平台通过将关注点明确分离到Servlet、JSP和EJB组件的角色中，从而在可扩展性、灵活性、事务和安全性等方面提供最大化的优势。

As business requirements become more sophisticated, the design needs to better address issues related to persistence, transactions, security, and scalability of business services. At some point in this increasing complexity, session beans and entity beans are introduced to provide centralized business processing for all clients and to leverage the benefits of the EJB container.  

随着业务需求日益复杂，设计需要更好地解决与业务服务的持久化、事务、安全性和可扩展性相关的问题。在这种不断增长的复杂性中，会话Bean和实体Bean被引入，旨在为所有客户端提供集中化的业务处理，并充分发挥EJB容器的优势。

Some designers use heavyweight components like enterprise beans without ensuring that the application requirements warrant their use. Some sophisticated application requirements that influence this decision are transactions, security, scalability, and distributed processing.  

部分设计者在未确认应用需求是否合理的情况下，就贸然采用企业级Bean等重量级组件。影响该决策的关键应用需求包括**事务**处理、**安全**性、**可扩展性**以及**分布式**处理能力。

# Mechanics  

Separate data access code from control and entity objects into data access objects. o See “Separate Data Access Code”. Separate presentation and business processing. Introduce session beans for business processing. Retain presentation processing in servlets and JSPs. o Apply this step when application requirements become more sophisticated, and as business logic consolidation is required at the business tier to offer the same business service to all clients (i.e., not only to presentation clients). o Introducing session beans as business service processing components enables this functionality. Session beans access the persistent storage via the data access objects. o Container-managed or bean-managed transaction demarcation can be utilized as appropriate for the session beans. o See “Session Facade”.  

将数据访问代码从控制对象和实体对象中分离，形成独立的数据访问对象。  
○ 参见“分离数据访问代码”章节  
分离表示层与业务处理层。引入会话Bean处理业务逻辑，而将表示层处理保留在Servlet和JSP中。  
○ 当应用需求趋于复杂，且业务层需要整合业务逻辑以向所有客户端（不仅限于表示层客户端）提供统一业务服务时，应采用此步骤。  
○ 通过将会话Bean作为业务服务处理组件引入，可实现该功能。会话Bean通过数据访问对象访问持久化存储。  
○ 可根据实际需求为会话Bean选择容器管理或Bean管理的事务划分方式。  
○ 参见“会话门面”模式

Introduce entity beans to model-shared, transactional, coarse-grained persistent business objects. If requirements do not warrant using entity beans, then skip this step.  

引入实体Bean来建模共享的、事务性的、粗粒度持久化业务对象。若需求不涉及使用实体Bean，则跳过此步骤。

o Apply this step when the persistent business components become increasingly complex and you wish to leverage the entity bean benefits, including container-managed transactions and container-managed persistence (CMP).   
o Entity beans offer container-managed transaction for transaction demarcation. This allows declarative programming for transaction demarcation without hardcoding the transaction logic into the enterprise beans.   
o See “Value Object and “Composite Entity”.  

当持久化业务组件日益复杂且需要利用实体Bean的优势（包括容器管理事务和容器管理持久化(CMP)）时，可采用此步骤。  
实体Bean提供容器管理事务以实现事务划分，支持通过声明式编程进行事务划分，而无需将事务逻辑硬编码至企业级Bean中。  
参见“值对象”与“复合实体”模式。

• Decouple presentation-tier and business-tier components, using business delegates.  

• 使用业务委托模式解耦表示层与业务层组件

o Business Delegate decouples the presentation-tier components from business-tier components and hides the complexity of lookup and other implementation details.   
o See “Business Delegate”.  

o **业务委托**模式解耦了表示层组件与业务层组件，隐藏了查找服务及其他实现细节的复杂性。  
o 参见“业务委托”章节。

# Use A Connection Pool  

Database connections are not shared. Instead, clients manage their own connections for making database invocations.  

数据库连接不共享。客户端需自行管理连接以执行数据库调用。

Use a Connection Pool to pre-initialize multiple Connections, improving scalability and performance.  

使用连接池预初始化多个连接，以提升可扩展性和性能。

![](images/9d880f358703a2c7f4fc462d8577e209e89be549d7e8f25f9cbf65e5200040a6.jpg)  
Figure 5.25. Use A Connection Pool  

图 5.25. 使用连接池

# Motivation  

Opening a connection to a database is a fairly expensive operation that takes time and resources to perform. Both performance and scalability are affected. Since database connections are limited, if each client manages its own connection, the total number of connections will likely be exhausted far sooner than desired.  

建立数据库连接是一项相当耗时的操作，需要消耗大量时间和资源。这会影响系统性能和可扩展性。由于数据库连接数量有限，若每个客户端各自管理连接，连接总数很可能在远未达到预期需求时就被耗尽。

This issue arises in the presentation tier on projects that use a phased approach to introducing EJB technology. In this case, components in the presentation tier initially interact directly with a database, and the data access code is later moved into the business tier and encapsulated in an EJB layer. See “Separate Data Access Code” and “Refactor Architecture by Tiers” .  

该问题出现在采用分阶段引入EJB技术的项目表示层中。这种情况下，表示层组件最初直接与数据库交互，随后数据访问代码会被迁移至业务层并封装在EJB层中。参见《分离数据访问代码》与《按层级重构架构》章节。

# Mechanics  

Create an interface for connection management, including methods for   
retrieving and returning a connection.   
Apply Extract Class [Fowler] and/or Move Method [Fowler], moving the   
existing connection retrieval code into a class that implements the   
connection management interface. o At the points from which the connection code was extracted, substitute invocations to an instance of this new class; that is, connectionMgr.getConnection() and connectionMgr.returnConnection(conn). o Note that the JDBC specification, version 2, includes a standard mechanism for introducing connection pooling. This mechanism, if available, is the recommended way to introduce connection pooling. In the JDBC specification version 2, the management interface is named javax.sql.DataSource and it provides a factory for pooled Connection objects. o At this point, only the structure and interface has been standardized, but the functionality is the same. o Still no pooling is implemented, unless the JDBC 2.0 DataSource factory is utilized, which is recommended.  

创建一个用于连接管理的**接口**，包含获取和归还连接的方法。  
应用**提取类**[Fowler]和/或**搬移方法**[Fowler]重构手法，将现有连接获取代码移至实现该连接管理接口的类中。  
在原先提取连接代码的位置，替换为调用新类实例的方法：即`connectionMgr.getConnection()`和`connectionMgr.returnConnection(conn)`。  
需注意JDBC 2.0规范提供了标准的连接池引入机制，若环境支持则推荐采用该机制。在JDBC 2.0规范中，管理接口命名为`javax.sql.DataSource`，它作为池化`Connection`对象的工厂。  
当前阶段仅标准化了结构和接口，功能实现保持不变。  
除非使用推荐的JDBC 2.0 `DataSource`工厂，否则仍未实现连接池功能。

Modify the implementation of the connection retrieval methods within the connection manager implementation to pre-initialize some Connection instances and share them among users, thus introducing pooling.  

修改连接管理器实现中的连接获取方法实现，预初始化部分Connection实例并在用户间共享，从而引入连接池机制。

o There are numerous publicly available implementations from which to choose.   
o Clients of these connection manager instances are typically DAOs. See “Separate Data Access Code”.   
o Data access code typically migrates logically closer to the database as a project evolves. See “Refactor Architecture by Tiers”.  

o 有众多公开可选的实现方案可供选择。  
o 这些连接管理器实例的客户端通常是DAO（数据访问对象）。参见“分离数据访问代码”章节。  
o 随着项目演进，数据访问代码通常会逻辑上更靠近数据库层。参见“按层级重构架构”章节。

# Part III: J2EE PATTERN CATALOG  

Chapter 6 provides an overview of the J2EE Pattern Catalog with a discussion on our tiered approach. The chapter provides a guide to the pattern catalog and describes the terminology and UML Stereotypes used to describe each pattern. The template used to document each pattern is also defined and discussed. One of the important aspects of the chapter is the discussion of the relationships among various patterns in the catalog - both with each other, as well as with patterns in other literature such as Design Patterns [GoF], Patterns of Software Architecture, Volume 1 [POSA1] and Volume 2 [POSA2]. Another useful artifact in this chapter is the J2EE Patterns roadmap, which presents a table of common requirements mapped to various patterns and refactorings.  

第6章概述了J2EE模式目录，并讨论了我们的分层方法。本章提供了模式目录的指南，描述了用于描述每个模式的术语和UML构造型。同时定义并讨论了用于记录每个模式的模板。本章的一个重要方面是探讨目录中各种模式之间的关系——既包括彼此之间的关系，也包括与《设计模式》[GoF]、《软件架构模式》第1卷[POSA1]和第2卷[POSA2]等其他文献中模式的关系。本章另一个实用成果是J2EE模式路线图，它呈现了将常见需求映射到各种模式和重构的对照表。

Chapter 7, 8 and 9 describe the patterns in the J2EE Pattern Catalog.  

第7、8、9章阐述J2EE模式目录中的设计模式。

Chapter 7 provides six patterns for the presentation tier dealing with Servlets and Java Server Pages (JSP) technologies.  

第7章针对Servlet和Java Server Pages (JSP)技术，提出了六种表示层模式。

Chapter 8 provides seven business-tier patterns related to the use of Enterprise JavaBeans (EJB), Java Database Connectivity (JDBC), Java Naming and Directory Interface (JNDI) technologies.  

第8章提供了7种与Enterprise JavaBeans (EJB)、Java Database Connectivity (JDBC) 和Java Naming and Directory Interface (JNDI) 技术相关的业务层模式。

Chapter 9 provides 2 patterns related to the use of Java Database Connectivity (JDBC) and Java Messaging Service (JMS) technologies.  

第9章提供了2种与Java数据库连接（JDBC）和Java消息服务（JMS）技术相关的模式。

Epilogue presents a brief discussion on pattern selection and usage with sample use cases. It also discusses and demonstrates how multiple patterns work together to create a solution.  

尾声部分简要探讨了模式选择与应用的示例场景，并通过实例演示了多种模式如何协同工作以构建解决方案。

Part 3 J2EE PATTERN CATALOG  

第三部分 J2EE模式目录

Chapter 6—J2EE Patterns Overview Chapter 7—Presentation Tier Patterns Chapter 8—Business Tier Patterns Chapter 9—Integration Tier Patterns Epilogue—J2EE Patterns Applied  

第6章—J2EE模式概述  
第7章—表示层模式  
第8章—业务层模式  
第9章—集成层模式  
结语—J2EE模式实践应用

# Chapter 6. J2EE PATTERNS OVERVIEW  

# Topics in This Chapter  

The Tiered Approach   
• J2EE Patterns   
• J2EE Pattern Relationships   
• Relationship to Known Patterns Patterns Roadmap  

分层架构方法  
• J2EE模式  
• J2EE模式关联关系  
• 与已知模式的关系  
模式路线图

The J2EE patterns are a collection of J2EE-based solutions to common problems. They reflect the collective expertise and experience of Java architects at the Sun Java Center, gained from successfully executing numerous J2EE engagements. The Sun Java Center is Sun's consulting organization, focused on architecting Java technology-based solutions for customers. The Sun Java Center has been architecting solutions for the J2EE platform since its early days, focusing on achieving Quality of Service (QoS) qualities such as scalability, availability, performance, securability, reliability, and flexibility.  

J2EE模式是一套基于J2EE的通用问题解决方案集合。这些模式凝聚了Sun Java中心架构师团队在成功实施大量J2EE项目过程中积累的集体智慧与实践经验。作为Sun公司的技术咨询机构，Sun Java中心专注于为客户构建基于Java技术的解决方案。自J2EE平台诞生之初，该中心便致力于实现包括可扩展性、可用性、性能、安全性、可靠性及灵活性在内的服务质量（QoS）目标。

These J2EE patterns describe typical problems encountered by enterprise application developers and provide solutions for these problems. We have formulated these solutions based on our ongoing work with numerous J2EE customers and on exchanges with other Java architects experiencing similar problems. The patterns capture the essence of these solutions, and they represent the solution refinement that takes place over the course of time and from collective experience. To put it another way, they extract the core issues of each problem, offering solutions that represent an applicable distillation of theory and practice.  

这些J2EE模式描述了企业应用开发者遇到的典型问题，并提供了相应的解决方案。我们基于与众多J2EE客户的持续合作，以及与其他面临类似问题的Java架构师的交流，制定了这些解决方案。这些模式提炼了解决方案的精髓，体现了随着时间推移和集体经验积累而形成的方案优化。换言之，它们提取了每个问题的核心要点，提供的解决方案是理论与实践相结合的适用性结晶。

Our work has focused on the J2EE area, especially regarding such J2EE components as Enterprise Java Beans (EJB), Java Server Pages (JSP), and servlets. During our work with J2EE customers implementing the various components, we have come to recognize the common problems and difficult areas that may impede a good implementation. We've also developed effective best practices and approaches for using the J2EE components in combination.  

我们的工作聚焦于J2EE领域，特别是针对企业级Java Beans（EJB）、Java Server Pages（JSP）和Servlet等J2EE组件。在为客户实施各类J2EE组件的过程中，我们识别出可能阻碍良好实现的常见问题与难点领域，并总结出组合使用J2EE组件的高效最佳实践与方法论。

The patterns presented here extract these “best practice” approaches and present them to you in a way that enables you to apply the patterns to your own particular application and to accommodate your own needs. The patterns clearly and simply express proven techniques. They make it easier for you to reuse successful designs and architectures. Simply put, you can use the patterns to design your J2EE system successfully and quickly.  

本文呈现的模式提炼了这些"最佳实践"方法，并以一种能适配您特定应用程序需求的方式予以展现。这些模式清晰简洁地表达了经过验证的技术，使您能更轻松地复用成功的设计与架构。简而言之，运用这些模式可助您高效完成J2EE系统的设计。

# What Is a Pattern?  

In Chapter 1, we discussed how different experts define a pattern. We also discussed some of the peripheral issues around patterns including the benefits of using patterns. Here, we revisit this discussion in the context of the J2EE Pattern Catalog.  

在第一章中，我们探讨了不同专家对模式的定义方式，同时讨论了围绕模式的一些周边问题，包括使用模式的优势。此处，我们将结合J2EE模式目录重新审视这一讨论。

As discussed in Chapter 1, some experts define a pattern as a recurring solution to a problem in a context. These terms—context, problem, and solution—deserve a bit of explanation. First, what is a context? A context is the environment, surroundings, situation, or interrelated conditions within which something exists. Second, what is a problem? A problem is an unsettled question, something that needs to be investigated and solved. Typically, the problem is constrained by the context in which it occurs. Finally, the solution refers to the answer to the problem in a context that helps resolve the issues.  

如第1章所述，部分专家将模式定义为在特定上下文中对某一问题的重复性解决方案。其中**上下文**、**问题**和**解决方案**这三个术语需要进一步阐释：  
1. **上下文**指事物所处的环境、背景、情境或相互关联的条件集合；  
2. **问题**则是待解决的未决事项，需要通过调查分析予以攻克，且通常受限于其发生的上下文；  
3. **解决方案**即针对特定上下文中的问题给出的应答，其作用在于化解相关矛盾。

So, if we have a solution to a problem in a context, is it a pattern? Not necessarily. The characteristic of recurrence also needs to be associated with the definition of a pattern. That is, a pattern is only useful if it can be applied repeatedly. Is that all? Perhaps not. As you can see, while the concept of a pattern is fairly simple, actually defining the term is more complex.  

那么，如果我们在某个上下文中找到了问题的解决方案，它就能被称为模式吗？未必如此。模式的定义还需要与**重复出现的特性**相关联。也就是说，只有当某个方案能够被反复应用时，它才能成为有价值的模式。这样就足够了吗？可能还不够。如你所见，尽管模式的概念看似简单，但准确定义这个术语实则更为复杂。

We point you to the references so that you can dig more deeply into the pattern history and learn about patterns in other areas. In our catalog, a pattern is described according to its main characteristics: context, problem, and solution, along with other important aspects, such as forces and consequences. The section describing the pattern template (see “Pattern Template”) explains these characteristics in more detail.  

我们提供相关参考资料，以便您更深入地探究模式的发展历史并了解其他领域的模式应用。在我们的模式目录中，每个模式均按照其主要特征进行描述：**上下文环境**、**问题场景**和**解决方案**，同时涵盖其他关键要素，例如**作用力**和**实施后果**。关于模式模板的详细说明（参见“模式模板”章节）将对这些特征进行更深入的解析。

# Identifying a Pattern  

We have handled many J2EE projects at the Sun Java Center, and over time we have noticed that similar problems recur across these projects. We have also seen similar solutions emerge for these problems. While the implementation strategies varied, the overall solutions were quite similar. Let us discuss, in brief, our pattern identification process.  

我们在Sun Java中心处理过众多J2EE项目，经过长期观察发现类似问题会在这些项目中反复出现。针对这些问题，我们也见证了相似解决方案的涌现。尽管具体实现策略各有不同，但整体解决方案却高度相似。下面简要阐述我们的模式识别流程。

When we see a problem and solution recur, we try to identify and document its characteristics using the pattern template. At first, we consider these initial documents to be candidate patterns. However, we do not add candidate patterns to the pattern catalog until we are able to observe and document their usage multiple times on different projects. We also undertake the process of pattern mining by looking for patterns in implemented solutions.  

当我们发现某个问题及其解决方案反复出现时，会尝试通过**模式模板**来识别并记录其特征。最初，我们将这些初步文档视为候选模式。但只有在不同项目中多次观察并记录其实际应用后，才会将候选模式纳入模式目录。此外，我们还通过分析已实现的解决方案来开展**模式挖掘**工作。

As part of the pattern validation process, we use the Rule of Three, as it is known in the pattern community. This rule is a guide for transitioning a candidate pattern into the pattern catalog. According to this rule, a solution remains a candidate pattern until it has been verified in at least three different systems. Certainly, there is much room for interpretation with rules such as this, but they help provide a context for pattern identification.  

在模式验证过程中，我们采用模式社区公认的**三现原则**。该原则是将候选模式纳入模式目录的指导准则，其核心要求是：一个解决方案必须至少在三个不同系统中得到验证，才能从候选模式转为正式模式。虽然此类规则存在较大解释空间，但它们为模式识别提供了重要语境框架。  

（注：根据技术文档惯例，"Rule of Three"译为"三现原则"以契合软件模式领域的专业表述；"pattern catalog"译为"模式目录"符合架构设计术语；通过拆分长句并添加"其核心要求是"提升中文可读性；末句采用"语境框架"准确传达"context"的技术含义）

Often, similar solutions may represent a single pattern. When deciding how to form the pattern, it is important to consider how to best communicate the solution. Sometimes, a separate name improves communication among developers. If so, then consider documenting two similar solutions as two different patterns. On the other hand, it might be better to communicate the solution by distilling the similar ideas into a pattern/strategy combination.  

通常，相似的解决方案可能代表单一模式。在决定如何构建模式时，关键要考虑如何最有效地传达解决方案。有时，采用独立命名能提升开发者间的沟通效率。若确实如此，则考虑将两个相似方案作为不同模式分别记录。反之，通过将相似理念提炼为模式/策略组合来传达方案可能更为合适。

# Patterns Versus Strategies  

When we started documenting the J2EE patterns, we made the decision to document them at a relatively high level of abstraction. At the same time, each pattern includes various strategies that provide lower level implementation details. Through the strategies, each pattern documents a solution at multiple levels of abstraction. We could have documented some of these strategies as patterns in their own right; however, we feel that our current template structure most clearly communicates the relationship of the strategies to the higher level pattern structure in which they are included.  

在开始编写J2EE模式文档时，我们决定采用相对较高的抽象层级进行记录。与此同时，每个模式都包含多种策略，这些策略提供了更底层的实现细节。通过这些策略，每个模式在多个抽象层级上记录解决方案。我们本可以将其中某些策略单独作为模式来记录，但认为当前的模板结构能更清晰地展现策略与其所属高层级模式结构之间的关系。

While we continue to have lively debates about converting these strategies to patterns, we have deferred these decisions for now, believing the current documentation to be clear. We have noted some of the issues with respect to the relationship of the strategies to the patterns:  

尽管我们仍在热烈讨论是否将这些策略转化为模式，但目前已暂缓相关决策，因为我们认为现有文档足够清晰。我们已注意到这些策略与模式关联性方面存在的若干问题：

The patterns exist at a higher level of abstraction than the strategies. The patterns include the most recommended or most common   
implementations as strategies.   
Strategies provide an extensibility point for each pattern. Developers discover and invent new ways to implement the patterns, producing new strategies for well-known patterns.   
Strategies promote better communication by providing names for lower level aspects of a particular solution.  

模式存在于比策略更高层次的抽象层面。模式包含了最推荐或最常见的实现作为策略。  
策略为每个模式提供了可扩展点。开发者发现并发明实现模式的新方法，从而为已知模式产生新的策略。  
策略通过为特定解决方案的底层细节提供命名，促进了更好的沟通。

# The Tiered Approach  

Since this catalog describes patterns that help you build applications that run on the J2EE platform, and since a J2EE platform (and application) is a multitiered system, we view the system in terms of tiers. A tier is a logical partition of the separation of concerns in the system. Each tier is assigned its unique responsibility in the system. We view each tier as logically separated from one another. Each tier is loosely coupled with the adjacent tier. We represent the whole system as a stack of tiers. See Figure 6.1.  

由于本目录描述的**模式**旨在帮助构建运行于J2EE平台的应用，而J2EE平台（及其应用）属于多层系统，因此我们采用**分层**视角来解析系统。**层**是对系统中关注点分离的逻辑划分，每层被赋予独特的职责。各层在逻辑上相互隔离，仅通过松耦合方式与相邻层交互。整个系统可表示为分层的堆叠结构，如图6.1所示。

# Figure 6.1. Tiered approach  

![](images/0cda613c8dc8cd4f7f9fef16914a8c686492fddd757b6dcb3cd102110941e23a.jpg)  

# Client Tier  

This tier represents all device or system clients accessing the system or the application. A client can be a Web browser, a Java or other application, a Java applet, a WAP phone, a network application, or some device introduced in the future. It could even be a batch process.  

该层代表所有访问系统或应用程序的设备或系统客户端。客户端可以是Web浏览器、Java或其他应用程序、Java applet、WAP手机、网络应用程序，或是未来引入的某些设备，甚至可能是批处理作业。

# Presentation Tier  

This tier encapsulates all presentation logic required to service the clients that access the system. The presentation tier intercepts the client requests, provides single sign-on, conducts session management, controls access to business services, constructs the responses, and delivers the responses to the client. Servlets and JSPs reside in this tier. Note that servlets and JSPs are not themselves UI elements, but they produce UI elements.  

该层封装了为访问系统的客户端提供服务所需的所有表示层逻辑。表示层负责拦截客户端请求、提供单点登录、进行会话管理、控制对业务服务的访问、构建响应并将响应返回给客户端。Servlet和JSP位于该层。需注意Servlet和JSP本身并非UI元素，而是用于生成UI元素。

# Business Tier  

This tier provides the business services required by the application clients. The tier contains the business data and business logic. Typically, most business processing for the application is centralized into this tier. It is possible that, due to legacy systems, some business processing may occur in the resource tier. Enterprise bean components are the usual and preferred solution for implementing the business objects in the business tier.  

该层为应用客户端提供所需的业务服务，包含业务数据与业务逻辑。通常，应用程序的大部分业务处理都集中于此层。由于遗留系统的存在，部分业务处理可能仍发生在资源层。在业务层中实现业务对象时，**Enterprise Bean**组件是常规且推荐的解决方案。

# Integration Tier  

This tier is responsible for communicating with external resources and systems such as data stores and legacy applications. The business tier is coupled with the integration tier whenever the business objects require data or services that reside in the resource tier. The components in this tier can use JDBC, J2EE connector technology, or some proprietary middleware to work with the resource tier.  

该层负责与外部资源和系统（如数据存储和遗留应用程序）进行通信。当业务对象需要访问资源层的数据或服务时，业务层会与集成层耦合。该层组件可使用JDBC、J2EE连接器技术或某些专有中间件来操作资源层。

# Resource Tier  

This is the tier that contains the business data and external resources such as mainframes and legacy systems, business-to-business (B2B) integration systems, and services such as credit card authorization.  

该层包含业务数据及外部资源，例如大型机与遗留系统、企业间（B2B）集成系统，以及信用卡授权等服务。

# J2EE Patterns  

We used the tiered approach to divide the J2EE patterns according to functionality, and our pattern catalog follows this approach. The presentation tier patterns contain the patterns related to servlets and JSP technology. The business tier patterns contain the patterns related to the EJB technology. The integration tier patterns contain the patterns related to JMS and JDBC. See Figure 6.2.  

我们采用分层方法根据功能划分J2EE模式，本模式目录遵循这一原则。表现层模式包含与Servlet和JSP技术相关的模式；业务层模式包含与EJB技术相关的模式；集成层模式则涵盖与JMS和JDBC相关的模式。具体参见图6.2。

![](images/8b52a1f7cada434f35aa4eb2a6fa21ace21f332c08f7c0700c1197600e1c9270.jpg)  
Figure 6.2. J2EE pattern relationships  

图6.2 J2EE模式关系图

# Presentation Tier Patterns  

Table 6-1 lists the presentation tier patterns, along with a brief description of each pattern.  

表6-1列出了表示层模式及其简要说明。

<html><body><table><tr><td colspan="2">Table 6-1. Presentation Tier Patterns</td></tr><tr><td>PatternName</td><td>Synopsis</td></tr><tr><td>Intercepting Filter</td><td></td></tr><tr><td>Front Controller</td><td>Provides a centralized controller for managing the handling of a request.</td></tr><tr><td>View Helper</td><td>Encapsulates logic that is not related to presentation formatting into Helper components.</td></tr><tr><td>Composite View</td><td>Creates an aggregate View from atomic subcomponents.</td></tr><tr><td>Service Worker</td><td>ViewHelperPatterns.</td></tr><tr><td>Dispatcher View</td><td>Combines a Dispatcher component with the FrontController and View Helper Patterns, deferring many activities to View processing.</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表6-1. 表示层模式</td></tr><tr><td>模式名称</td><td>概要</td></tr><tr><td>拦截过滤器</td><td></td></tr><tr><td>前端控制器</td><td>为请求处理提供集中化的控制逻辑。</td></tr><tr><td>视图助手</td><td>将与呈现格式无关的逻辑封装至助手组件。</td></tr><tr><td>组合视图</td><td>通过原子化子组件构建聚合视图。</td></tr><tr><td>服务工作者</td><td>视图助手模式。</td></tr><tr><td>分发器视图</td><td>将分发器组件与前端控制器及视图助手模式结合，将多数行为延迟至视图处理阶段。</td></tr></table></body></html>

# Business Tier Patterns  

Table 6-2 lists the business tier patterns, along with a brief synopsis of each pattern.  

表6-2列出了业务层模式，并附有各模式的简要说明。

<html><body><table><tr><td colspan="2">Table 6-2. Business Tier Patterns</td></tr><tr><td>Pattern Name</td><td>Synopsis</td></tr><tr><td>Business Delegate</td><td>Decouples presentation and service tiers, and provides a facade and proxy interface to the services.</td></tr><tr><td>ValueObject</td><td>Facilitates dataexchange between tiers by reducingnetwork chattiness.</td></tr><tr><td></td><td>Session Facade Hides business object complexity; centralizes workflow handling.</td></tr><tr><td>Composite Entity</td><td>Represents a best practice for designing coarse-grained entity beans by grouping parent-dependent objects into a single entity bean.</td></tr><tr><td>Value Assembler</td><td>Object Assembles a composite value object from multiple data sources.</td></tr><tr><td>Value Handler</td><td>List Manages query execution, results caching, and results processing.</td></tr><tr><td></td><td>locates business service factories.</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表6-2. 业务层模式</td></tr><tr><td>模式名称</td><td>概要</td></tr><tr><td>业务委托</td><td>解耦表示层与服务层，并为服务提供门面和代理接口。</td></tr><tr><td>值对象</td><td>通过减少网络通信频次，促进各层之间的数据交换。</td></tr><tr><td></td><td>会话门面 隐藏业务对象复杂性；集中处理工作流。</td></tr><tr><td>组合实体</td><td>通过将父依赖对象分组到单个实体Bean中，体现设计粗粒度实体Bean的最佳实践。</td></tr><tr><td>值组装器</td><td>从多个数据源组装复合值对象。</td></tr><tr><td>值处理器</td><td>列表 管理查询执行、结果缓存及结果处理。</td></tr><tr><td></td><td>定位业务服务工厂。</td></tr></table></body></html>

# Integration Tier Patterns  

Table 6-3 lists the integration tier patterns and provides a brief description of each pattern.  

表6-3列出了集成层模式，并对每种模式进行了简要描述。

<html><body><table><tr><td colspan="2">Table 6-3. Integration Tier Patterns</td></tr><tr><td>PatternName</td><td>Synopsis</td></tr><tr><td>DataAccessObject</td><td>Abstracts data sources; provides transparent access to data.</td></tr><tr><td>ServiceActivator</td><td>Facilitates asynchronous processing for EJB components.</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表6-3. 集成层模式</td></tr><tr><td>模式名称</td><td>概要</td></tr><tr><td>DataAccessObject</td><td>抽象数据源；提供透明的数据访问。</td></tr><tr><td>ServiceActivator</td><td>为EJB组件提供异步处理支持。</td></tr></table></body></html>

# Guide to the Catalog  

To help you effectively understand and use the J2EE patterns in the catalog, we suggest that you familiarize yourself with this section before reading the individual patterns. Here we introduce the pattern terminology and explain our use of the Unified Modeling Language (UML), stereotypes, and the pattern template. In short, we explain how to use these patterns. We also provide a high-level roadmap to the patterns in the catalog.  

为了帮助您有效理解并运用本目录中的J2EE模式，建议在阅读具体模式前先熟悉本节内容。此处我们将介绍模式术语，并阐述我们如何运用统一建模语言（UML）、构造型及模式模板。简而言之，我们将解释这些模式的使用方法。同时，我们还会提供本目录模式的高层次路线图。

# Terminology  

Players in the enterprise computing area, and particularly establishments using Java-based systems, have incorporated a number of terms and acronyms into their language. While many readers are familiar with these terms, sometimes their use varies from one setting to another. To avoid misunderstandings and to keep things consistent, we define in Table 6-4 how we use these terms and acronyms.  

在企业计算领域，尤其是采用基于Java系统的机构中，从业者常使用大量术语与缩写词。尽管许多读者对这些术语并不陌生，但其具体用法往往因场景而异。为避免歧义并保持一致性，我们在表6-4中明确定义了这些术语及缩写的使用规范。

<html><body><table><tr><td colspan="3">Table 6-4. Terminology</td></tr><tr><td>Term</td><td>Description/Definition</td><td>Usedin</td></tr><tr><td>BMP</td><td>s beans where the bean developer implements the patterns persistencelogicfor entitybeans.</td><td>tier</td></tr><tr><td></td><td>Business ObjectAn object that implements business logic and/or Business business data.Business data and business logic patterns areimplementedin coarse-grained objects called</td><td>tier</td></tr></table></body></html>  

<html><body><table><tr><td colspan="3">表6-4. 术语表</td></tr><tr><td>术语</td><td>描述/定义</td><td>使用层级</td></tr><tr><td>BMP</td><td>由Bean开发者自行实现实体Bean持久化逻辑的Bean</td><td>业务层</td></tr><tr><td></td><td>业务对象：实现业务逻辑和/或业务数据的对象。业务数据与业务逻辑模式通常封装在名为粗粒度对象的实现中</td><td>业务层</td></tr></table></body></html>

<html><body><table><tr><td></td><td>implemented as session or entity beans. In some cases, a business object could be an arbitrary Java object that provides some service.</td><td></td></tr><tr><td>CMP</td><td>Container-managed persistence: a strategy for Business entitybeans where the container servicespatterns transparently manage the persistence of entity beans.</td><td>tier</td></tr><tr><td>Composite</td><td>A complex object that holds other objects. Also Composite View, related to the Composite pattern described in theComposite GoF book.(See GoF below.)</td><td>Entity</td></tr><tr><td>Controller</td><td>Interacts with a client, controlling and managing Presentation and the handling of each request.</td><td>business tier patterns</td></tr><tr><td>Data Object</td><td>ss to data from a persistent store or an external integration system. Currently, Data Access Objects are patterns closely related to bean-managed persistence.</td><td>and tier</td></tr><tr><td>Delegate</td><td>A stand-in, or surrogate, object for another Business component;anintermediatelayer.ADelegate Delegate has qualities of a proxy and facade.</td><td>and many other patterns</td></tr><tr><td>Dependent Object</td><td>An object that does not exist by itself and whose Composite lifecycle is managed by another object.</td><td>Entity pattern</td></tr><tr><td>Dispatcher</td><td>Some of the responsibilities of a Controller Dispatcher View, include managing the choice of and dispatching Service toanappropriateView.Thisbehavior maybe Worker partitioned into a separate component, referred to as a Dispatcher.</td><td></td></tr><tr><td></td><td>Enterprise Bean Refers to an Enterprise JavaBean component;Many places can be a session or entity bean instance. When this literature this term is used, it means that the bean instance can be either an entity or a session bean.</td><td>in</td></tr><tr><td>Entity Bean</td><td>Refers to an entity bean. May also refer Many places collectively to the entity bean's home interface, this literature remote object, bean implementation, and primary key objects.</td><td></td></tr><tr><td>Facade</td><td>A pattern for hiding underlying complexities; Session described in the GoF book.</td><td>Facade pattern</td></tr><tr><td>Factory (Abstract Factory or</td><td>Patterns described in the GoF book for creating Business objects or families of objects.</td><td>tier patterns: Data Access Object,</td></tr></table></body></html>  

<html><body><table><tr><td></td><td>实现为会话Bean或实体Bean。某些情况下，业务对象可以是提供特定服务的任意Java对象。</td><td></td></tr><tr><td>CMP</td><td>容器管理持久化：一种业务实体Bean策略，通过容器服务模式透明管理实体Bean的持久化。</td><td>层</td></tr><tr><td>组合</td><td>包含其他对象的复杂对象。组合视图(Composite View)与GoF著作中描述的Composite模式相关。(参见下文GoF)</td><td>实体</td></tr><tr><td>控制器</td><td>与客户端交互，控制并管理表示层及每个请求的处理。</td><td>业务层模式</td></tr><tr><td>数据对象</td><td>访问持久化存储或外部集成系统的数据。当前数据访问对象(DAO)模式与Bean管理持久化密切相关。</td><td>与层</td></tr><tr><td>委托</td><td>作为其他业务组件的代理对象或中介层。委托(Delegate)兼具代理模式和门面模式特性。</td><td>及其他多种模式</td></tr><tr><td>依赖对象</td><td>自身无法独立存在且生命周期由其他对象管理的对象。</td><td>实体模式</td></tr><tr><td>分发器</td><td>控制器分发视图(Dispatcher View)的部分职责包括管理视图选择并将服务分发给合适的视图。该行为可被划分为独立组件，称为分发器。</td><td></td></tr><tr><td></td><td>企业级Bean指EJB组件；可以是会话Bean或实体Bean实例。本文中使用该术语时，表示该实例可能是实体Bean或会话Bean。</td><td>于</td></tr><tr><td>实体Bean</td><td>指实体Bean。也可统称指代实体Bean的Home接口、远程对象、Bean实现及主键对象。</td><td></td></tr><tr><td>门面</td><td>用于隐藏底层复杂性的模式；GoF著作中描述的门面模式。</td><td>门面模式</td></tr><tr><td>工厂(抽象工厂或</td><td>GoF著作中描述的创建对象或对象族的模式。</td><td>业务层模式：数据访问对象</td></tr></table></body></html>

<html><body><table><tr><td>Factory Method)</td><td></td><td>Valueobject</td></tr><tr><td>Iterator</td><td>Apatterntoprovide accessorstounderlying Value collection facilities; described in the GoF book. Handler</td><td>List</td></tr><tr><td>GoF</td><td>GangofFour—refers tothe authors of the Manyplacesin popular design patterns book, Design Patterns:this literature ElementsofReusableObject-OrientedSoftware, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. [GoF]</td><td></td></tr><tr><td>Helper</td><td>Responsible for helping the Controller and/or Presentation tier View. For example, the Controller and View may patterns, delegate the following to a Helper: content Business retrieval, validation, storing the model or Delegate adapting it for use by the display.</td><td></td></tr><tr><td>Independent Object</td><td>Anobject that canexist byitself and may Composite manage the lifecycles of its dependent objects. Entity pattern</td><td></td></tr><tr><td>Locator</td><td>Anobject that aidsinlocatingservice and ServiceLocator business objects.</td><td>pattern</td></tr><tr><td>Model</td><td>A physical or logical representation of the system Presentation and or its subsystem.</td><td>business tier patterns</td></tr><tr><td></td><td>RDBMSs, ODBMSs, file systems, and so forth.</td><td>pue integration tier patterns</td></tr><tr><td>Proxy</td><td>A pattern to provide a placeholder for another Many places in object to control access to it; described in the this literature GoF book.</td><td></td></tr><tr><td>Scriptlet</td><td>Application logic embedded directly within a JSP. Presentation tier</td><td>patterns</td></tr><tr><td>SessionBean</td><td>Refers to a stateless or stateful session bean.Business May also refer collectively to the session bean's patterns home, remote object, and bean implementation.</td><td>tier</td></tr><tr><td>Singleton Template</td><td>A pattern that provides a single instance of an Manyplaces object, as described in the GoF book.</td><td>in this literature</td></tr><tr><td></td><td>encapsulated within a JSP View. Additionally, apatterns template may refer to a specific layout of components in a display.</td><td></td></tr><tr><td>Value Object</td><td>An arbitrary Java object that is used to carry data Business contain any business methods. May be designed with public attributes or provided with get</td><td>tier</td></tr></table></body></html>  

<html><body><table><tr><td>工厂方法)</td><td></td><td>值对象</td></tr><tr><td>迭代器</td><td>一种提供底层值集合访问器的模式；见GoF著作描述</td><td>列表</td></tr><tr><td>GoF</td><td>四人组——指经典设计模式著作《设计模式：可复用面向对象软件的基础》作者Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides</td><td></td></tr><tr><td>助手</td><td>负责协助控制器和/或表示层视图。例如控制器和视图可能将以下工作委托给助手：内容检索、验证、存储模型或适配显示数据</td><td></td></tr><tr><td>独立对象</td><td>可独立存在并管理其依赖对象生命周期的对象</td><td>组合模式</td></tr><tr><td>定位器</td><td>辅助定位服务和业务对象的对象</td><td>服务定位器模式</td></tr><tr><td>模型</td><td>系统或其子系统的物理或逻辑表示</td><td>业务层模式</td></tr><tr><td></td><td>关系型数据库、对象数据库、文件系统等</td><td>集成层模式</td></tr><tr><td>代理</td><td>为控制对象访问而提供替身的模式；见GoF著作描述</td><td></td></tr><tr><td>脚本片段</td><td>直接嵌入JSP的应用逻辑</td><td>表示层模式</td></tr><tr><td>SessionBean</td><td>指无状态或有状态会话Bean，也可统指会话Bean的Home接口、远程对象及Bean实现</td><td>业务层</td></tr><tr><td>单例模板</td><td>提供对象单一实例的模式，见GoF著作描述</td><td>本文献中</td></tr><tr><td></td><td>封装在JSP视图中的模板，也可指显示组件的特定布局</td><td></td></tr><tr><td>值对象</td><td>用于传输数据的任意Java对象，不包含业务方法。可设计为公有属性或提供getter</td><td>业务层</td></tr></table></body></html>

<html><body><table><tr><td></td><td>methods to obtain attribute values.</td><td></td></tr><tr><td>View</td><td>TheViewmanages sthe make up the display. It interacts with Helpers to patterns get data values with whichto populate the display. Additionally, it may c delegateactivities, such ascontentretrieval, to its Helpers.</td><td>egraphics and text thatPresentation tier</td></tr></table></body></html>  

<html><body><table><tr><td></td><td>获取属性值的方法</td><td></td></tr><tr><td>视图层</td><td>视图层负责管理构成显示的要素。它通过与助手交互来获取用于填充显示的数据值。此外，它可能将某些活动（例如内容检索）委托给其助手处理。</td><td>图形与文本呈现层</td></tr></table></body></html>

# Use of UML  

We have used UML extensively in the pattern catalog, particularly as follows:  

我们在模式目录中广泛使用了UML，具体应用如下：

Class diagrams.  We use the class diagrams to show the structure of the pattern solution and the structure of the implementation strategies. This provides the static view of the solution.   
Sequence (or Interaction) diagrams.  We use these diagrams to show the interactions between different participants in a solution or a strategy. This provides the dynamic view of the solution.   
Stereotypes.  We use stereotypes to indicate different types of objects and roles in the class and interaction diagrams. The list of stereotypes and their meanings is included in Table 6-5.  

类图。我们使用类图展示模式解决方案的结构及实现策略的结构，这提供了解决方案的静态视图。  
时序图（或交互图）。我们使用这类图表展示解决方案或策略中不同参与者间的交互，这提供了解决方案的动态视图。  
构造型。我们通过构造型标注类和交互图中不同类型的对象与角色，其具体含义详见表6-5。

Each pattern in the pattern catalog includes a class diagram that shows the structure of the solution and a sequence diagram that shows the interactions for the pattern. In addition, patterns with multiple strategies use class and sequence diagrams to explain each strategy.  

模式目录中的每个模式均包含展示解决方案结构的类图，以及描述模式交互行为的时序图。对于采用多策略的模式，还会通过类图和时序图分别阐释各策略的实现机制。

To learn more about UML, please see the Bibliography.  

要了解更多关于UML的信息，请参阅参考文献。

# UML Stereotypes  

While reading the patterns and their diagrams, you will encounter certain stereotypes. Stereotypes are terms coined or used by designers and architects. We created and used these stereotypes in order to present the diagrams in a concise and easy to understand manner. Note that some of the stereotypes relate to the terminology explained in the previous section.  

在阅读模式及其图示时，您会遇到某些**构造型**（Stereotype）。构造型是设计师和架构师创造或使用的特定术语。我们创建并运用这些构造型，旨在以简洁易懂的方式呈现图示。需注意，部分构造型与前一节阐述的术语体系相关联。

<html><body><table><tr><td colspan="2">Table6-5.UMLStereotypes</td></tr><tr><td>Stereotype</td><td>Meaning</td></tr><tr><td>EJB</td><td>Represents an enterprise bean component; associated with a business object. This is a role that is usually fulfilled by a session or entity bean.</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表6-5 UML构造型</td></tr><tr><td>构造型</td><td>含义</td></tr><tr><td>EJB</td><td>表示企业级Bean组件，通常与业务对象关联。该角色通常由会话Bean或实体Bean实现。</td></tr></table></body></html>

<html><body><table><tr><td></td><td>SessionEJB Represents a sessionbean as a wholewithout specifying the session bean remote interface, home interface, or the bean implementation.</td></tr><tr><td>EntityEJB</td><td>remote interface, home interface, the bean implementation, or the primarykey.</td></tr><tr><td>View</td><td>A View represents and displays information to the client.</td></tr><tr><td>JSP</td><td></td></tr><tr><td>Servlet</td><td>A Java servlet; a Controller is typically implemented as a Servlet.</td></tr><tr><td>Singleton</td><td>Aclass that has asingleinstanceinaccordance withthe Singleton pattern.</td></tr><tr><td>Custom Tag</td><td> s  i    s  JavaBeans.A Helper isresponsiblefor such activities as gatheringdata required by the View and for adapting this data model for use by the View. Helpers can service requests for data from the View by simply providing access to the raw data or by formatting the data as Web content.</td></tr></table></body></html>  

<html><body><table><tr><td></td><td>SessionEJB 表示整个会话Bean，无需指定会话Bean的远程接口、主接口或Bean实现。</td></tr><tr><td>EntityEJB</td><td>远程接口、主接口、Bean实现或主键。</td></tr><tr><td>View</td><td>视图负责向客户端表示和展示信息。</td></tr><tr><td>JSP</td><td></td></tr><tr><td>Servlet</td><td>Java Servlet；控制器通常以Servlet形式实现。</td></tr><tr><td>Singleton</td><td>遵循单例模式的类，确保仅存在单一实例。</td></tr><tr><td>Custom Tag</td><td>作为JavaBeans的辅助组件。Helper负责收集视图所需数据，并将数据模型适配为视图可用的格式。Helper可通过直接提供原始数据访问，或将数据格式化为Web内容，来满足视图的数据请求。</td></tr></table></body></html>

# Pattern Template  

The J2EE patterns are all structured according to a defined pattern template. The pattern template consists of sections presenting various attributes for a given pattern. You'll also notice that we've tried to give each J2EE pattern a descriptive pattern name. While it is difficult to fully encompass a single pattern in its name, the pattern names are intended to provide sufficient insight into the function of the pattern. Just as with names in real life, those assigned to patterns affect how the reader will interpret and eventually use that pattern.  

J2EE模式均按照既定的模式模板进行结构化组织。该模板包含多个章节，分别呈现特定模式的各种属性特征。您还会注意到，我们为每个J2EE模式都赋予了具有描述性的模式名称。虽然很难通过名称完全概括某个模式的全部内涵，但这些命名旨在让读者能够充分理解模式的核心功能。正如现实生活中的命名规则，赋予模式的名称将直接影响读者对模式的理解方式及最终应用实践。

We have adopted a pattern template that consists of the following sections:  

我们采用的模式模板包含以下部分：

Context:  Sets the environment under which the pattern exists.   
• Problem:  Describes the design issues faced by the developer.   
• Forces:  Lists the reasons and motivations that affect the problem and the solution. The list of forces highlights the reasons why one might choose to use the pattern and provides a justification for using the pattern. Solution:  Describes the solution approach briefly and the solution elements in detail. The solution section contains two subsections: o Structure:  Uses UML class diagrams to show the basic structure of the solution. The UML Sequence diagrams in this section present the dynamic mechanisms of the solution. There is a detailed explanation of the participants and collaborations. o Strategies:  Describes different ways a pattern may be implemented. Please see “Patterns Versus Strategies” to gain a better understanding of strategies. Where a strategy can be demonstated  

上下文：设定该模式存在的环境。  
• 问题：描述开发者面临的设计难题。  
• 影响因素：列出影响问题及解决方案的动因和理由。这些因素阐明了选用该模式的依据，并为模式的应用提供合理性支撑。  
解决方案：简要描述解决思路并详细说明解决方案要素。该部分包含两个子章节：  
  ○ 结构：通过UML类图展示解决方案的基础结构。本节中的UML时序图呈现解决方案的动态机制，包含对参与要素及其协作关系的详细说明。  
  ○ 策略：描述模式的不同实现方式。请参阅"模式与策略"以深入理解策略概念。此处可展示具体策略的实践案例。

using code, we include a code snippet in this section. If the code is more elaborate and lengthier than a snippet, we include it in the “Sample Code” section of the pattern template.  

在代码部分，我们会包含一个代码片段。如果代码比片段更复杂冗长，则将其放在模式模板的“示例代码”章节中。

Consequences:  Here we describe the pattern trade-offs. Generally, this section focuses on the results of using a particular pattern or its strategy, and notes the pros and cons that may result from the application of the pattern.   
Sample Code:  This section includes example implementations and code listings for the patterns and the strategies. This section is rendered optional if code samples can be adequately included with the discussion in the “Strategies” section.   
Related Patterns:  This section lists other relevant patterns in the J2EE Pattern Catalog or from other external resources, such as the GoF design patterns. For each related pattern, there is a brief description of its   
relationship to the pattern being described.  

**后果**：本节描述模式的权衡取舍，主要阐述采用特定模式或策略所产生的结果，并指出应用该模式可能带来的优缺点。  

**示例代码**：本节包含模式及策略的示例实现和代码清单。若代码示例能充分融入“策略”章节的讨论中，则该部分可省略。  

**相关模式**：本节列出J2EE模式目录或其他外部资源（如GoF设计模式）中的相关模式，并简要说明其与当前描述模式的关联性。

# J2EE Pattern Relationships  

A recent focus group of architects and designers raised a major concern: There seems to be a lack of understanding of how to apply patterns in combination to form larger solutions. We address this problem with a high-level visual of the patterns and their relationships. This diagram is called the J2EE Pattern Relationships Diagram and is shown in Figure 6.2. In Epilogue “J2EE Patterns Applied,” we explore example use cases to demonstrate how many patterns come together to form a patterns framework to realize a use case.  

近期一个由架构师和设计师组成的焦点小组提出了一个重要问题：业界普遍缺乏对如何组合应用模式以构建更大规模解决方案的理解。我们通过高阶模式关系可视化图表来解决这一问题，该图表称为**J2EE模式关系图**（见图6.2）。在附录《J2EE模式实战》中，我们将通过示例用例来演示多个模式如何协同形成模式框架，最终实现具体用例。

Individual patterns offer their context, problem, and solution when addressing a particular need. However, it is important to step back and grasp the big picture to put the patterns to their best use. This grasping the big picture results in better application of the patterns in a J2EE application.  

单个模式在解决特定需求时会提供其上下文、问题及解决方案。然而，退一步把握整体架构对于充分发挥模式效用至关重要。这种全局视角能促使**J2EE**应用中更精准地运用模式。

Reiterating Christopher Alexander's quote from Chapter 1, a pattern does not exist in isolation and needs the support of other patterns to bring meaning and usefulness. Virtually every pattern in the catalog has a relationship to other patterns. Understanding these relationships when designing and architecting a solution helps in the following ways:  

重申第一章中克里斯托弗·亚历山大的观点：模式并非孤立存在，需要其他模式的支持才能体现其意义和价值。本目录中几乎每个模式都与其他模式存在关联。在设计和架构解决方案时，理解这些关联关系具有以下优势：

Enables you to consider what other new problems may be introduced when you consider applying a pattern to solve your problem. This is the domino effect: What new problems are introduced when a particular pattern is introduced into the architecture? It is critical to identify these conflicts before coding begins. Enables you to revisit the pattern relationships to determine alternate solutions. After possible problems are identified, revisit the pattern  

让你在考虑应用模式解决问题时，能够评估可能引入的其他新问题。这就是多米诺效应：当特定模式被引入架构时，会引发哪些新问题？在编码开始前识别这些冲突至关重要。通过重新审视模式关系，你可以探索替代解决方案。在识别潜在问题后，需重新评估模式选择。

relationships and collect alternate solutions. Perhaps the new problems can be addressed by selecting a different pattern or by using another pattern in combination with the one you have already chosen.  

关系并收集替代解决方案。或许可以通过选择不同的模式，或是将已有模式与其他模式组合使用来解决新出现的问题。

Figure 6.2 shows the relationships between the patterns.  

图6.2展示了这些模式之间的关系。

Intercepting Filter intercepts incoming requests and outgoing responses and applies a filter. These filters may be added and removed in a declarative manner, allowing them to be applied unobtrusively in a variety of combinations. After this preprocessing and/or post-processing is complete, the final filter in the group vectors control to the original target object. For an incoming request, this is often a Front Controller, but may be a View.  

拦截过滤器（Intercepting Filter）会拦截传入的请求和传出的响应，并应用过滤器。这些过滤器可以通过声明式的方式添加或移除，从而以非侵入式的方式实现多种组合应用。当预处理和/或后处理完成后，过滤器组中的最后一个过滤器会将控制权转交给原始目标对象。对于传入请求而言，目标对象通常是前端控制器（Front Controller），但也可能是视图（View）。

Front Controller is a container to hold the common processing logic that occurs within the presentation tier and that may otherwise be erroneously placed in a View. A controller handles requests and manages content retrieval, security, view management, and navigation, delegating to a Dispatcher component to dispatch to a View.  

前端控制器是一个容器，用于封装表现层中的通用处理逻辑，这些逻辑若不加处理可能会被错误地放置在视图中。控制器负责处理请求并管理内容检索、安全性、视图管理和导航，同时委托给分发器组件来调度视图。

View Helper encourages the separation of formatting-related code from other business logic. It suggests using Helper components to encapsulate logic relating to initiating content retrieval, validation, and adapting and formatting the model. The View component is then left to encapsulate the presentation formatting. Helper components typically delegate to the Business Services via a Business Delegate, while a View may be composed of multiple subcomponents to create its template.  

视图助手（View Helper）模式提倡将与格式相关的代码与其他业务逻辑分离。该模式建议使用助手组件来封装涉及内容检索初始化、验证以及模型适配与格式化的逻辑，而视图组件则专注于封装呈现层格式化。助手组件通常通过业务委托（Business Delegate）调用业务服务，而视图可能由多个子组件组合构成其模板。

Composite View suggests composing a View from numerous atomic pieces. Multiple smaller views, both static and dynamic, are pieced together to create a single template.  

组合视图（Composite View）建议通过多个原子化组件来构建视图。将多个静态和动态的小型视图组合起来，最终形成一个统一的模板。

Business Delegate reduces coupling between tiers and provides an entry point for accessing the services that are provided by another tier. The Delegate may also provide results caching for common requests to improve performance. A Business Delegate typically uses a Service Locator to locate service objects, such as an EJB Home object and JMS Connection factory.  

业务委托模式降低了各层之间的耦合度，并为访问其他层提供的服务提供了入口点。该委托器还可对常见请求提供结果缓存以提升性能。业务委托器通常通过服务定位器查找服务对象，例如EJB Home对象和JMS连接工厂。

The Service to Worker and Dispatcher View patterns represent a common combination of other patterns from the catalog. The two patterns share a common structure, consisting of a controller working with a Dispatcher, Views, and Helpers. The Service to Worker and the Dispatcher View patterns are identical with respect to the components involved, but differ in the division of labor among those components. Unlike the Service to Worker pattern, the Dispatcher View pattern suggests deferring content retrieval and error handling to the time of View Processing. Also, the Dispatcher View pattern suggests the Dispatcher plays a more limited role in View Management, as the choice of View is typically already included in the request.  

**服务工作者模式**与**调度器视图模式**代表了模式目录中其他模式的常见组合。这两种模式共享相同的结构，均由控制器与调度器、视图及助手组件协同工作构成。服务工作者模式与调度器视图模式在涉及组件方面完全一致，但各组件间的职责划分存在差异。与服务工作者模式不同，调度器视图模式建议将内容检索与错误处理延迟至视图处理阶段执行。此外，调度器视图模式主张调度器在视图管理中的作用更为有限，因为视图选择通常已包含在请求中。

The Session Façade provides coarse-grained services to the clients by hiding the complexities of the business object interactions. The Session Façade may use the Service Locator pattern to locate services. The Session façade may also use other patterns to provide its services: Value Object, Value Object Assembler, Value List Handler, Service Activator, and Data Access Object.  

会话门面（Session Façade）通过隐藏业务对象交互的复杂性，向客户端提供粗粒度服务。该模式可采用**服务定位器模式**（Service Locator）来定位服务，同时可能结合以下模式实现功能：**值对象**（Value Object）、**值对象组装器**（Value Object Assembler）、**值列表处理器**（Value List Handler）、**服务激活器**（Service Activator）以及**数据访问对象**（Data Access Object）。

The Value Object pattern provides the best techniques and strategies to exchange data across tiers (that is, across system boundaries). This pattern attempts to reduce the network overhead by minimizing the number of network calls to get data from the business tier.  

**值对象模式**提供了跨层（即跨系统边界）交换数据的最佳技术和策略。该模式通过减少从业务层获取数据的网络调用次数，从而降低网络开销。

The Value Object Assembler constructs a composite value object from various sources. These sources could be EJB components, Data Access Objects, or other arbitrary Java objects. This pattern is most useful when the client needs to obtain data for the application model or part of the model.  

值对象组装器（Value Object Assembler）从多个数据源构建复合值对象。这些数据源可以是EJB组件、数据访问对象或其他任意Java对象。当客户端需要为应用模型或部分模型获取数据时，该模式最为实用。

The Value List Handler uses the GoF iterator pattern to provide query execution and processing services. The Value List Handler may also cache the results and return subsets of the result to the clients as requested. By using this pattern, it is possible to avoid overheads associated with finding large numbers of entity beans.  

值列表处理器采用GoF迭代器模式来提供查询执行与处理服务。该处理器还可缓存结果集，并根据客户端请求返回结果的子集。通过运用此模式，能够有效规避查找大量实体Bean所带来的性能开销。

The Composite Entity pattern groups parent-dependent objects into a coarse grained entity bean. It shows how to aggregate objects into a tree with a parent object that manages its dependent objects.  

组合实体模式将依赖父对象的对象组合成粗粒度的实体Bean。该模式展示了如何将对象聚合成树形结构，由父对象管理其依赖的子对象。

The Service Activator pattern enables asynchronous processing for enterprise bean components. The EJB specification version 2.0 defines a new type of enterprise bean called message-driven bean that provides similar functionality. However, this pattern can be leveraged by all EJB applications that have a need for asynchronous processing with enterprise bean components.  

服务激活器模式为企业级Bean组件提供了异步处理能力。EJB 2.0规范定义了一种新型企业级Bean——消息驱动Bean（message-driven bean），其功能与此类似。但该模式可被所有需要对企业级Bean组件进行异步处理的EJB应用程序所采用。

The Data Access Object pattern provides loose coupling between the business and resource tiers for enterprise beans that use bean-managed persistence. The Data Access Object intercepts and services all access to the resource tier, making the implementation details of the resource tiers transparent to the clients. The data in the resource tier can reside in database systems, proprietary systems, other external systems and services. By using this pattern, you can build applications that are more flexible and portable.  

数据访问对象（DAO）模式为采用Bean管理持久化的企业级Bean提供了业务层与资源层之间的松耦合。该模式会拦截并处理所有对资源层的访问，使得资源层的实现细节对客户端透明。资源层中的数据可驻留在数据库系统、专有系统或其他外部系统与服务中。通过采用此模式，能够构建更具灵活性和可移植性的应用程序。

# Relationship to Known Patterns  

There is a wealth of software pattern documentation available today. The patterns in these different books are at various levels of abstraction. There are architecture patterns, design patterns, analysis patterns, and programming patterns. The most popular and influential of these books is Design Patterns: Elements of Reusable  

当今已有大量软件模式文档可供参考。这些不同书籍中的模式处于不同的抽象层次，包括架构模式、设计模式、分析模式和编程模式。其中最具影响力和广泛传播的当属《设计模式：可复用面向对象软件的基础》。

Object-Oriented Software, [GoF] better known as the Gang of Four, or GoF book.   
The patterns in the GoF book describe expert solutions for object design.  

面向对象软件设计经典著作《[GoF]》（更广为人知的名称是“四人帮”或GoF书籍）。  
GoF书中描述的模式为对象设计提供了专家级解决方案。

Our pattern catalog includes patterns that describe the structure of an application and others that describe design elements.  

我们的模式目录包含描述应用程序结构的模式，以及描述设计元素的模式。

The unifying theme of the pattern catalog is its support of the J2EE platform. In some cases, the patterns in the catalog are based on or related to an existing pattern in the literature. In these cases, we communicate this relationship by referencing the existing pattern in the name of the J2EE pattern and/or including a reference and citation in the “Related Patterns” section at the end of each pattern description. For example, some patterns are based on GoF patterns but are considered in a J2EE context. In those cases, the J2EE pattern name includes the GoF pattern name as well as a reference to the GoF pattern in the related patterns section.  

该模式目录的核心主题是对J2EE平台的支持。在某些情况下，目录中的模式基于或关联于现有文献中的模式。对于这类情况，我们通过在J2EE模式名称中引用现有模式，或在每个模式描述末尾的"相关模式"章节添加参考文献来体现这种关联。例如，部分模式基于GoF模式但置于J2EE语境中考量，此时J2EE模式名称会包含GoF模式名称，并在相关模式章节注明GoF模式的引用。

# Patterns Roadmap  

Here we present a list of common requirements that architects encounter when creating solutions with the J2EE. We present the requirement or motivation in a brief statement, followed by a list of one or more patterns addressing that requirement. While this requirements list is not exhaustive, we hope that it helps you to quickly identify the relevant patterns based on your needs.  

以下列举了架构师在使用J2EE构建解决方案时常见的需求。我们以简明陈述的方式呈现需求背景，随后列出满足该需求的一个或多个模式。尽管这份需求清单并非详尽无遗，但希望能帮助您根据实际需要快速定位相关模式。

Table 6-6 shows the functions typically handled by the presentation tier patterns and indicates which pattern provides a solution.  

表6-6列出了通常由表示层模式处理的各项功能，并标注了各功能对应的解决方案模式。

<html><body><table><tr><td colspan="3">Table 6-6. Presentation Tier Patterns</td></tr><tr><td>If you are looking for this</td><td>Find it here</td><td></td></tr><tr><td>Preprocessing or post-processing"Intercepting Filter' of your requests</td><td></td><td>Pattern</td></tr><tr><td>handling</td><td>Filter"</td><td>Pattern</td></tr><tr><td>Adding logging，debugging，( some other behavior  to completed for each request</td><td>or"Front Controller", "Intercepting beFilter"</td><td>Pattern</td></tr><tr><td>Creating a generic interface for delegating processing from controller  to helper components</td><td>commandFront Controller"</td><td>Pattern</td></tr></table></body></html>  

<html><body><table><tr><td colspan="3">表6-6. 表示层模式</td></tr><tr><td>如需实现以下功能</td><td>请参阅此模式</td><td></td></tr><tr><td>请求的预处理或后处理（"拦截过滤器"）</td><td></td><td>模式</td></tr><tr><td>请求处理</td><td>"过滤器"</td><td>模式</td></tr><tr><td>为每个请求添加日志记录、调试或其他行为</td><td>"前端控制器"或"拦截过滤器"</td><td>模式</td></tr><tr><td>创建通用接口以便将处理从控制器委派给辅助组件</td><td>"前端控制器"</td><td>模式</td></tr></table></body></html>

<html><body><table><tr><td>Whether to implement Controller as aservlet or JSP</td><td>your"Front Controller"</td><td>Pattern</td></tr><tr><td>Creating a View from numerous"Composite View" sub-Views</td><td></td><td>Pattern</td></tr><tr><td>Whether to implement your View"View Helper" as a servlet or JSP</td><td></td><td>Pattern</td></tr><tr><td>How to partition your View and"View Helper" Model</td><td></td><td>Pattern</td></tr><tr><td>Where to encapsulate presentation-related data formatting logic</td><td>your"View Helper"</td><td>Pattern</td></tr><tr><td>Whether to implement your Helper components as JavaBeans or Custom tags</td><td>"ViewHelper"</td><td>Pattern</td></tr><tr><td>Combining multiple presentation patterns</td><td>"Service to Worker", "DispatcherPattern View"</td><td></td></tr><tr><td>Where to encapsulate Management and Navigation logic, View" whichinvolves choosing a View and dispatching to it</td><td>View"Service to Worker", "Dispatcher Pattern</td><td></td></tr><tr><td>Where to store session state Controlling 　client access to a</td><td>"Session State on SessionStatein thePresentation Tier", and "Storing State on the Business Tier"</td><td>Client", Design</td></tr><tr><td>certainView or sub-View</td><td>`Controlling Client Access"</td><td>Design</td></tr><tr><td>Controlling the flow of requests</td><td>"HideResourceFromaClient" s"Duplicate Form Submissions"</td><td>Refactoring</td></tr><tr><td>into the application</td><td></td><td>Design</td></tr><tr><td>Controlling duplicate form"</td><td>"Introduce Synchronizer Token' "Duplicate Form Submissions"</td><td>Refactoring</td></tr><tr><td>submissions</td><td></td><td>Design</td></tr><tr><td>Design issues using JSP standard</td><td>"Introduce Synchronizer Token" Helper Properties-Integrity and</td><td>refactoring Refactoring</td></tr><tr><td>property auto-population mechanism via <jsp:setProperty> Reducing coupling between</td><td>Consistency" "HidePresentation Tier-Specific</td><td>Design</td></tr><tr><td>presentation tier and business tier</td><td>Details From the Business Tier" "IntroduceBusinessDelegate"</td><td></td></tr><tr><td>Partitioning Data Access Code</td><td>Separate Data Access Code"</td><td>Refactoring</td></tr></table></body></html>  

<html><body><table><tr><td>将Controller实现为Servlet还是JSP</td><td>你的"前端控制器"</td><td>模式</td></tr><tr><td>从多个"组合视图"子视图创建视图</td><td></td><td>模式</td></tr><tr><td>将"视图助手"实现为Servlet还是JSP</td><td></td><td>模式</td></tr><tr><td>如何划分视图与"视图助手"模型</td><td></td><td>模式</td></tr><tr><td>在何处封装与呈现相关的数据格式化逻辑</td><td>你的"视图助手"</td><td>模式</td></tr><tr><td>将助手组件实现为JavaBean还是自定义标签</td><td>"视图助手"</td><td>模式</td></tr><tr><td>组合多种呈现模式</td><td>"服务到工作者"、"分发器视图模式"</td><td></td></tr><tr><td>在何处封装视图管理和导航逻辑（涉及选择视图并分发）</td><td>视图"服务到工作者"、"分发器模式"</td><td></td></tr><tr><td>会话状态存储位置控制客户端访问</td><td>"表示层会话状态"与"业务层状态存储"</td><td>客户端设计</td></tr><tr><td>特定视图或子视图</td><td>`控制客户端访问"</td><td>设计</td></tr><tr><td>控制请求流</td><td>"对客户端隐藏资源"与"重复表单提交"</td><td>重构</td></tr><tr><td>进入应用程序</td><td></td><td>设计</td></tr><tr><td>控制重复表单</td><td>"引入同步令牌"与"重复表单提交"</td><td>重构</td></tr><tr><td>提交</td><td></td><td>设计</td></tr><tr><td>使用JSP标准的设计问题</td><td>"引入同步令牌"助手属性-完整性与</td><td>重构</td></tr><tr><td>通过<jsp:setProperty>实现的属性自动填充机制 降低</td><td>一致性" "对业务层隐藏</td><td>设计</td></tr><tr><td>表示层与业务层的耦合</td><td>表示层特定细节" "引入业务委托"</td><td></td></tr><tr><td>划分数据访问代码</td><td>"分离数据访问代码"</td><td>重构</td></tr></table></body></html>

Table 6-7 shows the functions handled by the business tier patterns and indicates where you can find the particular pattern or patterns that may provide solutions.   

表6-7列出了业务层模式所处理的各项功能，并标注了可提供解决方案的特定模式所在章节。


<html><body><table><tr><td colspan="3">Table 6-7. Business Tier Patterns</td></tr><tr><td>Ifyou arelookingfor this</td><td>Find it here</td><td></td></tr><tr><td>Minimize coupling between presentation andBusiness Delegate"</td><td></td><td>Pattern</td></tr><tr><td>business tiers Cache business services for clients</td><td>"Business Delegate"</td><td>Pattern</td></tr><tr><td>Hide implementation details of business"Business service lookup/creation/access</td><td>Delegate" "Service Locator"</td><td>Pattern</td></tr><tr><td>Isolate vendor and technology dependencies for services lookup</td><td>s"Service Locator"</td><td>Pattern</td></tr><tr><td>Provide uniform method for business service"Service Locator" lookup and creation</td><td></td><td>Pattern</td></tr><tr><td>enterprise bean and JMS component lookup</td><td></td><td>Pattern</td></tr><tr><td>Transfer data between business objects and"Value Object" clients across tiers</td><td></td><td>Pattern</td></tr><tr><td>Minimize code duplication between entity"Value Object" beans and Value Object classes</td><td></td><td>Pattern</td></tr><tr><td>Provide simpler uniform interface to clients</td><td>Business Delegate"</td><td>Pattern</td></tr><tr><td>Reduce remote method invocations by providing coarse-grained method access to business tier components</td><td>SessionFacade"</td><td>Pattern</td></tr><tr><td>Manage erelationships sbetween bean components and hide the complexity of interactions</td><td>enterprise"Session Facade"</td><td>Pattern</td></tr><tr><td>Protect the business tier components fromSession direct exposure to clients</td><td>Facade", "Business Delegate"</td><td>Pattern</td></tr><tr><td>Provide uniform boundary access to business "Session Facade" tier components</td><td></td><td>Pattern</td></tr><tr><td>Design complex entity beans</td><td>"Composite Entity"</td><td>Pattern</td></tr><tr><td>Identify coarse-grained objects dependent objects for entity bean design</td><td>and"Composite Entity"</td><td>Pattern</td></tr><tr><td>Design for coarse-grained entity beans</td><td>"Composite Entity"</td><td>Pattern</td></tr><tr><td>Reduce or eliminate the entity bean clients'</td><td>"CompositeEntity"</td><td>Pattern</td></tr><tr><td>dependency on the database schema Reduce or eliminate entity bean to entity bean"Composite</td><td>Entity",</td><td>,Pattern</td></tr></table></body></html>  

<html><body><table><tr><td colspan="3">表6-7. 业务层模式</td></tr><tr><td>若需实现以下目标</td><td>请参阅此模式</td><td></td></tr><tr><td>最小化表示层与业务层间的耦合</td><td>"Business Delegate"</td><td>模式</td></tr><tr><td>为客户端缓存业务服务</td><td>"Business Delegate"</td><td>模式</td></tr><tr><td>隐藏业务服务的实现细节</td><td>"Service Locator"</td><td>模式</td></tr><tr><td>隔离服务查找的厂商与技术依赖</td><td>"Service Locator"</td><td>模式</td></tr><tr><td>提供统一的业务服务查找与创建方法</td><td>"Service Locator"</td><td>模式</td></tr><tr><td>企业级Bean和JMS组件查找</td><td>"Service Locator"</td><td>模式</td></tr><tr><td>跨层传输业务对象与客户端间的数据</td><td>"Value Object"</td><td>模式</td></tr><tr><td>最小化实体Bean与值对象类间的代码重复</td><td>"Value Object"</td><td>模式</td></tr><tr><td>为客户端提供更简洁的统一接口</td><td>"Business Delegate"</td><td>模式</td></tr><tr><td>通过粗粒度方法访问减少业务层组件的远程调用</td><td>"Session Facade"</td><td>模式</td></tr><tr><td>管理Bean组件间关系并隐藏交互复杂性</td><td>"Session Facade"</td><td>模式</td></tr><tr><td>避免业务层组件直接暴露给客户端</td><td>"Session Facade", "Business Delegate"</td><td>模式</td></tr><tr><td>提供对业务层组件的统一边界访问</td><td>"Session Facade"</td><td>模式</td></tr><tr><td>设计复杂实体Bean</td><td>"Composite Entity"</td><td>模式</td></tr><tr><td>识别实体Bean设计中的粗粒度对象及其依赖对象</td><td>"Composite Entity"</td><td>模式</td></tr><tr><td>设计粗粒度实体Bean</td><td>"Composite Entity"</td><td>模式</td></tr><tr><td>减少或消除实体Bean客户端对数据库模式的依赖</td><td>"Composite Entity"</td><td>模式</td></tr><tr><td>减少或消除实体Bean间的直接依赖</td><td>"Composite Entity"</td><td>模式</td></tr></table></body></html>

<html><body><table><tr><td>relationships</td><td>`SessionFacade"</td><td></td></tr><tr><td>Reduce number of entity beans and improve"Composite Entity" manageability</td><td></td><td>Pattern</td></tr><tr><td>Obtain the data model for the application from various business tier components</td><td>"Value Object Assembler"</td><td>Pattern</td></tr><tr><td>On the fly construction of the data model</td><td>"Value Object Assembler"</td><td>Pattern</td></tr><tr><td>Hide the complexity of data model construction from the clients</td><td>"Value Object Assembler"</td><td>Pattern</td></tr><tr><td>Provide business tier query and results list"Value List Handler" processing facility</td><td></td><td>Pattern</td></tr><tr><td>Minimize the overhead of using enterprise"Value List Handler" bean finder methods</td><td></td><td>Pattern</td></tr><tr><td>Provide query-results caching for clients on"Value List Handler" the server side with forward and backward navigation</td><td></td><td>Pattern</td></tr><tr><td>Use session beans as business tier facades</td><td>"Session Beans as Business-Tier Facades"</td><td>Design</td></tr><tr><td>Trade-offs between using stateful and statelesssessionbeans</td><td>"Session Bean-Stateless VersusStateful"</td><td>Design</td></tr><tr><td>Provide protection to entity beans from direct client access</td><td>"Wrap Entities With Session"</td><td>Refactoring</td></tr><tr><td>Encapsulate business services to hide the implementation details of the business tier</td><td>"Introduce Business Delegate"</td><td>Refactoring</td></tr><tr><td>Coding business logic in entity beans</td><td>"Business Logic in Entity Beans"</td><td>Design</td></tr><tr><td></td><td>"Move Business Logic to Session"</td><td>Refactoring</td></tr><tr><td>Provide session beans as coarse-grained business services</td><td>"Merge Session Beans"</td><td>Refactoring</td></tr><tr><td></td><td>"Wrap Entities With Session"</td><td>Refactoring</td></tr><tr><td>Minimize and/or eliminate network and container overhead due to entity-bean-to-entity-bean communication</td><td>Eliminate Inter-Entity BeanCommunication"</td><td>Refactoring</td></tr><tr><td>Partitioning Data Access Code</td><td>SeparateDataAccess Code"</td><td>Refactoring</td></tr></table></body></html>  

<html><body><table><tr><td>关系</td><td>`SessionFacade"</td><td></td></tr><tr><td>减少实体Bean数量并提升"组合实体"可管理性</td><td></td><td>模式</td></tr><tr><td>从各业务层组件获取应用数据模型</td><td>"值对象装配器"</td><td>模式</td></tr><tr><td>动态构建数据模型</td><td>"值对象装配器"</td><td>模式</td></tr><tr><td>向客户端隐藏数据模型构建的复杂性</td><td>"值对象装配器"</td><td>模式</td></tr><tr><td>提供业务层查询与结果列表"值列表处理器"处理机制</td><td></td><td>模式</td></tr><tr><td>最小化企业级"值列表处理器"Bean查询方法开销</td><td></td><td>模式</td></tr><tr><td>为服务端客户端提供带前后导航的"值列表处理器"查询结果缓存</td><td></td><td>模式</td></tr><tr><td>将会话Bean作为业务层门面使用</td><td>"会话Bean作为业务层门面"</td><td>设计</td></tr><tr><td>有状态与无状态会话Bean的权衡</td><td>"会话Bean-无状态VS有状态"</td><td>设计</td></tr><tr><td>保护实体Bean免受客户端直接访问</td><td>"用会话封装实体"</td><td>重构</td></tr><tr><td>封装业务服务以隐藏业务层实现细节</td><td>"引入业务委托"</td><td>重构</td></tr><tr><td>在实体Bean中编写业务逻辑</td><td>"实体Bean中的业务逻辑"</td><td>设计</td></tr><tr><td></td><td>"将业务逻辑移至会话层"</td><td>重构</td></tr><tr><td>提供粗粒度业务服务的会话Bean</td><td>"合并会话Bean"</td><td>重构</td></tr><tr><td></td><td>"用会话封装实体"</td><td>重构</td></tr><tr><td>最小化或消除因实体Bean间通信导致的网络与容器开销</td><td>"消除实体Bean间通信"</td><td>重构</td></tr><tr><td>数据访问代码分区</td><td>"分离数据访问代码"</td><td>重构</td></tr></table></body></html>

Table 6-8 shows the functions typically handled by the presentation tier patterns and indicates which pattern provides a solution.  

表6-8列出了通常由表示层模式处理的功能，并指出哪种模式提供了解决方案。

<html><body><table><tr><td colspan="3">Table 6-8. Integration Tier Patterns</td></tr><tr><td>If you are lookingfor this</td><td>Findithere</td><td></td></tr><tr><td>Minimize coupling between business and resource tiers</td><td>"Data Access Object"</td><td>Pattern</td></tr><tr><td>Centralize access to resource tiers</td><td>"Data Access Object"</td><td>Pattern</td></tr><tr><td>Minimize complexity of resource access in business tier components</td><td>`Data Access Object"</td><td>Pattern</td></tr><tr><td>Provide asynchronous processing for enterprise bean components</td><td>Service Activator"</td><td>Pattern</td></tr><tr><td></td><td>'Service Activator"</td><td>Pattern</td></tr></table></body></html>  

<html><body><table><tr><td colspan="3">表6-8. 集成层模式</td></tr><tr><td>如需实现以下目标</td><td>请采用此模式</td><td></td></tr><tr><td>降低业务层与资源层的耦合度</td><td>"数据访问对象"</td><td>模式</td></tr><tr><td>集中管理资源层访问</td><td>"数据访问对象"</td><td>模式</td></tr><tr><td>简化业务层组件的资源访问复杂度</td><td>`数据访问对象"</td><td>模式</td></tr><tr><td>为EJB组件提供异步处理能力</td><td>"服务激活器"</td><td>模式</td></tr><tr><td></td><td>'服务激活器"</td><td>模式</td></tr></table></body></html>

# Summary  

So far, we have seen the basic concepts behind the J2EE patterns, understood the tiers for pattern categorization, explored the relationships between different patterns, and taken a look at the roadmap to help guide you to a particular pattern. In the following chapters, we present the patterns individually. They are grouped into chapters based on the tier into which each has been categorized.  

至此，我们已经了解了J2EE模式的基本概念，理解了模式分类的分层结构，探究了不同模式之间的关系，并浏览了帮助您定位特定模式的路线图。在后续章节中，我们将逐一介绍这些模式。它们按照所属分层类别被归入不同章节。

# Chapter 7. PRESENTATION TIER PATTERNS  

# Topics in This Chapter  

Intercepting Filter   
• Front Controller   
• View Helper   
• Composite View   
• Service to Worker Dispatcher View  

拦截过滤器  
• 前端控制器  
• 视图助手  
• 组合视图  
• 服务至工作者分发器视图

# Intercepting Filter  

# Context  

The presentation-tier request handling mechanism receives many different types of requests, which require varied types of processing. Some requests are simply forwarded to the appropriate handler component, while other requests must be modified, audited, or uncompressed before being further processed.  

表示层请求处理机制会接收多种不同类型的请求，这些请求需要经过多样化的处理流程。部分请求仅需简单转发至对应的处理组件，而其他请求则需在执行后续处理前进行修改、审计或解压操作。

# Problem  

Preprocessing and post-processing of a client Web request and response are required.  

客户端Web请求和响应需要进行预处理和后处理。

When a request enters a Web application, it often must pass several entrance tests prior to the main processing stage. For example,  

当请求进入Web应用程序时，通常需通过多项准入测试才能进入主处理阶段。例如，

Has the client been authenticated?   
• Does the client have a valid session?   
• Is the client's IP address from a trusted network? Does the request path violate any constraints?   
• What encoding does the client use to send the data? Do we support the browser type of the client?  

客户端是否已通过认证？  
• 客户端是否持有有效会话？  
• 客户端的IP地址是否来自可信网络？请求路径是否违反任何约束？  
• 客户端使用何种编码发送数据？我们是否支持该客户端的浏览器类型？

Some of these checks are tests, resulting in a yes or no answer that determines whether processing will continue. Other checks manipulate the incoming data stream into a form suitable for processing.  

部分检查属于测试性质，会产生"是"或"否"的判定结果以决定是否继续执行流程。另一些检查则会对输入数据流进行转换，使其符合处理要求。

The classic solution consists of a series of conditional checks, with any failed check aborting the request. Nested if/else statements are a standard strategy, but this solution leads to code fragility and a copy-and-paste style of programming, because the flow of the filtering and the action of the filters is compiled into the application.  

经典解决方案由一系列条件检查组成，任何检查失败都会中止请求。嵌套的if/else语句是标准策略，但这种方案会导致代码脆弱性和复制粘贴式的编程风格，因为过滤流程和过滤器的行为被硬编码到应用程序中。

The key to solving this problem in a flexible and unobtrusive manner is to have a simple mechanism for adding and removing processing components, in which each component completes a specific filtering action.  

以灵活且非侵入式的方式解决此问题的关键在于，需要一种简单的机制来添加和移除处理组件，其中每个组件完成特定的过滤操作。

# Forces  

Common processing, such as checking the data-encoding scheme or logging information about each request, completes per request. Centralization of common logic is desired.  

公共处理逻辑（例如检查数据编码方案或记录每个请求的信息）需在每个请求中完成。此类通用逻辑应当集中化管理。

Services should be easy to add or remove unobtrusively without affecting existing components, so that they can be used in a variety of combinations, such as  

服务应能轻松添加或移除，且不影响现有组件，以便支持多种组合使用场景，例如

o Logging and authentication $\bigcirc$ Debugging and transformation of output for a specific client o Uncompressing and converting encoding scheme of input  

○ 日志记录与身份验证  
○ 针对特定客户端的调试及输出转换  
○ 输入解压与编码方案转换

# Solution  

Create pluggable filters to process common services in a standard manner without requiring changes to core request processing code. The filters intercept incoming requests and outgoing responses, allowing preprocessing and post-processing. We are able to add and remove these filters unobtrusively, without requiring changes to our existing code.  

创建可插拔过滤器以标准方式处理通用服务，无需修改核心请求处理代码。这些过滤器拦截传入请求和传出响应，实现预处理和后处理功能。我们可以无侵入地添加或移除这些过滤器，而无需修改现有代码。

We are able, in effect, to decorate our main processing with a variety of common services, such as security, logging, debugging, and so forth. These filters are components that are independent of the main application code, and they may be added or removed declaratively. For example, a deployment configuration file may be modified to set up a chain of filters. The same configuration file might include a mapping of specific URLs to this filter chain. When a client requests a resource that matches this configured URL mapping, the filters in the chain are each processed in order before the requested target resource is invoked.  

实际上，我们能够通过多种通用服务（如安全、日志记录、调试等）对主处理逻辑进行装饰。这些过滤器是与主应用代码解耦的独立组件，可通过声明式配置动态添加或移除。例如，可通过修改部署配置文件来建立过滤器链，该配置文件还可包含特定URL与此过滤器链的映射关系。当客户端请求的资源匹配到配置的URL映射时，系统会在调用目标资源前按顺序执行过滤器链中的所有过滤器。

# Structure  

Figure 7.1 represents the Intercepting Filter pattern.  

图7.1展示了拦截过滤器模式。

![](images/15aa7a3eb56e70da11da98d7dbacb447e2186a3a457a096e58ac2c200f1712e4.jpg)  
Figure 7.1. Intercepting Filter pattern class diagram  

图7.1 拦截过滤器模式类图

# Participants and Responsibilities  

Figure 7.2 represents the Intercepting Filter pattern.  

图7.2展示了拦截过滤器模式。

![](images/4d5a5b56da4b902c3db9334f2c604ce6c69c9d88d58a4d0cddb7b0a164f78be7.jpg)  
Figure 7.2. Intercepting Filter sequence diagram  

图7.2 拦截过滤器时序图

# FilterManager  

The FilterManager manages filter processing. It creates the FilterChain with the appropriate filters, in the correct order, and initiates processing.  

FilterManager负责管理过滤器处理流程。它会按照正确的顺序创建包含相应过滤器的FilterChain，并启动处理过程。

# FilterChain  

The FilterChain is an ordered collection of independent filters.  

FilterChain 是一个由独立过滤器组成的有序集合。

# FilterOne, FilterTwo, FilterThree  

These are the individual filters that are mapped to a target. The FilterChain coordinates their processing.  

这些是映射到目标的独立过滤器，由FilterChain协调它们的处理流程。

# Target  

The Target is the resource requested by the client.  

目标是客户端请求的资源。

# Strategies  

# Custom Filter Strategy  

Filter is implemented via a custom strategy defined by the developer. This is less flexible and less powerful than the preferred Standard Filter Strategy, which is presented in the next section and is only available in containers supporting the 2.3 servlet specification. The Custom Filter Strategy is less powerful because it cannot provide for the wrapping of request and response objects in a standard and portable way. Additionally, the request object cannot be modified, and some sort of buffering mechanism must be introduced if filters are to control the output stream. To implement the Custom Filter Strategy, the developer could use the Decorator pattern [GoF] to wrap filters around the core request processing logic. For example, there may be a debugging filter that wraps an authentication filter. Example 7.1 and Example 7.2 show how this mechanism might be created programmatically:  

过滤器通过开发者定义的自定义策略实现。这种方式的灵活性和功能性均逊于下一节介绍的标准过滤器策略，后者仅支持2.3版本Servlet规范的容器可用。自定义过滤器策略的局限性在于：无法以标准化、可移植的方式封装请求和响应对象；请求对象不可修改；若需控制输出流则必须引入缓冲机制。开发者可采用装饰器模式（Decorator pattern [GoF]）将过滤器包裹在核心请求处理逻辑外围来实现该策略，例如用调试过滤器包裹认证过滤器。示例7.1与示例7.2展示了该机制的编程实现方式：

# Example 7.1 Implementing a Filter – Debugging Filter  

public class DebuggingFilter implements Processor { private Processor target;  

public class DebuggingFilter implements Processor { private Processor target;

public DebuggingFilter(Processor myTarget) { target $=$ myTarget;   
public void execute(ServletRequest req, ServletResponse res) throws IOException, ServletException { //Do some filter processing here, such as // displaying request parameters target.execute(req, res);  

public DebuggingFilter(Processor myTarget) { target $=$ myTarget;   
public void execute(ServletRequest req, ServletResponse res) throws IOException, ServletException { //在此执行过滤器处理，例如 // 显示请求参数 target.execute(req, res);

# Example 7.2 Implementing a Filter – Core Processor  

public class CoreProcessor implements Processor { private Processor target; public CoreProcessor() this(null); } public CoreProcessor(Processor myTarget) target $=$ myTarget; public void execute(ServletRequest req, ServletResponse res) throws IOException, ServletException { //Do core processing here  

```java
public class CoreProcessor implements Processor {
    private Processor target;
    public CoreProcessor() this(null);
    public CoreProcessor(Processor myTarget) target = myTarget;
    public void execute(ServletRequest req, ServletResponse res) throws IOException, ServletException {
        //核心处理逻辑在此执行
```

In the servlet controller, we delegate to a method called process-Request to handle incoming requests, as shown in Example 7.3.  

在Servlet控制器中，我们将请求处理委托给名为`processRequest`的方法，如示例7.3所示。

# Example 7.3 Handling Requests  

public void processRequest(ServletRequest req, ServletResponse res) throws IOException, ServletException { Processor processors $=$ new DebuggingFilter( new AuthenticationFilter(new CoreProcessor())); processors.execute(req, res);  

public void processRequest(ServletRequest req, ServletResponse res) throws IOException, ServletException { Processor processors $=$ new DebuggingFilter( new AuthenticationFilter(new CoreProcessor())); processors.execute(req, res);

//Then dispatch to next resource, which is probably // the View to display   
dispatcher.dispatch(req, res);  

// 随后分派至下一资源，通常为待渲染的视图  
dispatcher.dispatch(req, res);

For example purposes only, imagine that each processing component writes to standard output when it is executed. Example 7.4 shows the possible execution output.  

仅为示例用途，假设每个处理组件在执行时都会写入标准输出。示例7.4展示了可能的执行输出结果。

# Example 7.4 Messages Written to Standard Output  

Debugging filter preprocessing completed...   
Authentication filter processing completed...   
Core processing completed...   
Debugging filter post-processing completed...  

调试过滤器预处理完成...  
身份验证过滤器处理完成...  
核心处理完成...  
调试过滤器后处理完成...

A chain of processors is executed in order. Each processor, except for the last one in the chain, is considered a filter. The final processor component is where we encapsulate the core processing we want to complete for each request. Given this design, we will need to change the code in the CoreProcessor class, as well as in any filter classes, when we want to modify how we handle requests.  

处理器链按顺序执行。除链中最后一个处理器外，每个处理器都被视为过滤器。最终的处理器组件封装了我们需要为每个请求完成的核心处理逻辑。基于这种设计，当需要修改请求处理方式时，我们必须调整`CoreProcessor`类以及所有过滤器类的代码。

Figure 7.3 is a sequence diagram describing the flow of control when using the filter code of Example 7.1, Example 7.2, and Example 7.3.  

图7.3是描述使用示例7.1、示例7.2和示例7.3过滤器代码时控制流程的时序图。

![](images/ce88e50579fa454988edbcf811f72ee0f1d29a12c606351dfd97b7fe72346170.jpg)  
Figure 7.3. Sequence diagram for Custom Filter Strategy, decorator implementation  

图7.3 自定义过滤器策略的序列图（装饰器实现）

Notice that when we use a decorator implementation, each filter invokes on the next filter directly, though using a generic interface. Alternatively, this strategy can be implemented using a FilterManager and FilterChain. In this case, these two components coordinate and manage filter processing and the individual filters do not communicate with one another directly. This design approximates that of a servlet 2.3-compliant implementation, though it is still a custom strategy. Example 7.5 is the listing of just such a FilterManager class that creates a FilterChain, which is shown in Example 7.6. The FilterChain adds filters to the chain in the appropriate order (for the sake of brevity, this is done in the FilterChain constructor, but would normally be done in place of the comment), processes the filters, and finally processes the target resource. Figure 7.4 is a sequence diagram for this code.  

请注意，当我们采用装饰器模式实现时，每个过滤器会直接调用下一个过滤器（尽管通过通用接口）。此外，该策略也可通过`FilterManager`和`FilterChain`来实现。此时，这两个组件负责协调和管理过滤器处理流程，而各过滤器之间不再直接交互。该设计近似符合Servlet 2.规范的实现方式，但仍属于自定义策略。示例7.5展示的正是这样一个`FilterManager`类，它会创建如示例7.6所示的`FilterChain`。`FilterChain`会按正确顺序向链中添加过滤器（为简洁起见，此操作在`FilterChain`构造函数中完成，但通常应替换注释处的逻辑），处理过滤器链，最终处理目标资源。图7.4为此代码的时序图。

![](images/8fc332b66097e33feb685a7ffc26e2e23651d3993c22f347c5133427653034a3.jpg)  
Figure 7.4. Sequence diagram for Custom Filter Strategy, nondecorator implementation  

图7.4 自定义过滤器策略的序列图（非装饰器实现）

# Example 7.5 FilterManager–Custom Filter Strategy  

public class FilterManager { public void processFilter(Filter target, javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, java.io.IOException { FilterChain filterChain $=$ new FilterChain();  

public class FilterManager { public void processFilter(Filter target, javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, java.io.IOException { FilterChain filterChain $=$ new FilterChain();

// The filter manager builds the filter chain here  

// 过滤器管理器在此处构建过滤器链

// if necessary   
// Pipe request through Filter Chain   
filterChain.processFilter(request, response); //process target resource   
target.execute(request, response);  

// 如有必要  
// 通过过滤器链传递请求  
filterChain.processFilter(request, response); //处理目标资源  
target.execute(request, response);

# Example 7.6 FilterChain–Custom Filter Strategy  

ublic class FilterChain {   
// filter chain   
private Vector myFilters $=$ new Vector();   
// Creates new FilterChain   
public FilterChain() { // plug-in default filter services for example // only. This would typically be done in the // FilterManager, but is done here for example // purposes addFilter(new DebugFilter()); addFilter(new LoginFilter()); addFilter(new AuditFilter());   
}   
public void processFilter( javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)   
throws javax.servlet.ServletException, java.io.IOException { Filter filter; // apply filters Iterator filters $=$ myFilters.iterator(); while (filters.hasNext()) { filter $=$ (Filter)filters.next(); // pass request & response through various // filters filter.execute(request, response); }   
}  

public class FilterChain {  
// 过滤器链  
private Vector myFilters = new Vector();  
// 创建新的FilterChain  
public FilterChain() {  
    // 仅作为示例插入默认过滤器服务  
    // 通常应在FilterManager中完成，此处仅为示例  
    addFilter(new DebugFilter());  
    addFilter(new LoginFilter());  
    addFilter(new AuditFilter());  
}  

public void processFilter(  
    javax.servlet.http.HttpServletRequest request,  
    javax.servlet.http.HttpServletResponse response)  
    throws javax.servlet.ServletException, java.io.IOException {  
    Filter filter;  
    // 应用过滤器  
    Iterator filters = myFilters.iterator();  
    while (filters.hasNext()) {  
        filter = (Filter)filters.next();  
        // 将请求和响应传递给各个过滤器  
        filter.execute(request, response);  
    }  
}

public void addFilter(Filter filter) { myFilters.add(filter);  

public void addFilter(Filter filter) { myFilters.add(filter);

This strategy does not allow us to create filters that are as flexible or as powerful as we would like. For one, filters are added and removed programmatically. While we could write a proprietary mechanism for handling adding and removing filters via a configuration file, we still would have no way of wrapping the request and response objects. Additionally, without a sophisticated buffering mechanism, this strategy does not provide flexible postprocessing.  

该策略无法让我们创建足够灵活或强大的过滤器。首先，过滤器的添加和移除是通过编程方式实现的。虽然我们可以编写专有机制通过配置文件来管理过滤器的增删，但仍无法对请求和响应对象进行封装。此外，由于缺乏完善的缓冲机制，该策略无法提供灵活的后处理能力。

The Standard Filter Strategy provides solutions to these issues, leveraging features of the 2.3 Servlet specification, which has provided a standard solution to the filter dilemma.  

标准过滤器策略利用2.3 Servlet规范提供的特性解决了这些问题，为过滤器难题提供了标准解决方案。

# Note  

As of this writing, the Servlet 2.3 specification is in final draft form.  

截至本文撰写时，Servlet 2.3 规范已进入最终草案阶段。

# Standard Filter Strategy  

Filters are controlled declaratively using a deployment descriptor, as described in the servlet specification version 2.3, which, as of this writing, is in final draft form. The servlet 2.3 specification includes a standard mechanism for building filter chains and unobtrusively adding and removing filters from those chains. Filters are built around interfaces, and added or removed in a declarative manner by modifying the deployment descriptor for a Web application.  

过滤器通过部署描述符以声明式方式进行控制，具体规范参见Servlet 2.3版本（截至本文撰写时处于最终草案阶段）。该规范提供了一套标准机制用于构建过滤器链，并能以非侵入方式动态增删链中的过滤器。过滤器围绕接口构建，通过修改Web应用的部署描述符即可实现过滤器的声明式添加或移除。

Our example for this strategy will be to create a filter that preprocesses requests of any encoding type such that each request may be handled similarly in our core request handling code. Why might this be necessary? HTML forms that include a file upload use a different encoding type than that of most forms. Thus, form data that accompanies the upload is not available via simple getParameter() invocations. So, we create two filters that preprocess requests, translating all encoding types into a single consistent format. The format we choose is to have all form data available as request attributes.  

本策略的示例将创建一个过滤器，用于预处理任何编码类型的请求，使得核心请求处理代码能以统一方式处理所有请求。为何需要这样做？包含文件上传的HTML表单使用的编码类型与普通表单不同，因此伴随上传的表单数据无法通过简单的`getParameter()`调用获取。为此我们创建两个预处理过滤器，将所有编码类型转换为统一格式——具体实现是将所有表单数据以请求属性的形式暴露。

One filter handles the standard form encoding of type application/x-www-form-urlencoded and the other handles the less common encoding type multipart/form-data, which is used for forms that include file uploads. The filters translate all form data into request attributes, so the core  

一个过滤器处理标准的`application/x-www-form-urlencoded`表单编码类型，另一个则处理较少见的`multipart/form-data`编码类型（用于包含文件上传的表单）。这些过滤器将所有表单数据转换为请求属性，因此核心

request handling mechanism can work with every request in the same manner, instead of with special casing for different encodings.  

请求处理机制能够以统一方式处理所有请求，而无需针对不同编码进行特殊处理。

Example 7.8 shows a filter that translates requests using the common application form encoding scheme. Example 7.9 shows the filter that handles the translation of requests that use the multipart form encoding scheme. The code for these filters is based on the final draft of the servlet specification, version 2.3. A base filter is used as well, from which both of these filters inherit (see the section “Base Filter Strategy”). The base filter, shown in Example 7.7, provides default behavior for the standard filter callback methods.  

示例7.8展示了一个采用通用应用表单编码方案进行请求转码的过滤器。示例7.9则演示了处理多部分表单编码请求转码的过滤器实现。这些过滤器的代码基于Servlet规范2.3版的最终草案。示例7.7所示的基础过滤器作为父类被二者继承（参见"基础过滤器策略"章节），该基础过滤器为标准回调方法提供了默认行为。

# Example 7.7 Base Filter–Standard Filter Strategy  

public class BaseEncodeFilter implements javax.servlet.Filter { private javax.servlet.FilterConfig myFilterConfig; public BaseEncodeFilter() { } public void doFilter( javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse, javax.servlet.FilterChain filterChain) throws java.io.IOException, javax.servlet.ServletException { filterChain.doFilter(servletRequest, servletResponse); public javax.servlet.FilterConfig getFilterConfig() { return myFilterConfig;   
public void setFilterConfig( javax.servlet.FilterConfig filterConfig) { myFilterConfig $=$ filterConfig;  

public class BaseEncodeFilter implements javax.servlet.Filter {  
    private javax.servlet.FilterConfig myFilterConfig;  

    public BaseEncodeFilter() {  
    }  

    public void doFilter(  
        javax.servlet.ServletRequest servletRequest,  
        javax.servlet.ServletResponse servletResponse,  
        javax.servlet.FilterChain filterChain) throws java.io.IOException, javax.servlet.ServletException {  
        filterChain.doFilter(servletRequest, servletResponse);  
    }  

    public javax.servlet.FilterConfig getFilterConfig() {  
        return myFilterConfig;  
    }  

    public void setFilterConfig(javax.servlet.FilterConfig filterConfig) {  
        myFilterConfig = filterConfig;  
    }  
}

# Example 7.8 StandardEncodeFilter–Standard Filter Strategy  

public class StandardEncodeFilter extends BaseEncodeFilter { // Creates new StandardEncodeFilter public StandardEncodeFilter() {  }  

public class StandardEncodeFilter extends BaseEncodeFilter { // 创建新的StandardEncodeFilter  
    public StandardEncodeFilter() {  
    }

public void doFilter(javax.servlet.ServletRequest servletRequest,javax.servlet.ServletResponse servletResponse,javax.servlet.FilterChain filterChain)   
throws java.io.IOException, javax.servlet.ServletException { String contentType $=$ servletRequest.getContentType(); if ((contentType $==$ null) || contentType.equalsIgnoreCase( "application/x-www-form-urlencoded")) { translateParamsToAttributes(servletRequest, servletResponse); filterChain.doFilter(servletRequest, servletResponse);   
}   
private void translateParamsToAttributes(   
ServletRequest request, ServletResponse response)   
{ Enumeration paramNames $=$ request.getParameterNames(); while (paramNames.hasMoreElements()) String paramName $=$ (String) paramNames.nextElement(); String [] values; values $=$ request.getParameterValues(paramName); System.err.println("paramName $=$ " $^+$ paramName); if (values.length $\scriptstyle==\_1$ )  

public void doFilter(javax.servlet.ServletRequest servletRequest,javax.servlet.ServletResponse servletResponse,javax.servlet.FilterChain filterChain)   
throws java.io.IOException, javax.servlet.ServletException { String contentType = servletRequest.getContentType(); if ((contentType == null) || contentType.equalsIgnoreCase( "application/x-www-form-urlencoded")) { translateParamsToAttributes(servletRequest, servletResponse); filterChain.doFilter(servletRequest, servletResponse);   
}   
private void translateParamsToAttributes(   
ServletRequest request, ServletResponse response)   
{ Enumeration paramNames = request.getParameterNames(); while (paramNames.hasMoreElements()) String paramName = (String) paramNames.nextElement(); String [] values; values = request.getParameterValues(paramName); System.err.println("paramName = " + paramName); if (values.length == 1 )  

（注：根据用户规则第3条，代码块保持原样不翻译，仅修正了原文中的符号错误）

request.setAttribute(paramName, values[0]); else request.setAttribute(paramName, values);  

request.setAttribute(paramName, values[0]); 否则 request.setAttribute(paramName, values);

# Example 7.9 MultipartEncodeFilter–Standard Filter Strategy  

ublic class MultipartEncodeFilter extends   
BaseEncodeFilter {   
public MultipartEncodeFilter() { }   
public void doFilter(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse,javax.servlet.FilterChain filterChain)   
throws java.io.IOException, javax.servlet.ServletException { String contentType $=$ servletRequest.getContentType(); // Only filter this request if it is multipart // encoding if (contentType.startsWith( "multipart/form-data")){ try { String uploadFolder $=$ getFilterConfig().getInitParameter( "UploadFolder"); if (uploadFolder $==$ null) uploadFolder $=$ /\*\* The MultipartRequest class is: $\star$ Copyright (C) 2001 by Jason Hunter $\star$ <jhunter@servlets.com>. All rights reserved. \*\*/ MultipartRequest multi $=$ new MultipartRequest(servletRequest, uploadFolder, $\frac{1}{\mid}~\star~1024\star1024);$ Enumeration params $=$ multi.getParameterNames(); while (params.hasMoreElements()) { String name $=$ (String)params.nextElement(); String value $=$ multi.getParameter(name);   
servletRequest.setAttribute(name, value);  

public class MultipartEncodeFilter extends   
BaseEncodeFilter {   
public MultipartEncodeFilter() { }   
public void doFilter(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse,javax.servlet.FilterChain filterChain)   
throws java.io.IOException, javax.servlet.ServletException { String contentType $=$ servletRequest.getContentType(); // 仅当请求为multipart编码时才进行过滤 if (contentType.startsWith( "multipart/form-data")){ try { String uploadFolder $=$ getFilterConfig().getInitParameter( "UploadFolder"); if (uploadFolder $==$ null) uploadFolder $=$ /\*\* MultipartRequest类声明: $\star$ 版权所有(C) 2001 Jason Hunter $\star$ <jhunter@servlets.com> 保留所有权利 \*\*/ MultipartRequest multi $=$ new MultipartRequest(servletRequest, uploadFolder, $\frac{1}{\mid}~\star~1024\star1024);$ Enumeration params $=$ multi.getParameterNames(); while (params.hasMoreElements()) { String name $=$ (String)params.nextElement(); String value $=$ multi.getParameter(name);   
servletRequest.setAttribute(name, value);

Enumeration files $=$ multi.getFileNames(); while (files.hasMoreElements()) { String name $=$ (String)files.nextElement(); String filename $=$ multi.getFilesystemName(name); String type $=$ multi.getContentType(name); File f $=$ multi.getFile(name); // At this point, do something with the // file, as necessary catch (IOException e) { LogManager.logMessage( "error reading or saving file" $^+$ e); } // end if filterChain.doFilter(servletRequest, servletResponse); } // end method doFilter()  

枚举文件 $=$ multi.getFileNames();  
while (files.hasMoreElements()) {  
    String name $=$ (String)files.nextElement();  
    String filename $=$ multi.getFilesystemName(name);  
    String type $=$ multi.getContentType(name);  
    File f $=$ multi.getFile(name);  
    // 在此处根据需要对文件进行处理  
    catch (IOException e) {  
        LogManager.logMessage(  
            "文件读取或保存错误" $^+$ e);  
    }  
    // end if  
    filterChain.doFilter(servletRequest, servletResponse);  
}  
// end method doFilter()

The following excerpt in Example 7.10 is from the deployment descriptor for the Web application containing this example. It shows how these two filters are registered and then mapped to a resource, in this case a simple test servlet. Additionally, the sequence diagram for this example is shown in Figure 7.5.  

示例7.10中的以下摘录来自包含本示例的Web应用程序部署描述符。它展示了如何注册这两个过滤器并将其映射到资源（本例中是一个简单的测试Servlet）。此外，图7.5展示了本示例的序列图。

# Example 7.10 Deployment Descriptor-Standard Filter Strategy  

<filter> <filter-name>StandardEncodeFilter</filter-name> <display-name>StandardEncodeFilter</display-name> <description></description> <filter-class> corepatterns.filters.encodefilter. StandardEncodeFilter</filter-class>  

<filter>  
<filter-name>StandardEncodeFilter</filter-name>  
<display-name>StandardEncodeFilter</display-name>  
<description></description>  
<filter-class>corepatterns.filters.encodefilter.StandardEncodeFilter</filter-class>

</filter> <filter> <filter-name>MultipartEncodeFilter</filter-name> <display-name>MultipartEncodeFilter</display-name> <description></description> <filter-class>corepatterns.filters.encodefilter. MultipartEncodeFilter</filter-class> <init-param> <param-name>UploadFolder</param-name> <param-value>/home/files</param-value> </init-param> </filter> <filter-mapping> <filter-name $>$ StandardEncodeFilter</filter-name> <url-pattern>/EncodeTestServlet</url-pattern> </filter-mapping> <filter-mapping> <filter-name>MultipartEncodeFilter</filter-name> <url-pattern>/EncodeTestServlet</url-pattern> </filter-mapping>  

</filter>  
<filter>  
    <filter-name>MultipartEncodeFilter</filter-name>  
    <display-name>MultipartEncodeFilter</display-name>  
    <description></description>  
    <filter-class>corepatterns.filters.encodefilter.MultipartEncodeFilter</filter-class>  
    <init-param>  
        <param-name>UploadFolder</param-name>  
        <param-value>/home/files</param-value>  
    </init-param>  
</filter>  

<filter-mapping>  
    <filter-name>StandardEncodeFilter</filter-name>  
    <url-pattern>/EncodeTestServlet</url-pattern>  
</filter-mapping>  

<filter-mapping>  
    <filter-name>MultipartEncodeFilter</filter-name>  
    <url-pattern>/EncodeTestServlet</url-pattern>  
</filter-mapping>

![](images/d738a2240e2068be1c33cc68520038e1638655fd709d7360fc5a5e399b4bfb8e.jpg)  
Figure 7.5. Sequence diagram for Intercepting Filter, Standard Filter Strategy – encoding conversion example  

图7.5 拦截过滤器模式的标准过滤器策略序列图——编码转换示例

The StandardEncodeFilter and the MultiPartEncodeFilter intercept control when a client makes a request to the controller servlet. The container fulfills the role of filter manager and vectors control to these filters by invoking their doFilter methods. After completing its processing, each filter passes control to its containing FilterChain, which it instructs to execute the next filter. Once both of the filters have received and subsequently relinquished control, the next component to receive control is the actual target resource, in this case the controller servlet.  

StandardEncodeFilter与MultiPartEncodeFilter会在客户端向控制器Servlet发起请求时拦截控制流。容器扮演着过滤器管理器的角色，通过调用这些过滤器的doFilter方法将控制流转发给它们。每个过滤器完成处理后，会将控制权传递给其所属的FilterChain，并指示其执行下一个过滤器。当两个过滤器都接收并释放控制权后，下一个获得控制权的组件就是实际的目标资源——本例中的控制器Servlet。

Filters, as supported in version 2.3 of the servlet specification, also support wrapping the request and response objects. This feature provides for a much more powerful mechanism than can be built using the custom implementation suggested by the Custom Filter Strategy. Of course, a hybrid approach combining the two strategies could be custom built as well, but would still lack the power of the Standard Filter Strategy as supported by the servlet specification.  

Servlet 2.3 规范支持的过滤器还支持对请求和响应对象进行包装。该特性提供了比**自定义过滤器策略**建议的自定义实现更强大的机制。当然，也可以定制构建结合这两种策略的混合方案，但仍无法达到Servlet规范支持的**标准过滤器策略**的强大功能。

# Base Filter Strategy  

A base filter serves as a common superclass for all filters. Common features can be encapsulated in the base filter and shared among all filters. For example, a base filter is a good place to include default behavior for the container callback methods in the Declared Filter Strategy. Example 7.11 shows how this can be done.  

基础过滤器作为所有过滤器的公共父类。通用特性可封装在基础过滤器中，供所有过滤器共享。例如，基础过滤器是**声明式过滤器策略**中容器回调方法默认行为的理想实现位置。示例7.11展示了具体实现方式。

# Example 7.11 Base Filter Strategy  

public class BaseEncodeFilter implements javax.servlet.Filter {   
private javax.servlet.FilterConfig myFilterConfig;   
public BaseEncodeFilter() {}   
public void doFilter(javax.servlet.ServletRequest servletRequest,javax.servlet.ServletResponse servletResponse, javax.servlet.FilterChain filterChain) throws java.io.IOException, javax.servlet.ServletException { filterChain.doFilter(servletRequest, servletResponse); public javax.servlet.FilterConfig getFilterConfig() { return myFilterConfig; }   
public void   
setFilterConfig(javax.servlet.FilterConfig filterConfig) { myFilterConfig $=$ filterConfig;  

public class BaseEncodeFilter implements javax.servlet.Filter {  
private javax.servlet.FilterConfig myFilterConfig;  
public BaseEncodeFilter() {}  
public void doFilter(javax.servlet.ServletRequest servletRequest,javax.servlet.ServletResponse servletResponse, javax.servlet.FilterChain filterChain) throws java.io.IOException, javax.servlet.ServletException { filterChain.doFilter(servletRequest, servletResponse); public javax.servlet.FilterConfig getFilterConfig() { return myFilterConfig; }  
public void   
setFilterConfig(javax.servlet.FilterConfig filterConfig) { myFilterConfig $=$ filterConfig;

# Template Filter Strategy  

Using a base filter from which all others inherit (see “Base Filter Strategy” in this chapter) allows the base class to provide template method [Gof] functionality. In this case, the base filter is used to dictate the general steps that every filter must complete, while leaving the specifics of how to complete that step to each filter subclass. Typically, these would be coarsely defined, basic methods that simply impose a limited structure on each template. This strategy can be combined with any other filter strategy, as well. The listings in Example 7.12 and Example 7.13 show how to use this strategy with the Declared Filter Strategy.  

采用一个供所有过滤器继承的基类过滤器（参见本章“基类过滤器策略”），可让基类提供模板方法[Gof]功能。在此方案中，基类过滤器用于规定每个过滤器必须完成的通用步骤，而将具体实现细节交由各过滤器子类完成。通常这些基类方法会进行粗粒度定义，仅对每个模板施加有限的结构约束。该策略亦可与其他任意过滤器策略组合使用。示例7.12和示例7.13的代码清单展示了如何将此策略与声明式过滤器策略结合使用。

Example 7.12 shows a base filter called TemplateFilter, as follows.  

示例7.12展示了一个名为TemplateFilter的基础过滤器，如下所示。

Example 7.12 Using a Template Filter Strategy   
public abstract class TemplateFilter implements javax.servlet.Filter { private FilterConfig filterConfig; public void setFilterConfig(FilterConfig fc) { filterConfig=fc; } public FilterConfig getFilterConfig() { return filterConfig; } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // Common processing for all filters can go here doPreProcessing(request, response, chain); // Common processing for all filters can go here doMainProcessing(request, response, chain); // Common processing for all filters can go here doPostProcessing(request, response, chain); // Common processing for all filters can go here // Pass control to the next filter in the chain or // to the target resource chain.doFilter(request, response); public void doPreProcessing(ServletRequest request, ServletResponse response, FilterChain chain) { public void doPostProcessing(ServletRequest request, ServletResponse response, FilterChain chain) { } public abstract void doMainProcessing(ServletRequest request, ServletResponse response, FilterChain chain);  

示例 7.12 使用模板过滤器策略  
public abstract class TemplateFilter implements javax.servlet.Filter { private FilterConfig filterConfig; public void setFilterConfig(FilterConfig fc) { filterConfig=fc; } public FilterConfig getFilterConfig() { return filterConfig; } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 所有过滤器的通用处理逻辑可置于此处 doPreProcessing(request, response, chain); // 所有过滤器的通用处理逻辑可置于此处 doMainProcessing(request, response, chain); // 所有过滤器的通用处理逻辑可置于此处 doPostProcessing(request, response, chain); // 所有过滤器的通用处理逻辑可置于此处 // 将控制权传递给链中的下一个过滤器或目标资源 chain.doFilter(request, response); public void doPreProcessing(ServletRequest request, ServletResponse response, FilterChain chain) { public void doPostProcessing(ServletRequest request, ServletResponse response, FilterChain chain) { } public abstract void doMainProcessing(ServletRequest request, ServletResponse response, FilterChain chain);

Given this class definition for TemplateFilter, each filter is implemented as a subclass that must only implement the doMainProcessing method. These subclasses have the option, though, of implementing all three methods if they desire. Example 7.13 is an example of a filter subclass that implements the one mandatory method (dictated by our template filter) and the optional preprocessing method. Additionally, a sequence diagram for using this strategy is shown in Figure 7.6.  

根据`TemplateFilter`类的定义，每个过滤器均需通过子类实现，且子类必须仅实现`doMainProcessing`方法。不过这些子类也可选择性地实现全部三个方法。示例7.13展示了一个过滤器子类的实现案例，该子类既实现了模板过滤器规定的必需方法，也实现了可选的预处理方法。图7.6则展示了采用此策略的序列图。

# Example 7.13 Debugging Filter  

public class DebuggingFilter extends TemplateFilter { public void doPreProcessing(ServletRequest req, ServletResponse res, FilterChain chain) { //do some preprocessing here public void doMainProcessing(ServletRequest req, ServletResponse res, FilterChain chain) { //do the main processing;  

public class DebuggingFilter extends TemplateFilter { public void doPreProcessing(ServletRequest req, ServletResponse res, FilterChain chain) { //在此处进行预处理 public void doMainProcessing(ServletRequest req, ServletResponse res, FilterChain chain) { //执行主要处理

![](images/bf7e6f12560d81b335da9d6fef8471cc59af705782e1e4b0168303fbc37cccff.jpg)  
Figure 7.6. Intercepting Filter, Template Filter Strategy sequence diagram  

图7.6 拦截过滤器模式-模板过滤器策略时序图

In the sequence diagram in Figure 7.6, filter subclasses, such as DebuggingFilter, define specific processing by overriding the abstract doMainProcessing method and, optionally, doPreProcessing and doPostProcessing. Thus, the template filter imposes a structure to each filter's processing, as well as providing a place for encapsulating code that is common to every filter.  

图7.6所示的时序图中，过滤器子类（如DebuggingFilter）通过重写抽象方法`doMainProcessing`及可选的`doPreProcessing`与`doPostProcessing`来定义具体处理逻辑。因此，模板过滤器既为每个过滤器的处理流程制定了结构框架，又为封装各过滤器共有代码提供了统一位置。

# Consequences  

# Centralizes Control with Loosely Coupled Handlers  

Filters provide a central place for handling processing across multiple requests, as does a controller. Filters are better suited to massaging requests and responses for ultimate handling by a target resource, such as a controller. Additionally, a controller often ties together the management of numerous unrelated common services, such as authentication, logging, encryption, and so forth, while filtering allows for much more loosely coupled handlers, which can be combined in various combinations.  

过滤器为跨多个请求的处理提供了集中管理点，这一点与控制器类似。过滤器更适用于对请求和响应进行预处理，以便目标资源（如控制器）进行最终处理。此外，控制器通常需要整合管理多个无关的公共服务（如身份验证、日志记录、加密等），而过滤机制则支持更松耦合的处理器，这些处理器可以按不同组合灵活搭配使用。

Improves Reusability  

提升可复用性

Filters promote cleaner application partitioning and encourages reuse. These pluggable interceptors are transparently added or removed from existing code, and due to their standard interface, they work in any combination and are reusable for varying presentations.  

过滤器促进了更清晰的应用分层并鼓励复用。这些可插拔的拦截器能够透明地添加到现有代码或从中移除，由于其标准化的接口，它们能以任意组合方式工作，并适用于不同的展示层实现。

# Declarative and Flexible Configuration  

Numerous services are combined in varying permutations without a single recompile of the core code base.  

众多服务通过不同组合方式集成，而无需对核心代码库进行任何重新编译。

# Information Sharing is Inefficient  

Sharing information between filters can be inefficient, since by definition each filter is loosely coupled. If large amounts of information must be shared between filters, then this approach may prove to be costly.  

在过滤器之间共享信息可能效率低下，因为根据定义，每个过滤器都是松耦合的。如果必须在过滤器之间共享大量信息，那么这种方法可能会带来较高的性能开销。

# Related Patterns  

# Front Controller  

The controller solves some similar problems, but is better suited to handling core processing.  

控制器解决了一些类似的问题，但更适用于处理核心业务逻辑。

# Decorator [GoF]  

The Intercepting Filter pattern is related to the Decorator pattern, which provides for dynamically pluggable wrappers.  

拦截过滤器模式与装饰器模式相关，后者提供了动态可插拔的包装器。

# Template Method [GoF]  

The Template Method pattern is used to implement the Template Filter Strategy.  

模板方法模式用于实现模板过滤策略。

# Interceptor [POSA2]  

The Intercepting Filter pattern is related to the Interceptor pattern, which allows services to be added transparently and triggered automatically.  

拦截过滤器模式与拦截器模式相关，它允许透明地添加服务并自动触发。

# Pipes and Filters [POSA1]  

The Intercepting Filter pattern is related to the Pipes and Filters pattern.  

拦截过滤器模式与管道过滤器模式相关联。

# Front Controller  

# Context  

The presentation-tier request handling mechanism must control and coordinate processing of each user across multiple requests. Such control mechanisms may be managed in either a centralized or decentralized manner.  

表示层请求处理机制必须控制和协调跨多个请求的每个用户处理流程。此类控制机制可采用**集中式**或**分散式**管理方式。

# Problem  

The system requires a centralized access point for presentation-tier request handling to support the integration of system services, content retrieval, view management, and navigation. When the user accesses the view directly without going through a centralized mechanism, two problems may occur:  

系统需要一个集中化的访问点来处理表示层请求，以支持系统服务集成、内容检索、视图管理和导航控制。若用户绕过集中化机制直接访问视图，可能导致以下两个问题：

Each view is required to provide its own system services, often resulting in duplicate code.   
View navigation is left to the views. This may result in commingled view content and view navigation.  

每个视图需要自行提供系统服务，通常会导致代码重复。  
视图导航交由视图自身处理，这可能导致视图内容与导航逻辑混杂。

Additionally, distributed control is more difficult to maintain, since changes will often need to be made in numerous places.  

此外，分布式控制更难以维护，因为变更通常需要在多处进行修改。

# Forces  

Common system services processing completes per request. For example, the security service completes authentication and authorization checks.   
? Logic that is best handled in one central location is instead replicated within numerous views.   
• Decision points exist with respect to the retrieval and manipulation of data.   
• Multiple views are used to respond to similar business requests. A centralized point of contact for handling a request may be useful, for example, to control and log a user's progress through the site. System services and view management logic are relatively sophisticated.  

每请求的通用系统服务处理完成。例如，安全服务完成认证与授权检查。  
? 本应集中处理的逻辑被分散在多个视图中重复实现。  
• 在数据检索与操作环节存在决策点。  
• 需使用多个视图响应相似的业务请求。集中式请求处理入口（例如用于控制和记录用户在站点的操作流程）将更为高效。系统服务与视图管理逻辑具有较高复杂度。  

（注：问号"?"为原文保留符号，可能表示疑问或待确认项）

# Solution  

Use a controller as the initial point of contact for handling a request. The controller manages the handling of the request, including invoking security services such as authentication and authorization, delegating  

使用控制器作为处理请求的初始接触点。该控制器负责管理请求的处理流程，包括调用安全服务（如认证与授权）、委派业务逻辑执行等操作。

# business processing, managing the choice of an appropriate view, handling errors, and managing the selection of content creation strategies.  

The controller provides a centralized entry point that controls and manages Web request handling. By centralizing decision points and controls, the controller also helps reduce the amount of Java code, called scriptlets, embedded in the JSP.  

控制器提供了一个集中化的入口点，用于控制和管理Web请求处理。通过集中决策点和控制逻辑，控制器还有助于减少嵌入在JSP中的Java代码（称为脚本片段）的数量。

Centralizing control in the controller and reducing business logic in the view promotes code reuse across requests. It is a preferable approach to the alternative—embedding code in multiple views—because that approach may lead to a more error-prone, reuse-by-copy- and-paste environment.  

将控制逻辑集中于控制器并减少视图中的业务逻辑，有助于实现跨请求的代码复用。相较于将代码分散嵌入多个视图的做法，这种集中式控制是更优的选择，因为后者容易导致错误频发，形成通过复制粘贴实现代码复用的低效环境。

Typically, a controller coordinates with a dispatcher component. Dispatchers are responsible for view management and navigation. Thus, a dispatcher chooses the next view for the user and vectors control to the resource. Dispatchers may be encapsulated within the controller directly or can be extracted into a separate component.  

通常，控制器会与**分发器(dispatcher)**组件协同工作。分发器负责视图管理与导航，其核心职责是选择用户的下一个视图并将控制权定向至目标资源。分发器可直接封装在控制器内部，也可被抽离为独立组件。

While the Front Controller pattern suggests centralizing the handling of all requests, it does not limit the number of handlers in the system, as does a Singleton. An application may use multiple controllers in a system, each mapping to a set of distinct services.  

虽然前端控制器模式建议集中处理所有请求，但它不会像单例模式那样限制系统中的处理器数量。一个应用程序可以在系统中使用多个控制器，每个控制器映射到一组不同的服务。

# Structure  

Figure 7.7 represents the Front Controller class diagram pattern.  

图7.7展示了前端控制器（Front Controller）的类图模式。

![](images/1850e0d8a2cce15f3a0bdaf2a9d4158062b2f6482ff0621d2ff54ee4f8505e1e.jpg)  
Figure 7.7. Front Controller class diagram  

图7.7 前端控制器类图

# Participants and Responsibilities  

Figure 7.8 shows the sequence diagram representing the Front Controller pattern. It depicts how the controller handles a request.  

图7.8展示了表示前端控制器模式的序列图，描述了控制器如何处理请求。

![](images/c1bfde58a4e5daf5985d4711a93ccadbe5a2cea787ea612c12018617ec13e878.jpg)  
Figure 7.8. Front Controller sequence diagram  

图7.8 前端控制器时序图

# Controller  

The controller is the initial contact point for handling all requests in the system. The controller may delegate to a helper to complete authentication and authorization of a user or to initiate contact retrieval.  

控制器是系统中处理所有请求的初始接触点。控制器可委托辅助组件完成用户认证授权，或发起联系人检索操作。

# Dispatcher  

A dispatcher is responsible for view management and navigation, managing the choice of the next view to present to the user, and providing the mechanism for vectoring control to this resource.  

分发器负责视图管理与导航，管理向用户呈现的下一个视图的选择，并提供将控制流转至该资源的机制。

A dispatcher can be encapsulated within a controller or can be a separate component working in coordination. The dispatcher provides either a static dispatching to the view or a more sophisticated dynamic dispatching mechanism.  

调度器可以封装在控制器内部，也可以作为独立组件协同工作。该组件既支持静态视图调度，也提供更复杂的动态调度机制。

The dispatcher uses the RequestDispatcher object (supported in the servlet specification) and encapsulates some additional processing.  

分发器使用`RequestDispatcher`对象（Servlet规范中支持）并封装了一些额外的处理逻辑。

# Helper  

A helper is responsible for helping a view or controller complete its processing. Thus, helpers have numerous responsibilities, including gathering data required by the view and storing this intermediate model, in which case the helper is sometimes referred to as a value bean. Additionally, helpers may adapt this data model for use by the view. Helpers can service requests for data from the view by simply providing access to the raw data or by formatting the data as Web content.  

助手（Helper）负责协助视图或控制器完成其处理流程。因此，助手承担多项职责，包括收集视图所需数据并存储这些中间模型（此时助手有时被称为值Bean）。此外，助手可能对数据模型进行适配以供视图使用。助手可通过直接提供原始数据访问权限，或将数据格式化为Web内容的方式，来响应视图的数据请求。

A view may work with any number of helpers, which are typically implemented as JavaBeans (JSP $1.0+)$ and custom tags (JSP $1.1+\cdot$ ). Additionally, a helper may represent a Command object, a delegate (see “Business Delegate”), or an XSL Transformer, which is used in combination with a stylesheet to adapt and convert the model into the appropriate form.  

视图可与任意数量的辅助组件协作，这些组件通常以 **JavaBeans**（JSP 1.0+）和自定义标签（JSP 1.1+）形式实现。此外，辅助组件可表现为 **Command** 对象、委托（参见“业务委托”模式）或 **XSL Transformer**——后者结合样式表使用，用于将模型适配并转换为目标形态。

# View  

A view represents and displays information to the client. The view retrieves information from a model. Helpers support views by encapsulating and adapting the underlying data model for use in the display.  

视图负责向客户端呈现和展示信息。视图从模型中获取信息。辅助类通过封装和适配底层数据模型来支持视图，以便在显示中使用。

# Strategies  

There are several strategies for implementing a controller.  

实现控制器有多种策略。

# Servlet Front Strategy  

This strategy suggests implementing the controller as a servlet. Though semantically equivalent, it is preferred to the JSP Front Strategy. The controller manages the aspects of request handling that are related to business processing and control flow. These responsibilities are related to, but logically independent of, display formatting, and are more appropriately encapsulated in a servlet rather than in a JSP.  

该策略建议将控制器实现为Servlet。虽然在语义上等效，但它比JSP前端策略更受青睐。控制器负责管理与业务处理和控制流相关的请求处理环节。这些职责虽与显示格式化相关，但在逻辑上独立于显示层，因此更适合封装在Servlet而非JSP中。

The Servlet Front Strategy does have some potential drawbacks. In particular, it does not leverage some of the JSP runtime environment utilities, such as automatic population of request parameters into helper properties. Fortunately, this drawback is minimal because it is relatively easy to create or obtain similar utilities for general use. There is also the possibility that the functionality of some of the JSP utilities may be included as standard servlet features in a future version of the servlet specification. Example 7.14 is an example of the Servlet Front Strategy.  

Servlet前端策略确实存在一些潜在缺陷。特别是它无法利用JSP运行时环境的某些实用功能，例如将请求参数自动填充到辅助属性中。所幸这一缺陷影响较小，因为创建或获取类似的通用工具相对容易。此外，未来Servlet规范版本可能会将部分JSP实用功能纳入标准Servlet特性。示例7.14展示了Servlet前端策略的具体实现。

# Example 7.14 Servlet Front Strategy Sample Code  

public class EmployeeController extends HttpServlet   
// Initializes the servlet.   
public void init(ServletConfig config) throws ServletException { super.init(config); }   
// Destroys the servlet.   
public void destroy() {   
}   
/\*\* Processes requests for both HTTP $\star$ <code>GET $<$ /code> and <code>POST $<$ /code> methods. $\star$ @param request servlet request $\star$ @param response servlet response \*/   
protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { String page; /\*\*ApplicationResources provides a simple API $\star$ for retrieving constants and other \* preconfigured values\*\*/ ApplicationResources resource $=$ ApplicationResources.getInstance(); try { // Use a helper object to gather parameter // specific information. RequestHelper helper $=$ new RequestHelper(request); Command cmdHelper $=$ helper.getCommand(); // Command helper perform custom operation page $=$ cmdHelper.execute(request, response); catch (Exception e) { LogManager.logMessage( "EmployeeController:exception : " + e.getMessage()); request.setAttribute(resource.getMessageAttr(), "Exception occurred : " $^+$ e.getMessage()); page $=$ resource.getErrorPage(e); } // dispatch control to view dispatch(request, response, page);   
}   
/\*\* Handles the HTTP <code $>$ GET</code> method.   
$\star$ @param request servlet request $\star$ @param response servlet response \*/   
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { processRequest(request, response);   
/\*\* Handles the HTTP <code>POST</code> method.   
$\star$ @param request servlet request   
$\star$ @param response servlet response \*/   
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { processRequest(request, response);   
}   
/\*\* Returns a short description of the servlet \*/   
public String getServletInfo() { return "Front Controller Pattern" + " Servlet Front Strategy Example";   
}   
protected void dispatch(HttpServletRequest request, HttpServletResponse response, String page)   
throws  javax.servlet.ServletException, java.io.IOException { RequestDispatcher dispatcher $=$ getServletContext().getRequestDispatcher(page);  

public class EmployeeController extends HttpServlet   
// 初始化Servlet  
public void init(ServletConfig config) throws ServletException { super.init(config); }   
// 销毁Servlet  
public void destroy() {   
}   
/\*\* 处理HTTP $\star$ <code>GET $<$ /code>和<code>POST $<$ /code>方法的请求。 $\star$ @param request servlet请求 $\star$ @param response servlet响应 \*/   
protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { String page; /\*\*ApplicationResources提供简单API $\star$ 用于获取常量及其他\*预配置值\*\*/ ApplicationResources resource $=$ ApplicationResources.getInstance(); try { // 使用辅助对象收集参数 // 特定信息 RequestHelper helper $=$ new RequestHelper(request); Command cmdHelper $=$ helper.getCommand(); // 命令辅助执行自定义操作 page $=$ cmdHelper.execute(request, response); catch (Exception e) { LogManager.logMessage( "EmployeeController:exception : " + e.getMessage()); request.setAttribute(resource.getMessageAttr(), "发生异常 : " $^+$ e.getMessage()); page $=$ resource.getErrorPage(e); } // 将控制分派至视图 dispatch(request, response, page);   
}   
/\*\* 处理HTTP <code $>$ GET</code>方法。   
$\star$ @param request servlet请求 $\star$ @param response servlet响应 \*/   
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { processRequest(request, response);   
/\*\* 处理HTTP <code>POST</code>方法。   
$\star$ @param request servlet请求   
$\star$ @param response servlet响应 \*/   
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { processRequest(request, response);   
}   
/\*\* 返回Servlet的简短描述 \*/   
public String getServletInfo() { return "前端控制器模式" + " Servlet前端策略示例";   
}   
protected void dispatch(HttpServletRequest request, HttpServletResponse response, String page)   
throws  javax.servlet.ServletException, java.io.IOException { RequestDispatcher dispatcher $=$ getServletContext().getRequestDispatcher(page);

dispatcher.forward(request, response);  

dispatcher.forward(request, response);

# JSP Front Strategy  

This strategy suggests implementing the controller as a JSP. Though semantically equivalent, the Servlet Front Strategy is preferred to the JSP Front Strategy. Since the controller handles processing that is not specifically related to display formatting, it is a mismatch to implement this component as a JSP.  

该策略建议将控制器实现为JSP页面。虽然在语义上等效，但**Servlet前端策略**优于**JSP前端策略**。由于控制器处理的逻辑与显示格式无直接关联，将其实现为JSP组件存在设计失配问题。

Implementing the controller as a JSP is clearly not preferred for another reason: It requires a software developer to work with a page of markup in order to modify request handling logic. Thus, a software developer will typically find the JSP Front Strategy more cumbersome when completing the cycle of coding, compilation, testing, and debugging. Example 7.15 is an example of the JSP Front Strategy.  

将控制器实现为JSP显然还存在另一个不利因素：它要求软件开发人员通过修改标记页面来调整请求处理逻辑。因此，在完成编码、编译、测试和调试的完整周期时，开发人员通常会发现**JSP前端策略**更为繁琐。示例7.15展示了这种策略的具体应用。

# Example 7.15 JSP Front Strategy Sample Code  

<%@page contentType $=$ "text/html"%>   
<%@ page import $=$ "corepatterns.util.\*" %>   
<html>   
<head><title>JSP Front Controller</title></head>   
<body>   
<h3><center> Employee Profile </h3>   
<%   
/\*\*Control logic goes here... At some point in this code block we retrieve employee information, encapsulate it within a value object and place this bean in request scope with the key "employee". This code has been omitted. We either dispatch to another JSP at this point or simply allow the remaining portions of scriptlet code toexecute\*\*/   
%> <jsp:useBean id $=$ "employee" scope $=$ "request" class $=$ "corepatterns.util.EmployeeVO"/>   
<FORM method $\equiv$ POST $>$   
<table width $="60\%$ ">   
<tr>  

<%@page contentType="text/html"%>  
<%@ page import="corepatterns.util.*" %>  
<html>  
<head><title>JSP前端控制器</title></head>  
<body>  
<h3><center> 员工档案 </h3>  
<%  
/**控制逻辑在此处... 在此代码块中的某个时刻，我们检索员工信息，将其封装到值对象中，并将此Bean以键"employee"放入请求范围。此部分代码已省略。此时我们要么分派到另一个JSP，要么简单地允许剩余的脚本代码执行*/  
%> <jsp:useBean id="employee" scope="request" class="corepatterns.util.EmployeeVO"/>  
<FORM method=POST>  
<table width="60%">  
<tr>

<td>  First Name : </td> <td> <input type $=$ "text" name $=$ "<% $=$ Constants.FLD_FIRSTNAME%>" value $=$ "<jsp:getProperty name $=$ "employee" property $=$ "firstName"/ $>$ " $>$ </td> </tr> <tr> <td> Last Name : </td> <td> <input type $=$ "text" name $=$ "<% $=$ Constants.FLD_LASTNAME%>" value $=$ "<jsp:getProperty name $=$ "employee" property $=$ "lastName"/>"></td> </tr> <tr> <td> Employee ID : </td> <td> <input type $=$ "text" name $=$ "<% $=$ Constants.FLD_EMPID%>" value $=$ "<jsp:getProperty name $=$ "employee" property $=$ "id"/>"> </td> </tr> <tr> <td> <input type $=$ "submit" name $=$ "employee_profile" $>$ </td> <td> </td> </tr> </table> </FORM> </body> </html>  

<td> 名：</td> <td> <input type $=$ "text" name $=$ "<% $=$ Constants.FLD_FIRSTNAME%>" value $=$ "<jsp:getProperty name $=$ "employee" property $=$ "firstName"/ $>$ " $>$ </td> </tr> <tr> <td> 姓：</td> <td> <input type $=$ "text" name $=$ "<% $=$ Constants.FLD_LASTNAME%>" value $=$ "<jsp:getProperty name $=$ "employee" property $=$ "lastName"/>"></td> </tr> <tr> <td> 员工ID：</td> <td> <input type $=$ "text" name $=$ "<% $=$ Constants.FLD_EMPID%>" value $=$ "<jsp:getProperty name $=$ "employee" property $=$ "id"/>"> </td> </tr> <tr> <td> <input type $=$ "submit" name $=$ "employee_profile" $>$ </td> <td> </td> </tr> </table> </FORM> </body> </html>

# Command and Controller Strategy  

Based on the Command pattern [GoF], the Command and Controller Strategy suggests providing a generic interface to the helper components to which the controller may delegate responsibility, minimizing the coupling among these components (see “View Helper” for more information on helper components). Adding to or changing the work that needs to be completed by these helpers does not require any changes to the interface between the controller and the helpers, but rather to the type and/or content of the commands. This provides a flexible and easily extensible mechanism for developers to add request handling behaviors.  

基于命令模式[GoF]，命令与控制策略建议为辅助组件提供一个通用接口，控制器可将职责委托给这些组件，从而最小化组件间的耦合（有关辅助组件的更多信息，请参阅“视图助手”）。新增或修改这些辅助组件需要完成的工作，无需变更控制器与辅助组件之间的接口，只需调整命令的类型和/或内容即可。这为开发者提供了一种灵活且易于扩展的机制，用于添加请求处理行为。

Finally, because the command processing is not coupled to the command invocation, the command processing mechanism may be reused with various types of clients, not just with Web browsers. This strategy also facilitates the creation of composite commands (see Composite pattern [GoF]). See Example 7.16 for sample code and Figure 7.9 for a sequence diagram.  

最终，由于命令处理与命令调用解耦，该命令处理机制可复用于各类客户端（而不仅限于Web浏览器）。此策略还便于创建复合命令（参见[GoF]的Composite模式）。示例代码见Example 7.16，序列图见图7.9。

# Example 7.16 Command and Controller Strategy Sample Code  

/\*\* This processRequest method is invoked from both \* the servlet doGet and doPost methods \*\*/ protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException {  

/\*\* 此 processRequest 方法由 \* servlet 的 doGet 和 doPost 方法共同调用 \*\*/  
protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException {

String resultPage;   
try { RequestHelper helper $=$ new RequestHelper(request); /\*\* the getCommand() method internally uses a factory to retrieve command objects as follows: Command command $=$ CommandFactory.create( request.getParameter("op")); \*\*/ Command command $=$ helper.getCommand(); // delegate request to a command object helper resultPage $=$ command.execute(request, response);   
}   
catch (Exception e) { LogManager.logMessage("EmployeeController", e.getMessage() ); resultPage $=$ ApplicationResources.getInstance(). getErrorPage(e);   
}   
dispatch(request, response, resultPage);  

String resultPage;  
try {  
    RequestHelper helper = new RequestHelper(request);  
    /** getCommand()方法内部通过工厂模式获取命令对象：Command command = CommandFactory.create( request.getParameter("op")); */  
    Command command = helper.getCommand(); // 将请求委托给命令对象处理  
    resultPage = command.execute(request, response);  
}  
catch (Exception e) {  
    LogManager.logMessage("EmployeeController", e.getMessage() );  
    resultPage = ApplicationResources.getInstance().getErrorPage(e);  
}  
dispatch(request, response, resultPage);

![](images/dd146f9978c7d137ac1a4b573163718cdff44cc6b4f864928516f1baafa8a9b2.jpg)  
Figure 7.9. Command and Controller Strategy sequence diagram  

图7.9 命令与控制策略时序图

# Physical Resource Mapping Strategy  

All requests are made to specific physical resource names rather than logical names. An example is the following URL: http://some.server.com/resource1.jsp. In the case of a controller, an example URL might be http://some.server.com/servlet/Controller. The Logical Resource Mapping Strategy is typically preferred over this strategy because it provides much greater flexibility. The Logical Resource Mapping Strategy lets you modify resource mappings in a declarative manner, via a configuration file. This is much more flexible than the Physical Resource Mapping Strategy, which requires that you make changes to each resource, as is necessary when implementing this strategy.  

所有请求均指向具体的物理资源名称而非逻辑名称。例如以下URL：http://some.server.com/resource1.jsp。对于控制器而言，示例URL可能是http://some.server.com/servlet/Controller。**逻辑资源映射策略**通常优于此策略，因其能提供更高的灵活性。该策略允许通过配置文件以声明式方式修改资源映射，相比**物理资源映射策略**需要逐个修改资源的实现方式，具有显著的可扩展优势。

# Logical Resource Mapping Strategy  

Requests are made to logical resource names rather than to specific physical names. The physical resources to which these logical names refer may then be modified in a declarative manner.  

请求被发送至逻辑资源名称而非特定物理名称。这些逻辑名称所指向的物理资源可通过声明式方式进行修改。

For example, the URL http://some.server.com/process may be mapped as follows:  

例如，URL http://some.server.com/process 可能按如下方式映射：

process $=$ resource1.jsp OR   
process $=$ resource2.jsp OR   
process $=$ servletController  

process $=$ resource1.jsp OR  
process $=$ resource2.jsp OR  
process $=$ servletController

# Multiplexed Resource Mapping Strategy  

This is actually a substrategy of Logical Resource Naming Strategy. This strategy maps not just a single logical name, but an entire set of logical names, to a single physical resource. For example, a wildcard mapping might map all requests that end with .ctrl to a specific handler.  

这实际上是**逻辑资源命名策略**的子策略。该策略不仅将单个逻辑名称，而是将整套逻辑名称映射到单一物理资源。例如，通配符映射可能将所有以`.ctrl`结尾的请求定向到特定处理器。

A request and mapping might look as shown in Table 7-1  

请求与映射关系可能如表7-1所示

<html><body><table><tr><td colspan="2">Table7-1.</td></tr><tr><td>Request</td><td>Mapping</td></tr><tr><td>http://some.server.com/action.ctrl</td><td>*.ctrl = servletController</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表7-1.</td></tr><tr><td>请求</td><td>映射关系</td></tr><tr><td>http://some.server.com/action.ctrl</td><td>*.ctrl = servletController</td></tr></table></body></html>

In fact, this is the strategy JSP engines use in order to ensure that requests for JSP resources (that is, resources whose names end in . $\dot{\mathsf{J}}\mathsf{s p}$ ) are processed by a specific handler.  

实际上，这是JSP引擎采用的策略，用于确保对JSP资源（即名称以.$\dot{\mathsf{J}}\mathsf{s p}$结尾的资源）的请求由特定处理器处理。

Additional information can also be added to a request, providing further details to leverage for this logical mapping. See Table 7-2.  

可在请求中添加附加信息，为此逻辑映射提供更多可利用的细节。参见表7-2。

<html><body><table><tr><td colspan="2">Table7-2.</td></tr><tr><td>Request</td><td>Mapping</td></tr><tr><td>http://some.server.com/profile.ctrl?usecase= create</td><td>*.ctrl servletController</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表7-2.</td></tr><tr><td>请求</td><td>映射关系</td></tr><tr><td>http://some.server.com/profile.ctrl?usecase= create</td><td>*.ctrl servletController</td></tr></table></body></html>

A key benefit of using this strategy is that it provides great flexibility when designing your request handling components. When combined with other strategies, such as the Command and Controller Strategy, you can create a powerful request handling framework.  

采用该策略的核心优势在于能为请求处理组件的设计提供极大灵活性。结合**命令模式**与**控制器策略**等其他策略时，可构建出强大的请求处理框架。

Consider a controller that handles all requests ending in .ctrl, as described above. Also, consider the left side of this dot-delimited resource name (profile in the above example) to be one part of the name of a use case. Now combine this name with the query parameter value (create in the above example). We are signaling our request handler that we want to process a use case called create profile. Our multiplexed resource mapping sends the request to our servletController, which is part of the mapping shown in Table 7-2 . Our controller creates the appropriate command object, as described in the Command and Controller Strategy. How does the controller know the command object to which it should delegate? Leveraging the additional information in the request URI, the controller delegates to the command object that handles profile creation. This might be a ProfileCommand object that services requests for Profile creation and modification, or it might be a more specific ProfileCreationCommand object.  

假设存在一个控制器，如上所述，该控制器负责处理所有以`.ctrl`结尾的请求。同时，将点分隔资源名称的左侧部分（前例中的`profile`）视为用例名称的一个组成部分。将此名称与查询参数值（前例中的`create`）结合，即可向请求处理器表明需要处理名为`create profile`的用例。经过多路复用的资源映射会将请求发送至`servletController`——该组件对应于表7-2所示的映射关系。控制器会按照命令与控制策略创建相应的命令对象。那么控制器如何确定应该委托给哪个命令对象？通过解析请求URI中的附加信息，控制器将委托给处理档案创建的命令对象。这可能是服务档案创建和修改请求的`ProfileCommand`对象，也可能是更具体的`ProfileCreationCommand`对象。

# Dispatcher in Controller Strategy  

When the dispatcher functionality is minimal, it can be folded into the controller, as shown in Figure 7.10.  

当调度器功能较为简单时，可将其合并至控制器中，如图7.10所示。

![](images/62b40bf2bf4114ffd460a076bd29da9f127ade24e499021c5e67373a9b108894.jpg)  
Figure 7.10. Dispatcher in the Controller sequence diagram  

图7.10 控制器时序图中的Dispatcher组件

# Base Front Strategy  

Used in combination with the Servlet Front Strategy, this strategy suggests implementing a controller base class, whose implementation other controllers may extend. The base front may contain common and default implementations, while each subclass can override these implementations. The drawback of this strategy is the fact that any shared superclass, while promoting reuse and sharing, raises the issue of creating a fragile hierarchy, where changes necessary for one subclass affect all subclasses.  

与**Servlet Front策略**结合使用时，该策略建议实现一个控制器基类，其他控制器可通过继承扩展其**实现**。基础前端可包含通用和默认**实现**，而每个子类均可重写这些实现。此策略的缺点在于：任何共享超类在促进复用和共享的同时，会引发创建脆弱继承层次结构的问题——当某个子类所需的修改会影响到所有子类。

# Filter Controller Strategy  

Filters provide similar support for centralizing request processing control (see Intercepting Filter pattern). Thus, some aspects of a controller can reasonably be implemented as a filter. At the same time, filters primarily focus on request interception and decoration, not request processing and response generation. While there are overlapping responsibilities, such as managing logging or debugging, each component complements the other when used appropriately.  

过滤器为集中控制请求处理提供了类似的支持（参见拦截过滤器模式）。因此，控制器的某些功能可以合理地通过过滤器实现。与此同时，过滤器主要关注请求拦截与装饰，而非请求处理和响应生成。尽管存在职责重叠（例如管理日志记录或调试），但在合理使用时，这些组件能够相互补充。

# Consequences  

# Centralizes Control  

A controller provides a central place to handle system services and business logic across multiple requests. A controller manages business logic processing and request handling. Centralized access to an application means that requests are easily tracked and logged. Keep in mind, though, that as control centralizes, it is possible to introduce a single point of failure. In practice, this rarely is a problem, though, since multiple controllers typically exist, either within a single server or in a cluster.  

控制器为处理跨多个请求的系统服务和业务逻辑提供了集中化的场所。它负责管理业务逻辑处理与请求调度。这种集中式访问机制使得请求更易于追踪和记录。但需注意，随着控制权的集中化，可能会引入单点故障风险。实际应用中这种情况极少发生，因为通常存在多个控制器（部署在单台服务器或集群环境中）。

# Improves Manageability of Security  

A controller centralizes control, providing a choke point for illicit access attempts into the Web application. In addition, auditing a single entrance into the application requires fewer resources than distributing security checks across all pages.  

控制器集中管理控制流，为Web应用程序的非法访问尝试提供了关键拦截点。此外，相比在所有页面分散实施安全检查，审计单一入口点所需的资源更少。

# Improves Reusability  

A controller promotes cleaner application partitioning and encourages reuse, as code that is common among components moves into a controller or is managed by a controller.  

控制器能促进更清晰的应用分层并提升复用性，因为组件间的公共代码会被移至控制器中或由控制器统一管理。

# Related Patterns  

# View Helper  

The Front Controller pattern, in conjunction with the View Helper pattern, describes factoring business logic out of the view and providing a central point of control and dispatch. Flow logic is factored forward into the controller and data handling code moves back into the helpers.  

前端控制器模式与视图助手模式相结合，描述了将业务逻辑从视图中剥离，并提供一个集中控制和调度的中心点。流程逻辑被前移至控制器中，而数据处理代码则后移至助手组件内。

# Intercepting Filter  

Both Intercepting Filter and Front Controller describe ways to centralize control of certain types of request processing, suggesting different approaches to this issue.  

拦截过滤器（Intercepting Filter）与前端控制器（Front Controller）均描述了集中管控特定类型请求处理的方案，针对该问题提出了不同的实现路径。

# Dispatcher View and Service to Worker  

The Dispatcher View and Service to Worker patterns are another way to name the combination of the View Helper pattern with a dispatcher, and Front Controller pattern. Dispatcher View and Service to Worker, while structurally the same, describe different divisions of labor among components.  

Dispatcher View 和 Service to Worker 模式是对 View Helper 模式与调度器及 Front Controller 模式组合的另一种命名方式。尽管结构相同，Dispatcher View 和 Service to Worker 描述了组件间不同的职责划分。

# View Helper  

# Context  

The system creates presentation content, which requires processing of dynamic business data.  

系统生成呈现内容，需对动态业务数据进行处理。

# Problem  

Presentation tier changes occur often and are difficult to develop and maintain when business data access logic and presentation formatting logic are interwoven. This makes the system less flexible, less reusable, and generally less resilient to change.  

表示层变更频繁发生，当业务数据访问逻辑与呈现格式化逻辑相互交织时，其开发和维护会变得异常困难。这将导致系统灵活性降低、可重用性减弱，整体上对变更的适应能力也会下降。

Intermingling the business and systems logic with the view processing reduces modularity and also provides a poor separation of roles among Web production and software development teams.  

将业务逻辑与系统逻辑混杂在视图处理中会降低模块化程度，同时导致Web生产团队与软件开发团队之间的职责分离不清晰。

# Forces  

Business data assimilation requirements are nontrivial. ? Embedding business logic in the view promotes a copy-and-paste type of reuse. This causes maintenance problems and bugs because a piece of logic is reused in the same or different view by simply duplicating it in the new location. It is desirable to promote a clean separation of labor by having different individuals fulfill the roles of software developer and Web production team member. One view is commonly used to respond to a particular business request.  

业务数据同化需求不容忽视。将业务逻辑嵌入视图会导致**复制粘贴式复用**，这会引发维护问题和缺陷，因为同一段逻辑在相同或不同视图中复用仅需在新位置简单复制即可。理想的做法是通过让不同人员分别承担软件开发者和网页制作团队成员的职责，实现清晰的职责分离。通常一个视图用于响应特定的业务请求。

# Solution  

A view contains formatting code, delegating its processing responsibilities to its helper classes, implemented as JavaBeans or custom tags. Helpers also store the view's intermediate data model and serve as business data adapters.  

视图包含格式化代码，将其处理职责委托给作为JavaBeans或自定义标签实现的辅助类。辅助类还存储视图的中间数据模型，并充当业务数据适配器。

There are multiple strategies for implementing the view component. The JSP View Strategy suggests using a JSP as the view component. This is the preferred strategy, and it is the one most commonly used. The other principal strategy is the Servlet View Strategy, which utilizes a servlet as the view (see the section “Strategies” for more information).  

实现视图组件存在多种策略。**JSP视图策略**建议采用JSP作为视图组件，这是首选且最常用的策略。另一种主要策略是**Servlet视图策略**，该策略使用Servlet作为视图（详见“策略”章节）。

Encapsulating business logic in a helper instead of a view makes our application more modular and facilitates component reuse. Multiple clients, such as controllers and views, may leverage the same helper to retrieve and adapt similar model state for presentation in multiple ways. The only way to reuse logic embedded in a view is by copying and pasting it elsewhere. Furthermore, copy-and-paste duplication makes a system harder to maintain, since the same bug potentially needs to be corrected in multiple places.  

将业务逻辑封装在辅助类而非视图中，可使应用程序更具模块化特性并促进组件复用。多个客户端（如控制器和视图）可复用同一辅助类，以多种方式获取并适配相似的模型状态用于展示。而嵌入视图的逻辑仅能通过复制粘贴实现复用。此外，这种复制粘贴的重复模式会导致系统维护难度增加，因为同一缺陷可能需要在多处进行修正。

A signal that one may need to apply this pattern to existing code is when scriptlet code dominates the JSP view. The overriding goal when applying this pattern, then, is the partitioning of business logic outside of the view. While some logic is best encapsulated within helper objects, other logic is better placed in a centralized component that sits in front of the views and the helpers—this might include logic that is common across multiple requests, such as authentication checks or logging services, for example. Refer to the “Intercepting Filter” and “Front Controller” for more information on these issues.  

当现有代码中脚本代码主导JSP视图时，可能就需要应用该模式。应用此模式的首要目标是将业务逻辑从视图中分离出来。虽然部分逻辑最适合封装在辅助对象中，但其他逻辑更适合置于视图和辅助对象之前的集中化组件中——例如，这可能包括跨多个请求的通用逻辑，如身份验证检查或日志服务。有关这些问题的更多信息，请参阅“拦截过滤器”和“前端控制器”。

If a separate controller is not employed in the architecture, or is not used to handle all requests, then the view component becomes the initial contact point for handling some requests. For certain requests, particularly those involving minimal processing, this scenario works fine. Typically, this situation occurs for pages that are based on static information, such as the first of a set of pages that will be served to a user to gather some information (see “Dispatcher View”). Additionally, this scenario occurs in some cases when a mechanism is employed to create composite pages (see “Composite View”).  

若架构中未采用独立控制器，或未用其处理所有请求，则视图组件将成为处理部分请求的初始接触点。对于某些请求（尤其是涉及最少处理逻辑的情况），这种模式完全适用。该场景通常出现在基于静态信息的页面中，例如向用户展示以收集信息的系列页面中的首页（参见“Dispatcher View”）。此外，当采用某种机制创建复合页面时（参见“Composite View”），此类情况亦会出现。

The View Helper pattern focuses on recommending ways to partition your application responsibilities. For related discussions about issues dealing with directing client requests directly to a view, please refer to the section “Dispatcher View”.  

视图助手模式着重于推荐应用程序职责划分的方式。有关将客户端请求直接导向视图的相关问题讨论，请参阅“调度器视图”章节。

# Structure  

Figure 7.11 is the class diagram representing the View Helper pattern.  

图7.11是表示视图助手(View Helper)模式的类图。

Figure 7.11. View Helper class diagram   

图7.11 View Helper类图


<html><body><table><tr><td>Client</td><td>View 1..</td><td></td><td>Helper</td></tr><tr><td></td><td></td><td></td><td>0..</td></tr></table></body></html>  

<html><body><table><tr><td>客户端</td><td>视图 1..</td><td></td><td>辅助类</td></tr><tr><td></td><td></td><td></td><td>0..</td></tr></table></body></html>

# Participants and Responsibilities  

Figure 7.12 shows the sequence diagram representing the View Helper pattern. A controller typically mediates between the client and the view. In some cases, though, a controller is not used and the view becomes the initial contact point for handling the request. (Also, see Dispatcher View pattern.)  

图7.12展示了表示View Helper模式的序列图。控制器通常作为客户端与视图之间的中介。但在某些情况下，若未使用控制器，视图将成为处理请求的初始接触点。（另请参阅Dispatcher View模式。）

![](images/89cff7ae520a815000d874b5e2187c256c3c8aa133db035efbf10a17f65e47b0.jpg)  
Figure 7.12. View Helper sequence diagram  

图7.12 View Helper序列图

As noted in the class diagram, there may be no helpers associated with a view. In this simple case, the page may be entirely static or include very small amounts of inline scriptlet code. This scenario is described in the sequence diagram in Figure 7.13.  

如类图所示，视图可能未关联任何辅助类。在此简单场景中，页面可能完全静态或仅包含少量内联脚本代码。图7.13的时序图描述了这种情况。

![](images/b181e7b8ed1957148f58c2f7a715e9f57e5476923a36c0fc339847a375d4db48.jpg)  
Figure 7.13. View Helper simple sequence diagram  

图7.13. View Helper简单序列图

# View  

A view represents and displays information to the client. The information that is used in a dynamic display is retrieved from a model. Helpers support views by encapsulating and adapting a model for use in a display.  

视图负责向客户端呈现和展示信息。动态显示所使用的信息从模型中获取。助手通过封装和适配模型以支持视图，使其适用于展示场景。

# Helper  

A helper is responsible for helping a view or controller complete its processing. Thus, helpers have numerous responsibilities, including gathering data required by the view and storing this intermediate model, in which case the helper is sometimes referred to as a value bean. Additionally, helpers may adapt this data model for use by the view. Helpers can service requests for data from the view by simply providing access to the raw data or by formatting the data as Web content.  

助手（helper）负责协助视图或控制器完成其处理流程。因此，助手承担多项职责，包括收集视图所需数据并存储这些中间模型（此时助手有时被称为值Bean）。此外，助手可能对数据模型进行适配以供视图使用。助手可通过两种方式响应视图的数据请求：直接提供原始数据访问，或将数据格式化为Web内容。

A view may work with any number of helpers, which are typically implemented as JavaBeans (JSP $1.0+)$ and custom tags (JSP $1.1+)$ . Additionally, a helper may represent a Command object, a delegate (see “Business Delegate”), or an XSL Transformer, which is used in combination with a stylesheet to adapt and convert the model into the appropriate form.  

视图可与任意数量的辅助组件协作，这些组件通常以 **JavaBeans**（JSP 1.0+）和自定义标签（JSP 1.1+）形式实现。此外，辅助组件可表现为 **Command** 对象、委托（参见“业务委托”模式）或 **XSL Transformer**——后者结合样式表使用，用于将模型适配并转换为目标形态。

# ValueBean  

A value bean is another name for a helper that is responsible for holding intermediate model state for use by a view. A typical case, as shown in the sequence diagram in Figure 7.12, has the business service returning a value bean in response to a request. In this case, ValueBean fulfills the role of a Value Object (see “Value Object”).  

值对象Bean（ValueBean）是辅助类的另一种称谓，其职责是持有供视图使用的中间模型状态。如图7.12序列图所示，典型场景中业务服务会响应请求返回一个值对象Bean。此时ValueBean承担着值对象（参见“值对象”章节）的角色。

# BusinessService  

The business service is a role that is fulfilled by the service the client is seeking to access. Typically, the business service is accessed via a Business delegate. The business delegate's role is to provide control and protection for the business service (see the “Business Delegate”).  

业务服务是由客户端寻求访问的服务所实现的角色。通常，业务服务通过**业务委托（Business Delegate）**进行访问。业务委托的作用是为业务服务提供控制与保护（参见“业务委托”章节）。

# Strategies  

# JSP View Strategy  

The JSP View Strategy suggests using a JSP as the view component. This is the preferred strategy to the Servlet View Strategy. While it is semantically equivalent to the Servlet View Strategy, it is a more elegant solution and is more commonly used. Views are the domain of Web designers, who prefer markup to Java code. Example 7.17 shows a code sample for this strategy. The excerpt is from a source file called welcome.jsp, to which a servlet controller dispatches after placing the WelcomeHelper JavaBean in request scope.  

JSP视图策略建议采用JSP作为视图组件。相较于Servlet视图策略，这是更优选的方案。尽管在语义上与Servlet视图策略等效，但该方案更为优雅且更广泛使用。视图属于网页设计师的领域，他们更倾向于标记语言而非Java代码。示例7.17展示了该策略的代码片段，这段摘录来自名为welcome.jsp的源文件，Servlet控制器将WelcomeHelper JavaBean置于请求作用域后，会转发至该文件。

# Example 7.17 JSP View Strategy Sample Code  

<jsp:useBean id $\equiv$ "welcomeHelper" scope $=$ "request" class $=$ "corepatterns.util.WelcomeHelper" />   
<HTML>   
<BODY bgcolor $=$ "FFFFFF" $>$   
$<\%$ if (welcomeHelper.nameExists())   
{   
%>   
<center><H3> Welcome <b>   
<jsp:getProperty name $=$ "welcomeHelper" property $=$ "name" />   
</b><br><br> </H3></center>   
<%   
}   
%>   
<H4><center>Glad you are visiting our site!</center></H4>   
</BODY>   
</HTML>  

<jsp:useBean id="welcomeHelper" scope="request" class="corepatterns.util.WelcomeHelper" />  
<HTML>  
<BODY bgcolor="FFFFFF">  
<% if (welcomeHelper.nameExists())   
{   
%>  
<center><H3> 欢迎 <b>  
<jsp:getProperty name="welcomeHelper" property="name" />  
</b><br><br> </H3></center>  
<%   
}   
%>  
<H4><center>很高兴您访问我们的网站！</center></H4>  
</BODY>  
</HTML>

The alternative Servlet View Strategy is typically implemented by embedding HTML markup directly within Java Servlet code. Intermingling Java code and markup tags creates a poor separation of user roles within a project and increases the dependencies on the same resources among multiple members of different teams. When an individual works on a template containing unfamiliar code or tags, it increases the likelihood of an accidental change introducing problems into the  

替代性Servlet视图策略通常通过在Java Servlet代码中直接嵌入HTML标记来实现。将Java代码与标记标签混杂在一起会导致项目中用户角色的分离不佳，并增加不同团队多个成员对相同资源的依赖。当开发人员处理包含不熟悉代码或标签的模板时，意外更改导致问题的可能性会显著增加。

system. There is also a reduction in work environment efficiency (too many people sharing the same physical resource) and an increase in source control management complexity. These problems are more likely to occur in larger enterprise environments that have more complicated system requirements and that use teams of developers. They are less likely to occur with small systems that have simple business requirements and use few developers, because the same individual may likely fill the roles mentioned above. However, keep in mind that projects often start small—with simple requirements and few developers—but may ultimately evolve to become sophisticated enough to benefit from these suggestions.  

系统层面还会出现工作环境效率下降（过多人员共享同一物理资源）以及源码管理复杂度上升的问题。这些问题更易发生在具备复杂系统需求且采用团队开发模式的大型企业环境中。而对于业务需求简单、开发人员较少的小型系统，由于同一人员可能兼任上述多个角色，此类问题出现的概率较低。但需注意，项目往往始于简单需求与少量开发人员的小规模阶段，最终可能演变得足够复杂，从而需要采纳这些建议方案。

# Servlet View Strategy  

The Servlet View Strategy utilizes a servlet as the view. It is semantically equivalent to the preferred JSP View Strategy. However, the Servlet View Strategy, as seen in Example 7.18, is often more cumbersome for the software development and Web production teams because it embeds markup tags directly within the Java code. When tags are embedded within the code, the view template is more difficult to update and modify.  

Servlet视图策略采用Servlet作为视图组件，其语义与首选的JSP视图策略等效。但如示例7.18所示，该策略通常会给软件开发团队和网页制作团队带来更多不便，因为它直接将标记标签嵌入Java代码中。当标签被硬编码在程序中时，视图模板的更新与修改会变得更为困难。

# Example 7.18 Servlet View Strategy Sample Code  

public class Controller extends HttpServlet { public void init(ServletConfig config) throws ServletException { super.init(config); public void destroy() { } /\*\* Processes requests for both HTTP $\star$ <code $>$ GET $<$ /code> and <code>POST $<$ /code> methods. $\star$ @param request servlet request $\star$ @param response servlet response \*/ protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { String title $=$ "Servlet View Strategy"; try { response.setContentType("text/html"); java.io.PrintWriter out $=$ response.getWriter(); out.println("<html $>$ <title>" $^+$ title+"</title>"); out.println("<body $\mathrm{\sim}$ ");  

public class Controller extends HttpServlet { public void init(ServletConfig config) throws ServletException { super.init(config); public void destroy() { } /** 处理HTTP <code>GET</code>和<code>POST</code>方法的请求。* @param request servlet请求 * @param response servlet响应 */ protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { String title = "Servlet视图策略"; try { response.setContentType("text/html"); java.io.PrintWriter out = response.getWriter(); out.println("<html><title>" + title+"</title>"); out.println("<body>");

out.println("<h2><center>Employees List</h2>"); EmployeeDelegate delegate $=$ new EmployeeDelegate(); /\*\* ApplicationResources provides a simple API $\star$ for retrieving constants and other \* preconfigured values\*\*/ Iterator employees $=$ delegate.getEmployees( ApplicationResources.getInstance(). getAllDepartments()); out.println("<table borde $\underline{{{\mathrm{r}}}}=2>"$ ); out.println("<tr><th>First Name</th>" $^+$ "<th>Last Name</th>" + "<th>Designation</th><th>Id $<$ /th></tr>"); while (employees.hasNext()) { out.println("<tr>"); EmployeeVO emp $=$ (EmployeeVO)employees.next(); out.println("<td>" $^+$ emp.getFirstName()+ "</td>"); out.println("<td>" $^+$ emp.getLastName()+ "</td>"); out.println("<td>" $^+$ emp.getDesignation()+ "</td>"); out.println("<td>"+emp.getId()+"</td>"); out.println("</tr>"); } out.println("</table>"); out.println("<br><br>"); out.println("</body>"); out.println("</html>"); out.close(); } catch (Exception e) { LogManager.logMessage("Handle this exception", e.getMessage() );   
/\*\* Handles the HTTP <code>GET</code> method. \* @param request servlet request $\star$ @param response servlet response \*/   
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { processRequest(request, response);   
/\*\* Handles the HTTP <code>POST</code> method. \* @param request servlet request $\star$ @param response servlet response $^\star/$   
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { processRequest(request, response);   
/\*\* Returns a short description of the servlet. \*/   
public String getServletInfo() { return "Example of Servlet View. " + "JSP View is preferable.";   
/\*\* dispatcher method \*\*/   
protected void dispatch(HttpServletRequest request, HttpServletResponse response, String page)   
throws javax.servlet.ServletException, java.io.IOException { RequestDispatcher dispatcher $=$ getServletContext().getRequestDispatcher(page); dispatcher.forward(request, response);  

out.println("<h2><center>员工列表</h2>");  
EmployeeDelegate delegate = new EmployeeDelegate();  
/** ApplicationResources提供简易API  
 * 用于获取常量及其他预配置值**/  
Iterator employees = delegate.getEmployees(  
    ApplicationResources.getInstance().getAllDepartments());  
out.println("<table border=2>");  
out.println("<tr><th>名</th>" + "<th>姓</th>" + "<th>职位</th><th>ID</th></tr>");  
while (employees.hasNext()) {  
    out.println("<tr>");  
    EmployeeVO emp = (EmployeeVO)employees.next();  
    out.println("<td>" + emp.getFirstName()+ "</td>");  
    out.println("<td>" + emp.getLastName()+ "</td>");  
    out.println("<td>" + emp.getDesignation()+ "</td>");  
    out.println("<td>"+emp.getId()+"</td>");  
    out.println("</tr>");  
}  
out.println("</table>");  
out.println("<br><br>");  
out.println("</body>");  
out.println("</html>");  
out.close();  
} catch (Exception e) {  
    LogManager.logMessage("处理此异常", e.getMessage());  

/** 处理HTTP <code>GET</code>方法  
 * @param request servlet请求  
 * @param response servlet响应 */  
protected void doGet(HttpServletRequest request, HttpServletResponse response)  
    throws ServletException, java.io.IOException {  
    processRequest(request, response);  

/** 处理HTTP <code>POST</code>方法  
 * @param request servlet请求  
 * @param response servlet响应 */  
protected void doPost(HttpServletRequest request, HttpServletResponse response)  
    throws ServletException, java.io.IOException {  
    processRequest(request, response);  

/** 返回Servlet的简短描述 */  
public String getServletInfo() {  
    return "Servlet视图示例。" + "建议使用JSP视图。";  

/** 分发方法 */  
protected void dispatch(HttpServletRequest request, HttpServletResponse response, String page)  
    throws javax.servlet.ServletException, java.io.IOException {  
    RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(page);  
    dispatcher.forward(request, response);

# JavaBean Helper Strategy  

The helper is implemented as a JavaBean. Using helpers results in a cleaner separation of the view from the business processing in an application, since business logic is factored out of the view and into the helper component. In this case the business logic is encapsulated in a JavaBean, which aids in content retrieval and adapts and stores the model for use by the view.  

该助手以JavaBean形式实现。使用助手能更清晰地将视图与应用程序中的业务处理分离，因为业务逻辑从视图抽离并封装至助手组件中。本例中，业务逻辑被封装在JavaBean内，该Bean负责辅助内容检索、适配模型数据并存储模型以供视图使用。

Using the JavaBean Helper Strategy requires less upfront work than does the Custom Tag Helper Strategy, since JavaBeans are more easily constructed and integrated into a JSP environment. Additionally, even novice developers understand JavaBeans. This strategy is also easier from a manageability standpoint, since the only resulting artifacts are the completed JavaBeans. An example of this strategy is shown in Example 7.19.  

采用JavaBean辅助策略相比自定义标签辅助策略需要的前期工作更少，因为JavaBean更易于构建并集成到JSP环境中。此外，即使是新手开发者也理解JavaBean的概念。从可管理性角度来看，该策略也更简单，因为最终产物仅包含已完成的JavaBean。示例7.19展示了该策略的具体应用。

# Example 7.19 JavaBean Helper Strategy Code Sample  

<jsp:useBean id $\equiv$ "welcomeHelper" scope $=$ "request" class $=$ "corepatterns.util.WelcomeHelper" />   
<HTML>   
<BODY bgcolor $=$ "FFFFFF" $>$   
$<\%$ if (welcomeHelper.nameExists())   
{   
%>   
<center><H3> Welcome <b>   
<jsp:getProperty name $=$ "welcomeHelper" property $=$ "name" />   
</b><br><br> </H3></center>   
<%   
}   
%>   
<H4><center>Glad you are visiting our site!</center></H4>   
</BODY>   
</HTML>  

<jsp:useBean id="welcomeHelper" scope="request" class="corepatterns.util.WelcomeHelper" />   
<HTML>   
<BODY bgcolor="FFFFFF">   
<% if (welcomeHelper.nameExists())   
{   
%>   
<center><H3> 欢迎 <b>   
<jsp:getProperty name="welcomeHelper" property="name" />   
</b><br><br> </H3></center>   
<%   
}   
%>   
<H4><center>很高兴您访问我们的网站！</center></H4>   
</BODY>   
</HTML>

# Custom Tag Helper Strategy  

The helper is implemented as a custom tag (JSP $1.1+$ only). Using helpers results in a cleaner separation of the view from the business processing in an application, since business logic is factored out of the view and into the helper component. In this case the business logic is encapsulated in a custom tag component, which may aid in content retrieval and adapts the model for use by the view.  

该助手以自定义标签形式实现（仅限JSP 1.1+版本）。使用助手能更清晰地分离应用程序中的视图与业务处理逻辑，因为业务逻辑被从视图层抽离并封装至助手组件。在此场景中，业务逻辑被封装在自定义标签组件内，该组件可协助内容检索并适配模型以供视图使用。

Using the Custom Tag Helper Strategy requires more upfront work than does the JavaBean Helper Strategy, since custom tag development is moderately complicated relative to JavaBean development. Not only is there more complexity in the development process, but there is much more complexity with respect to integrating and managing the completed tags. To use this strategy, the environment must be configured with numerous generated artifacts, including the tag itself, a tag library descriptor, and configuration files. An excerpt of a JSP View using this strategy is shown in Example 7.20.  

采用**自定义标签助手策略**比**JavaBean助手策略**需要更多的前期工作，因为相较于JavaBean开发，自定义标签的开发复杂度较高。不仅开发过程更为复杂，而且在集成和管理已完成的标签方面也存在更高的复杂性。使用此策略时，环境必须配置大量生成的构件，包括标签本身、标签库描述符以及配置文件。示例7.20展示了使用该策略的JSP视图片段。

# Example 7.20 Custom Tag Helper Strategy Sample Code  

<%@ taglib uri $=$ "/web-INF/corepatternstaglibrary.tld" prefix $\equiv$ "corepatterns" %>   
<html>   
<head><title>Employee List</title></head>   
<body>   
<div align $\varepsilon$ "center">   
<h3> List of employees in <corepatterns:department attribute $=$ "id"/ $>$ department - UsingCustom Tag Helpe Strategy. $\textless/\textbar{\textmd h}3>$   
<table border $^{*=}$ "1" $>$ <tr> <th> First Name </th> <th> Last Name </th> <th> Designation </th> <th> Employee Id </th> <th> Tax Deductibles </th> <th> Performance Remarks </th> <th> Yearly Salary</th> </tr> <corepatterns:employeelist id $\varepsilon$ "employeelist_key"> <tr> <td><corepatterns:employee attribute $=$ "FirstName"/> </td> <td><corepatterns:employee attribute $=$ "LastName"/></td> <td><corepatterns:employee attribute $=$ "Designation"/> </td> <td><corepatterns:employee attribute $=$ "Id"/ $>$ </td> <td><corepatterns:employee attribute $=$ "NoOfDeductibles"/></td> <td><corepatterns:employee attribute $=$ "PerformanceRemarks"/></td> <td><corepatterns:employee attribute $=$ "YearlySalary"/></td> <td> </tr> </corepatterns:employeelist> </table>  

<%@ taglib uri="/web-INF/corepatternstaglibrary.tld" prefix="corepatterns" %>  
<html>  
<head><title>员工列表</title></head>  
<body>  
<div align="center">  
<h3> <corepatterns:department attribute="id"/> 部门员工列表 - 使用自定义标签助手策略</h3>  
<table border="1">  
<tr>  
<th>名</th>  
<th>姓</th>  
<th>职位</th>  
<th>员工编号</th>  
<th>税务抵扣项</th>  
<th>绩效评语</th>  
<th>年薪</th>  
</tr>  
<corepatterns:employeelist id="employeelist_key">  
<tr>  
<td><corepatterns:employee attribute="FirstName"/></td>  
<td><corepatterns:employee attribute="LastName"/></td>  
<td><corepatterns:employee attribute="Designation"/></td>  
<td><corepatterns:employee attribute="Id"/></td>  
<td><corepatterns:employee attribute="NoOfDeductibles"/></td>  
<td><corepatterns:employee attribute="PerformanceRemarks"/></td>  
<td><corepatterns:employee attribute="YearlySalary"/></td>  
</tr>  
</corepatterns:employeelist>  
</table>

</div> </body> </html>  

</div> </body> </html>

# Business Delegate as Helper Strategy  

Helper components often make distributed invocations to the business tier. We suggest using a business delegate in order to hide the underlying implementation details of this request, such that the helper simply invokes a business service without knowing details about its physical implementation and distribution (see “Business Delegate”).  

辅助组件通常会对业务层进行分布式调用。我们建议使用**业务委托**（Business Delegate）模式来隐藏此类请求的底层实现细节，使得辅助组件只需调用业务服务，而无需了解其物理实现与分布式部署的具体细节（参见“业务委托模式”）。

Both a helper and a business delegate may be implemented as a JavaBean. Thus, one could combine the notion of the helper component and the business delegate and implement the business delegate as a specialized type of helper. One major distinction between a helper and a business delegate, though, is as follows: A helper component is written by a developer working in the presentation tier, while the delegate is typically written by a developer working on the services in the business tier. (Note: The delegate may also be provided as part of a framework.) Thus, this strategy is as much about who actually writes the delegate as it is about the implementation. If there is some overlap in developer roles, then the business delegate as helper is a strategy to consider.  

**助手**和**业务委托**均可实现为JavaBean。因此，可将助手组件的概念与业务委托相结合，将业务委托实现为一种特殊类型的助手。然而，助手与业务委托的一个主要区别在于：助手组件由表示层开发人员编写，而委托通常由业务层服务开发人员编写（注：委托也可能作为框架的一部分提供）。因此，该策略既关乎委托的实际编写者，也关乎具体实现。若开发人员角色存在重叠，则采用"业务委托即助手"的策略值得考虑。

# Example 7.21 Business Delegate as Helper Strategy Sample Code  

/\*\*A servlet delegates to a command object helper, as shown in the following excerpt:\*\*/   
String resultPage $=$ command.execute(request, response);  

/**Servlet 将任务委托给命令对象辅助类，如下代码片段所示：**/  
String resultPage $=$ command.execute(request, response);

/\*\*The command object helper uses the business delegate, which is simply implemented as another JavaBean helper, as shown in the following excerpt:\*\*/  

/**命令对象助手使用业务委托，后者被简单地实现为另一个JavaBean助手，如下列代码片段所示：*/

AccountDelegate accountDelegate $=$ new AccountDelegate();  

AccountDelegate accountDelegate = new AccountDelegate();

# Note on Helpers:  

JavaBean helpers are best used for aiding in content retrieval and storing and adapting the model for the view. JavaBean helpers are often used as command objects as well.  

JavaBean辅助类最适合用于协助内容检索、存储以及为视图适配模型。JavaBean辅助类也常被用作命令对象。

Like JavaBean helpers, custom tag helpers may fulfill each of these roles, except for acting as a command object. Unlike JavaBean helpers, custom tag helpers are well suited to control flow and iteration within a view. Custom tag helpers used in this way encapsulate logic that would otherwise be embedded directly within the JSP as scriptlet code. Another area where custom tag helpers are preferred is formatting raw data for display. A custom tag is able to iterate over a collection of results, format those results into an HTML table, and embed the table within a JSP View without requiring any Java Scriptlet code.  

与JavaBean辅助类类似，自定义标签助手可承担除命令对象外的所有角色。不同于JavaBean辅助类，自定义标签助手特别适合在视图中控制流程和迭代操作。通过这种方式使用的自定义标签助手封装了原本需要直接以脚本代码形式嵌入JSP的逻辑。自定义标签助手的另一优势在于格式化原始数据以供显示：它能遍历结果集、将数据格式化为HTML表格，并嵌入JSP视图而无需任何Java脚本代码。

Consider an example in which a Web client is requesting account information from a system, as shown in Figure 7.14. There are five helpers shown in this diagram. The four JavaBean helpers are the AccountCommand object, Account object, AccountDAO, and AccountDetails. The sole custom tag helper is the TableFormatter object.  

考虑一个示例场景：如图7.14所示，Web客户端正在向系统请求账户信息。图中展示了五个辅助组件，其中四个JavaBean辅助组件分别是AccountCommand对象、Account对象、AccountDAO和AccountDetails，唯一的自定义标签辅助组件是TableFormatter对象。

![](images/bd0b903d00a37a12462829342fb2c4b11f33edb4b79542912897a9eb1d21748f.jpg)  
Figure 7.14. Using helpers  

图7.14 使用辅助类

The controller handles the request. It creates or looks up the appropriate command object, which is implemented as a JavaBean helper. In this case, it is a command object that processes requests for account information. The controller  

控制器负责处理请求。它会创建或查找相应的命令对象，该对象以JavaBean辅助类的形式实现。在本例中，这是一个用于处理账户信息请求的命令对象。控制器

invokes the Command object, which asks a JavaBean Account object for information about the account. The Account object invokes the business service, asking for these details, which are returned in the form of a Value object (see “Value Object”), implemented as a JavaBean.  

调用Command对象，该对象向JavaBean Account对象请求账户信息。Account对象继而调用业务服务获取这些详细信息，并以值对象（参见“值对象”）的形式返回，该值对象通过JavaBean实现。

So how does the Account object access the business services? Let us examine two cases, one simple and the other more sophisticated. In the simple case, imagine that a project is taking a phased approach, phasing Enterprise JavaBeans (EJB) into the business tier over time. Assume at the moment that the database is being accessed via JDBC calls from the presentation tier. In this case, the Account object uses a Data Access object (see “Data Access Object”), hiding the underlying implementation details of accessing the database. The Data Access object knows what SQL queries are necessary to retrieve the information. These details are hidden from the rest of the application, reducing coupling and making each component more modular and reusable. This case is described in the previous sequence diagram.  

那么Account对象如何访问业务服务？我们来看两种场景：一种简单，另一种更复杂。在简单场景中，假设项目采用分阶段实施策略，逐步将Enterprise JavaBeans (EJB)引入业务层。当前阶段假定通过表示层直接发起JDBC调用来访问数据库。此时，Account对象会使用数据访问对象（参见"数据访问对象"模式），从而隐藏底层数据库访问的实现细节。数据访问对象知晓获取信息所需的SQL查询语句，这些细节对应用程序其他部分不可见，从而降低耦合度，使每个组件更具模块化和可复用性。该场景在前文的时序图中已有描述。

When the architecture becomes more sophisticated, and EJB is introduced in the business tier, then the Data Access object is replaced with a business delegate (see “Business Delegate”), typically written by the developers of the business service. The delegate hides the implementation details of EJB lookup, invocation, and exception handling from its client. It might also improve performance by providing caching services. Again, the object reduces coupling between tiers, improving the reusability and modularity of the various components. Regardless of the specific implementation of this object, its interface may remain unchanged during this transition. Figure 7.15 describes this scenario after the transition to the business delegate.  

当架构变得更加复杂，且在业务层引入EJB时，数据访问对象会被业务委托（参见“业务委托”）取代，后者通常由业务服务的开发人员编写。该委托向客户端隐藏了EJB查找、调用及异常处理的实现细节，还可能通过提供缓存服务来提升性能。该对象再次降低了层级间的耦合度，提升了各组件的可重用性与模块化程度。无论该对象的具体实现如何变化，在此过渡阶段其接口均可保持不变。图7.15展示了过渡至业务委托后的场景。

Figure 7.15. Accessing Business Services  

图 7.15 访问业务服务

![](images/5e6175024f01aa0b7d097daa6ae7df32cff60900a2cc616d771eb3000c0507cd.jpg)  

<html><body><table><tr><td>The command object now has a handle to the AccountDetails object, which it stores before returning control to the called AccountView.jsp. The view then grabs a combination of raw data and formatted data from the AccountDetails helper and the TableFormatter helper, respectively. The TableFormatter helper is implemented as a custom tag that cycles through the raw data and formats it into an HTML table for display. As stated, this conversion requires no scriptlet code in the view, which would be necessary to perform the same functionality with a JavaBean helper. Additionally, the Account object or the AccountDetails helper could provide convenient methods to adapt the raw data in other ways. While such methods would not introduce HTML markup into the data, they might provide different combinations of data. An example is to return the full name of the user in various formats, such as "Lastname, Firstname" or "'Firstname Lastname", and so forth.</td></tr></table></body></html>  

命令对象现在持有对AccountDetails对象的引用，在将控制权返回给被调用的AccountView.jsp之前会存储该对象。视图层随后分别从AccountDetails辅助类和TableFormatter辅助类获取原始数据与格式化数据的组合。TableFormatter辅助类以自定义标签的形式实现，通过遍历原始数据将其格式化为HTML表格进行展示。如前所述，这种转换无需在视图中编写脚本代码——若使用JavaBean辅助类实现相同功能则必须编写脚本代码。此外，Account对象或AccountDetails辅助类可提供便捷方法来以其他方式适配原始数据。虽然这类方法不会在数据中引入HTML标记，但可能生成不同的数据组合。例如以多种格式返回用户全名，如"姓, 名"或"名 姓"等。

# Transformer Helper Strategy  

The helper is implemented as an eXtensible Stylesheet Language Transformer. This is particularly useful with models that exist as structured markup, such as eXtensible Markup Language (XML), either natively within legacy systems or via some form of conversion. Using this strategy can help to enforce the separation of the model from the view, since much of the view markup must be factored into a separate stylesheet.  

该助手实现为可扩展样式表语言转换器（XSLT）。这对于以结构化标记（如原生存在于遗留系统中的可扩展标记语言XML或通过某种转换形式生成的XML）存在的模型尤为实用。采用此策略有助于强化模型与视图的分离，因为大量视图标记必须被分解到独立的样式表中。

Figure 7.16 describes a potential implementation of this strategy.  

图7.16描述了该策略的一种潜在实现方案。

![](images/5cd3f9316f124f979d516ca57ab9dae84d29ee4376071f18e00b2eac42a06185.jpg)  
Figure 7.16. Sequence diagram for Transformer Helper Strategy  

图7.16 Transformer Helper策略的序列图

The controller handles the request and invokes a Command object, implemented as a JavaBean helper. The Command object initiates the retrieval of Account data. The Account object invokes the business service, which returns the data in the form of a Value Object (see “Value Object”), implemented as a JavaBean.  

控制器处理请求并调用一个作为JavaBean辅助类实现的Command对象。该Command对象启动账户数据的检索流程。Account对象调用业务服务，后者以值对象（参见“值对象”）形式返回数据，该值对象同样实现为JavaBean。

Content retrieval is complete and control is dispatched to the AccountView, which uses its custom tag transformer to manipulate the model state. The transformer relies on a stylesheet, which describes how to transform the model, typically describing how to format it with markup for display to the client. The stylesheet is usually retrieved as a static file, though it may also be dynamically generated.  

内容检索已完成，控制权被分派至`AccountView`，后者使用其自定义标签转换器来操作模型状态。该转换器依赖于一个样式表，该样式表描述了如何转换模型——通常用于定义如何通过标记语言格式化模型以展示给客户端。样式表通常作为静态文件获取，但也可能动态生成。

An example of how the custom tag helper might look in AccountView follows:  

以下是`AccountView`中自定义标签助手的示例实现：

<xsl:transform model $=$ "accounthelper" stylesheet $=$ "/transform/styles/basicaccount.xsl"/>  

<xsl:transform model="accounthelper" stylesheet="/transform/styles/basicaccount.xsl"/>

The integration of eXtensible Stylesheets and XML with JSP is evolving, as tag libraries in this area continue to mature. For now, it is a less preferred strategy, given the immature state of the supporting libraries and the additional sophisticated skills necessary to generate and maintain the stylesheets.  

可扩展样式表与XML在JSP中的集成方案正在发展中，相关领域的标签库日趋成熟。鉴于当前支持库尚未完善，且生成维护样式表需要更高阶的技能，该策略目前并非首选方案。

# Consequences  

# Improves Application Partitioning, Reuse, and Maintainability  

Using helpers results in a cleaner separation of the view from the business processing in an application. The helpers, in the form of JavaBeans (JSP $1.0+)$ and custom tags (JSP $1.1+\cdot$ ), provide a place external to the view to encapsulate business logic. Otherwise, scriptlet code clutters the JSP, a cumbersome and unwieldy situation, especially in larger projects.  

使用辅助类能实现应用程序中视图与业务处理的清晰分离。这些辅助类以 **JavaBeans**（JSP 1.0+）和自定义标签（JSP 1.1+）的形式存在，为封装业务逻辑提供了独立于视图的载体。若采用脚本片段代码，则会导致 JSP 文件杂乱臃肿——这种低效且难以维护的情形在大型项目中尤为突出。

Additionally, business logic that is factored out of JSPs and into JavaBeans and custom tags is reused, reducing duplication and easing maintenance.  

此外，从JSP中抽离并封装到JavaBeans和自定义标签中的业务逻辑可实现复用，从而减少代码重复并降低维护成本。

# Improves Role Separation  

Separating formatting logic from application business logic reduces dependencies that individuals fulfilling different roles might have on the same resources. For example, a software developer might own code that is embedded within HTML markup, while a Web production team member might need to modify page layout and design components that are intermingled with business logic. Neither individual fulfilling these roles may be familiar with the implementation specifics of the other individual's work, thus raising the likelihood of accidental modifications introducing bugs into the system.  

将格式化逻辑与应用程序业务逻辑分离，可以减少不同角色人员对相同资源的依赖。例如，软件开发人员可能拥有嵌入在HTML标记中的代码，而网页制作团队成员可能需要修改与业务逻辑混杂的页面布局和设计组件。担任这些角色的任何一方可能都不熟悉对方工作的具体实现细节，从而增加了因意外修改将错误引入系统的可能性。

# Related Patterns  

# Business Delegate  

The helper components need to access methods in the business service API. It is also important to reduce the coupling among helpers in the presentation tier and among business services in the business tier. It is recommended that a delegate be used because these tiers may be physically distributed across a network. The delegate hides from the client the underlying details of looking up and accessing the business services, and it may also provide intermediate caching to reduce network traffic.  

辅助组件需要访问业务服务API中的方法。同时，降低表示层辅助组件之间以及业务层业务服务之间的耦合度也至关重要。由于这些层级可能物理分布在网络中，建议采用委托模式。该委托向客户端隐藏了查找和访问业务服务的底层细节，并可提供中间缓存以减少网络流量。

# Dispatcher View and Service to Worker  

When centralized control becomes desirable to handle such issues as security, workflow management, content retrieval, and navigation, consider the Dispatcher View or Service to Worker patterns.  

当需要集中控制来处理诸如安全性、工作流管理、内容检索和导航等问题时，可考虑采用**Dispatcher View**或**Service to Worker**模式。

Front Controller  

前端控制器

This pattern is paired with the View Helper pattern to create the Dispatcher View pattern or Service to Worker pattern.  

该模式与视图助手模式结合使用，可形成**分发器视图模式**或**服务到工作者模式**。

# Composite View  

# Context  

Sophisticated Web pages present content from numerous data sources, using multiple subviews that comprise a single display page. Additionally, a variety of individuals with different skill sets contribute to the development and maintenance of these Web pages.  

复杂的网页通过整合多个子视图来呈现来自不同数据源的内容，这些子视图共同构成一个完整的显示页面。此外，不同技术背景的各类人员会参与这些网页的开发和维护工作。

# Problem  

Instead of providing a mechanism to combine modular, atomic portions of a view into a composite whole, pages are built by embedding formatting code directly within each view.  

页面并非通过将模块化、原子化的视图部分组合成复合整体，而是直接在各个视图中嵌入格式化代码来构建。

Modification to the layout of multiple views is difficult and error prone, due to the duplication of code.  

由于代码重复，对多个视图布局的修改既困难又容易出错。

# Forces  

• Atomic portions of view content change frequently. Multiple composite views use similar subviews, such as a customer inventory table. These atomic portions are decorated with different surrounding template text, or they appear in a different location within the page. Layout changes are more difficult to manage and code harder to maintain when subviews are directly embedded and duplicated in multiple views. Embedding frequently changing portions of template text directly into views also potentially affects the availability and administration of the system. The server may need to be restarted before clients see the modifications or updates to these template components.  

• **视图内容的原子部分频繁变更**。多个复合视图会使用相似的子视图（例如客户库存表），这些原子部分被不同的外围模板文本装饰，或出现在页面不同位置。当子视图直接嵌入并复制到多个视图中时，布局变更更难以管理，代码维护性也会降低。将频繁变更的模板文本直接嵌入视图还可能影响系统的可用性和可管理性——客户端可能需要重启服务器才能看到这些模板组件的修改或更新。

# Solution  

Use composite views that are composed of multiple atomic subviews. Each component of the template may be included dynamically into the whole and the layout of the page may be managed independently of the content.  

采用由多个原子化子视图组合而成的复合视图。模板的每个组件都可以动态地整合到整体中，且页面布局可独立于内容进行管理。

This solution provides for the creation of a composite view based on the inclusion and substitution of modular dynamic and static template fragments. It promotes the reuse of atomic portions of the view by encouraging modular design. It is appropriate to use a composite view to generate pages containing display components that may be combined in a variety of ways. This scenario occurs, for example, with portal sites that include numerous independent subviews, such as news feeds, weather information, and stock quotes on a single page. The layout of the page is managed and modified independent of the subview content.  

该解决方案支持通过包含和替换模块化的动态与静态模板片段来创建复合视图。它通过倡导模块化设计，促进视图原子化部分的复用。当需要生成包含可按多种方式组合的显示组件的页面时，采用复合视图是恰当的选择。例如门户网站场景中，单个页面可能包含新闻推送、天气信息和股票行情等多个独立子视图。页面布局的管理与修改独立于子视图内容进行。

Another benefit of this pattern is that Web designers can prototype the layout of a site, plugging static content into each of the template regions. As site development progresses, the actual content is substituted for these placeholders.  

该模式的另一优势在于，Web设计师可以通过在模板区域的各个部分插入静态内容来快速构建网站布局原型。随着开发进程推进，这些占位内容将被实际内容逐步替换。

Figure 7.17 shows a screen capture of Sun's Java homepage, java.sun.com. Four regions are identified: Navigation, Search, Feature Story, and Headlines. While the content for each of these component subviews may originate from different data sources, they are laid out seamlessly to create a single composite page.  

图7.17展示了Sun公司Java主页java.sun.com的屏幕截图。页面被划分为四个区域：导航栏、搜索栏、专题报道和头条新闻。尽管这些组件子视图的内容可能来自不同的数据源，但它们被无缝整合布局，最终呈现为一个完整的复合页面。

![](images/aeaa20377bb338913baea3a68a4f442b0657b31088aa7bb4eb54977f0cd5e410.jpg)  
Figure 7.17. Screen shot of a modular page, including Search, Navigation, Feature Story, and Headlines regions  

图7.17 模块化页面截图，包含搜索区、导航区、专题故事区和头条区

This pattern is not without its drawbacks. There is a runtime overhead associated with it, a tradeoff for the increased flexibility that it provides. Also, the use of a more sophisticated layout mechanism brings with it some manageability and development issues, since there are more artifacts to maintain and a level of implementation indirection to understand.  

该模式并非没有缺点。它存在一定的运行时开销，这是为获得更高灵活性所付出的代价。此外，由于需要维护更多构件并理解实现层面的间接性，采用更复杂的布局机制会带来一些可管理性和开发问题。

# Structure  

Figure 7.18 shows the class diagram that represents the Composite View pattern.  

图7.18展示了表示组合视图模式的类图。

# Figure 7.18. Composite View class diagram  

![](images/94ff00e41ac22fcb356417698118a3c351ce1b08fdad22564d73568afc2f8e90.jpg)  

# Participants and Responsibilities  

Figure 7.19 shows the sequence diagram for the Composite View pattern.  

图7.19展示了组合视图模式的序列图。

![](images/347d25063dd6bf9b9afb10fdba2489d4759070c915752681340c3e609298f8ba.jpg)  
Figure 7.19. Composite View sequence diagram  

图7.19 组合视图序列图

# Composite View  

A composite view is a view that is an aggregate of multiple subviews.  

组合视图是由多个子视图聚合而成的视图。

# View Manager  

The View Manager manages the inclusion of portions of template fragments into the composite view. The View Manager may be part of a standard JSP runtime engine, in the form of the standard JSP include tag (<jsp:include>), or it may be encapsulated in a JavaBean helper (JSP $1.0+$ ) or custom tag helper (JSP $1.1+\cdot$ ) to provide more robust functionality.  

视图管理器负责将模板片段整合到复合视图中。它可以是标准JSP运行时引擎的一部分（通过标准JSP包含标签`<jsp:include>`实现），也可以封装在JavaBean助手（JSP $1.0+$）或自定义标签助手（JSP $1.1+\cdot$）中，以提供更强大的功能。

A benefit of using a mechanism other than the standard include tag is that conditional inclusion is easily done. For example, certain template fragments may be included only if the user fulfills a particular role or certain system conditions are satisfied. Furthermore, using a helper component as a View Manager allows for more sophisticated control of the page structure as a whole, which is useful for creating reusable page layouts.  

采用标准`include`标签之外的机制的优势在于能轻松实现条件包含。例如，某些模板片段可以仅在用户满足特定角色或系统符合特定条件时被包含。此外，通过将辅助组件作为视图管理器(View Manager)使用，可实现对页面整体结构的更精细控制，这对创建可复用的页面布局非常有用。

# Included View  

An included view is a subview that is one atomic piece of a larger whole view. This included view could also potentially be a composite, itself including multiple subviews.  

包含视图是作为整体视图原子组成部分的子视图。该包含视图本身也可能是复合视图，内含多个子视图。

# Strategies  

# JSP View Strategy  

See “JSP View Strategy”.  

参见“JSP视图策略”。

# Servlet View Strategy  

See “Servlet View Strategy”.  

参见“Servlet视图策略”。

# JavaBean View Management Strategy  

View management is implemented using JavaBeans, as shown in Example 7.22. The view delegates to the JavaBean, which implements the custom logic to control view layout and composition. The decisions on page layout may be based on user roles or security policies, making it much more powerful than the standard JSP include functionality. While it is semantically equivalent to the Custom Tag View Management Strategy, it is not nearly as elegant, since it introduces scriptlet code into the view.  

视图管理通过JavaBeans实现，如示例7.22所示。视图将控制权委托给JavaBean，由后者实现控制视图布局与组合的自定义逻辑。页面布局决策可基于用户角色或安全策略，这使其比标准JSP包含功能更强大。尽管其语义等同于自定义标签视图管理策略，但由于在视图中引入了脚本代码，该方案远不够优雅。

Using the JavaBean View Management Strategy requires less up-front work than using the preferred Custom Tag View Management Strategy, since it is easier to construct JavaBeans and integrate them into a JSP environment. Additionally, even novice developers understand JavaBeans. This strategy is also easier from a manageability standpoint, because the completed JavaBeans are the only resulting artifacts to manage and configure.  

采用**JavaBean视图管理策略**相较于首选的**自定义标签视图管理策略**需要的前期工作更少，因为构建JavaBean并将其集成到JSP环境中更为简单。此外，即使是新手开发者也能够理解JavaBean。从可管理性角度来看，该策略也更易于操作，因为最终只需管理和配置已完成的JavaBean这一种产物。

# Example 7.22 JavaBean View Management Strategy  

<%@page import $=$ "corepatterns.compositeview.beanhelper.Conten tHelper" %>   
<% ContentHelper personalizer $=$ new ContentHelper(request); %>   
<table valign $\varepsilon$ "top" cellpadding $=$ "30%"  width $\varepsilon$ "100%"> <% if (personalizer.hasWorldNewsInterest() ) { %> <tr> <td><jsp:getProperty name $=$ "feeder" property $=$ "worldNews"/></td> </tr> <% } if ( personalizer.hasCountryNewsInterest() ) { %> <tr> <td><jsp:getProperty name $=$ "feeder" property $=$ "countryNews"/ $^{\prime}><$ /td> </tr> <% } if ( personalizer.hasCustomNewsInterest() ) { %> <tr> <td><jsp:getProperty name $=$ "feeder"  

<%@page import $=$ "corepatterns.compositeview.beanhelper.Conten tHelper" %>  
<% ContentHelper personalizer $=$ new ContentHelper(request); %>  
<table valign $\varepsilon$ "top" cellpadding $=$ "30%"  width $\varepsilon$ "100%"> <% if (personalizer.hasWorldNewsInterest() ) { %> <tr> <td><jsp:getProperty name $=$ "feeder" property $=$ "worldNews"/></td> </tr> <% } if ( personalizer.hasCountryNewsInterest() ) { %> <tr> <td><jsp:getProperty name $=$ "feeder" property $=$ "countryNews"/ $^{\prime}><$ /td> </tr> <% } if ( personalizer.hasCustomNewsInterest() ) { %> <tr> <td><jsp:getProperty name $=$ "feeder"

property $=$ "customNews"/></td> </tr> <% if ( personalizer.hasAstronomyInterest() ) { %> <tr> <td><jsp:getProperty name $=$ "feeder" property $=$ "astronomyNews"/ $><$ /td> </tr> <% } %> /table>  

property $=$ "customNews"/></td> </tr> <% if ( personalizer.hasAstronomyInterest() ) { %> <tr> <td><jsp:getProperty name $=$ "feeder" property $=$ "astronomyNews"/ $><$ /td> </tr> <% } %> /table>

# Standard Tag View Management Strategy  

View management is implemented using standard JSP tags, such as the <jsp:include> tag. Using standard tags for managing the layout and composition of views is an easy strategy to implement, but does not provide the power and flexibility of the preferred Custom Tag View Management Strategy, since the layout for individual pages remains embedded within that page. Thus, while this strategy allows for the underlying content to vary dynamically, any site-wide layout changes would require individual modifications to numerous JSPs. This is shown in Example 7.23.  

视图管理通过标准JSP标签实现，例如`<jsp:include>`标签。使用标准标签管理视图布局和组合是一种易于实现的策略，但无法提供首选的自定义标签视图管理策略的强力和灵活性，因为单个页面的布局仍嵌入在该页面中。因此，虽然该策略允许底层内容动态变化，但任何全站范围的布局变更都需要对多个JSP文件进行单独修改。如示例7.23所示。

# Example 7.23 Standard Tag View Management Strategy  

<html>   
<body>   
<jsp:include page $=$ "/jsp/CompositeView/javabean/banner.html" flush $\varepsilon$ "true"/>   
<table width $\varepsilon$ "100%"> <tr align $\cdot^{=}$ "left" valign $\equiv$ "middle"> <td width $="20\%$ "> <jsp:include page $=$ "/jsp/CompositeView/javabean/ProfilePane.jsp" flush $\varepsilon$ "true"/>  

<html>  
<body>  
<jsp:include page="/jsp/CompositeView/javabean/banner.html" flush="true"/>  
<table width="100%"> <tr align="left" valign="middle"> <td width="20%"> <jsp:include page="/jsp/CompositeView/javabean/ProfilePane.jsp" flush="true"/>  

（注：根据规则3，代码块中的JSP标签及文件路径均保留原文未翻译）

</td> <td width $\equiv$ "70%" align $\varepsilon$ "center"> <jsp:include page $=$ "/jsp/CompositeView/javabean/mainpanel.jsp" flush $\varepsilon$ "true"/> </td> </tr> </table> <jsp:include page $=$ "/jsp/CompositeView/javabean/footer.html" flush $\equiv$ "true"/> </body> </html>  

</td> <td width $\equiv$ "70%" align $\varepsilon$ "center"> <jsp:include page $=$ "/jsp/CompositeView/javabean/mainpanel.jsp" flush $\varepsilon$ "true"/> </td> </tr> </table> <jsp:include page $=$ "/jsp/CompositeView/javabean/footer.html" flush $\equiv$ "true"/> </body> </html>  

（注：根据规则3要求，代码块中的JSP标签、文件路径及HTML属性均保持原样未翻译）

When creating a composite display using standard tags, both static content, such as an HTML file, and dynamic content, such as a JSP, can be included. Additionally, the content can be included at translation time or at runtime. If the content is included at translation time, then the page display will remain unchanged until the JSP is recompiled, at which point any modifications to included content will be visible. In other words, the page is laid out and generated once, each time the JSP is recompiled. Example 7.24 shows an excerpt of a JSP that generates a composite page in this way, using the standard JSP include directive $<\frac{\circ}{\circ}\textcircled{<}$ include $\%>.$ , which includes content at translation time.  

使用标准标签创建复合显示时，既可包含静态内容（如HTML文件），也可包含动态内容（如JSP）。此外，内容的包含时机可选择在翻译时或运行时。若在翻译时包含内容，则页面显示将保持不变直至JSP重新编译，此时对包含内容的所有修改才会生效。换言之，每次JSP重新编译时，页面布局和生成仅执行一次。示例7.24展示了通过标准JSP包含指令`<%@ include %>`（该指令在翻译时包含内容）生成复合页面的JSP代码片段。

Runtime inclusion of content means that changes to underlying subviews are visible in the composite page the next time a client accesses the page. This is much more dynamic and can be accomplished using the standard JSP include tag <jsp:include>, as shown in Example 7.25. There is of course some runtime overhead associated with this type of view generation, but it is the tradeoff for the increased flexibility of on-the-fly content modifications.  

运行时内容包含意味着当客户端再次访问页面时，对底层子视图的修改会立即反映在组合页面上。这种方式更具动态性，可通过标准JSP包含标签`<jsp:include>`实现（如示例7.25所示）。当然，这类视图生成方式会带来一定的运行时开销，但这是为实现动态内容修改的灵活性所必须付出的代价。

# Example 7.24 Composite View with Translation--Time Content Inclusion  

<table border $=1$ valign $=$ "top" cellpadding $=$ "2%" width $="100\%$ "> <tr> <td><%@ file $=$ "news/worldnews.html" %> </td> </tr> <tr> <td><%@ file $=$ "news/countrynews.html" %> </td> </tr> <tr>  

<table border $=1$ valign $=$ "top" cellpadding $=$ "2%" width $="100\%$ "> <tr> <td><%@ file $=$ "news/worldnews.html" %> </td> </tr> <tr> <td><%@ file $=$ "news/countrynews.html" %> </td> </tr> <tr>

<td><%@ file $=$ "news/customnews.html" %> </td> </tr> <tr> <td><%@ file $=$ "news/astronomy.html" %> </td> </tr> </table>  

<td><%@ file $=$ "news/customnews.html" %> </td> </tr> <tr> <td><%@ file $=$ "news/astronomy.html" %> </td> </tr> </table>

# Example 7.25 Composite View with Runtime Content Inclusion  

<table border $=1$ valign $=$ "top" cellpadding $=$ "2%" width $\varepsilon$ "100%"> <tr> <td><jsp:include page $=$ "news/worldnews.jsp" flush $\varepsilon$ "true"/> </td> </tr> <tr> <td><jsp:include page $=$ "news/countrynews.jsp" flush $\varepsilon$ "true"/> </td> </tr> <tr> <td><jsp:include page $=$ "news/customnews.jsp" flush $\varepsilon$ "true"/> </td> </tr> <tr> <td><jsp:include page $=$ "news/astronomy.jsp" flush $\varepsilon$ "true"/> </td> </tr>   
</table>  

<table border $=1$ valign $=$ "top" cellpadding $=$ "2%" width $\varepsilon$ "100%"> 
<tr> 
<td><jsp:include page $=$ "news/worldnews.jsp" flush $\varepsilon$ "true"/> </td> 
</tr> 
<tr> 
<td><jsp:include page $=$ "news/countrynews.jsp" flush $\varepsilon$ "true"/> </td> 
</tr> 
<tr> 
<td><jsp:include page $=$ "news/customnews.jsp" flush $\varepsilon$ "true"/> </td> 
</tr> 
<tr> 
<td><jsp:include page $=$ "news/astronomy.jsp" flush $\varepsilon$ "true"/> </td> 
</tr>   
</table>

# Custom Tag View Management Strategy  

View management is implemented using custom tags $(\mathtt{J S P1.1+})$ , which is the preferred strategy. Logic implemented within the tag controls view layout and composition. These tags are much more powerful and flexible than the standard JSP include tag, but also require a higher level of effort. Custom actions can base page layout and composition on such things as user roles or security policies.  

视图管理通过自定义标签$(\mathtt{J S P1.1+})$实现，这是推荐策略。标签内部封装的逻辑控制着视图布局与组合。这些标签比标准JSP包含标签更强大灵活，但也需要更高的实现成本。自定义动作可根据用户角色或安全策略等要素来决定页面布局与组合。

Using this strategy requires more upfront work than do the other view management strategies, since custom tag development is more complicated than simply using JavaBeans or standard tags. Not only is there more complexity in the development process, but there is much more complexity with respect to integrating and  

采用此策略相比其他视图管理方案需要更多前期工作，因为自定义标签的开发比单纯使用JavaBeans或标准标签更为复杂。不仅开发过程复杂度更高，在集成与部署环节也存在显著复杂性。

managing the completed tags. Using this strategy requires the generation of numerous artifacts, including the tag itself, a tag library descriptor, configuration files, and configuring the environment with these artifacts.  

管理已完成的标签。采用此策略需要生成大量构件，包括标签本身、标签库描述符、配置文件，以及使用这些构件配置环境。

The following JSP excerpt shows a possible implementation of this strategy and is excerpted from Example 7.26. Please refer to that code sample for more detail.  

以下JSP代码片段展示了该策略的一种可能实现，摘录自示例7.26。具体细节请参考该代码示例。

<region:render template $=$ '/jsp/CompositeView/templates/portal.jsp'>   
<region:put section $\varepsilon$ 'banner' content $=$ '/jsp/CompositeView/templates/banner.jsp'   
<region:put section $=$ 'controlpanel' content $=$ '/jsp/CompositeView/templates/ProfilePane.jsp' />   
<region:put section $\varepsilon$ 'mainpanel' content $=$ '/jsp/CompositeView/templates/mainpanel.jsp' />   
<region:put section $.=\cdot$ footer' content $=$ '/jsp/CompositeView/templates/footer.jsp' />   
</region:render>  

<region:render template $=$ '/jsp/CompositeView/templates/portal.jsp'>   
<region:put section $\varepsilon$ 'banner' content $=$ '/jsp/CompositeView/templates/banner.jsp'   
<region:put section $=$ 'controlpanel' content $=$ '/jsp/CompositeView/templates/ProfilePane.jsp' />   
<region:put section $\varepsilon$ 'mainpanel' content $=$ '/jsp/CompositeView/templates/mainpanel.jsp' />   
<region:put section $.=\cdot$ footer' content $=$ '/jsp/CompositeView/templates/footer.jsp' />   
</region:render>

# Transformer View Management Strategy  

View management is implemented using an XSL Transformer. This strategy would typically be combined with the Custom Tag View Management Strategy, using custom tags to implement and delegate to the appropriate components. Using this strategy can help to enforce the separation of the model from the view, since much of the view markup must be factored into a separate stylesheet. At the same time, it involves technologies that require new and sophisticated skill sets to implement correctly, an issue that makes this strategy impractical in many environments where these technologies are not already established.  

视图管理通过XSL Transformer实现。该策略通常与**自定义标签视图管理策略**结合使用，利用自定义标签来**实现**并委托给相应组件。采用此策略有助于强化模型与视图的分离，因为大量视图标记必须被分解到独立的样式表中。但与此同时，该策略涉及需要全新且复杂技术栈才能正确**实现**的技术，这一特性使其在许多尚未采用相关技术的环境中缺乏可行性。

The following excerpt shows the use of a custom tag from within a JSP to convert a model using a stylesheet and transformer:  

以下代码片段展示了在JSP中使用自定义标签，通过样式表和转换器对模型进行转换：

# Early-Binding Resource Strategy  

This is another name for translation-time content inclusion, as described in the Standard Tag View Management Strategy and shown in Example 7.24. It is appropriate for maintaining and updating a relatively static template and is recommended if a view includes headers and footers that change infrequently.  

这是翻译时内容包含的另一种称谓，如标准标签视图管理策略所述并在示例7.24中展示。该方式适用于维护和更新相对静态的模板，若视图包含不常变更的页眉页脚，则推荐采用此方案。

# Late-Binding Resource Strategy  

This is another name for runtime-content inclusion, as described in the Standard Tag View Management Strategy and shown in Example 7.25. It is appropriate for composite pages that may change frequently. One note: If the subview included at runtime is a dynamic resource, such as a JSP, then this subview may also be a composite view, including more runtime content. The flexibility offered by such nested composite structures should be weighed against their runtime overhead and considered in light of specific project requirements.  

这是运行时内容包含的另一种称谓，如标准标签视图管理策略所述并在示例7.25中所示。该方式适用于可能频繁变更的复合页面。需注意：若运行时包含的子视图是动态资源（例如JSP），则该子视图本身也可能是复合视图，可包含更多运行时内容。此类嵌套复合结构提供的灵活性应与其运行时开销进行权衡，并需结合具体项目需求考量。

# Consequences  

# Improves Modularity and Reuse  

The pattern promotes modular design. It is possible to reuse atomic portions of a template, such as a table of stock quotes, in numerous views and to decorate these reused portions with different information. This pattern permits the table to be moved into its own module and simply included where necessary. This type of dynamic layout and composition reduces duplication, fosters reuse, and improves maintainability.  

该模式提倡模块化设计。模板中的原子部分（例如股票报价表）可在多个视图中复用，并能用不同信息装饰这些复用部分。该模式允许将表格移至独立模块中，仅在需要时引入。这种动态布局与组合方式减少了重复代码，促进了复用性，并提升了可维护性。

# Enhances Flexibility  

A sophisticated implementation may conditionally include view template fragments based on runtime decisions, such as user role or security policy.  

成熟的实现方案可根据运行时决策（如用户角色或安全策略）有条件地包含视图模板片段。

# Enhances Maintainability and Manageability  

It is much more efficient to manage changes to portions of a template when the template is not hardcoded directly into the view markup. When kept separate from the view, it is possible to modify modular portions of template content independent of the template layout. Additionally, these changes are available to the client immediately, depending on the implementation strategy. Modifications to the layout of a page are more easily managed as well, since changes are centralized.  

将模板直接硬编码到视图标记中时，管理模板局部变更的效率远低于分离式管理。当模板与视图保持分离时，可以独立于模板布局修改内容的模块化部分。根据具体实现策略，这些变更还能立即对客户端生效。由于所有修改都集中处理，页面布局的调整也会变得更加容易管理。

# Reduces Manageability  

Aggregating atomic pieces of the display together to create a single view introduces the potential for display errors, since subviews are page fragments. This is a limitation that can become a manageability issue. For example, if a JSP page is generating an HTML page using a main page that includes three subviews, and the subviews each include the HTML open and close tag (that is, <HTML> and ${<}/\mathrm{HTML>}$ ), then the composed page will be invalid. Thus, it is important when using this pattern to be aware that subviews must not be complete views. Tag usage must be accounted for quite strictly in order to create valid composite views, and this can become a manageability issue.  

将原子化的显示片段聚合为单一视图时，由于子视图是页面片段，可能引发显示错误。这种限制会演变为可维护性问题。例如，若某个JSP页面通过主页面（包含三个子视图）生成HTML页面，而子视图各自包含HTML开闭标签（即`<HTML>`和`</HTML>`），最终合成的页面将无效。因此使用该模式时必须注意：**子视图绝不能是完整视图**。必须严格规范标签使用才能构建有效的复合视图，而这可能成为可维护性隐患。

# Performance Impact  

Generating a display that includes numerous subviews may slow performance. Runtime inclusion of subviews will result in a delay each time the page is served to the client. In an environment with strict Service Level Agreements that mandate specific response times, such performance slowdowns, though typically extremely minimal, may not be acceptable. An alternative is to move the subview inclusion to translation time, though this limits the subview to changing when the page is retranslated.  

生成包含大量子视图的显示可能会降低性能。在运行时动态包含子视图会导致每次向客户端提供页面时产生延迟。在具有严格服务级别协议（SLA）要求特定响应时间的环境中，此类性能下降（尽管通常极其微小）可能无法接受。另一种方案是将子视图包含操作移至翻译阶段完成，但这会限制子视图仅在页面重新翻译时才能变更。

# Sample Code  

The Composite View pattern can be implemented using any number of strategies, but one of the more popular is the Custom Tag View Management Strategy. In fact, there are a number of custom tag libraries currently available for implementing composite views that separate view layout from view content and provide for modular and pluggable template subviews.  

组合视图模式可通过多种策略实现，其中较流行的是**自定义标签视图管理策略**。实际上，现有多个自定义标签库可用于实现组合视图，这些库将视图布局与视图内容分离，并提供模块化、可插拔的模板子视图。

This sample will use a template library written by David Geary and featured in detail in “Advanced JavaServer Pages” [Geary].  

本示例将使用由David Geary编写的模板库，该库在《Advanced JavaServer Pages》[Geary]一书中有详细讲解。

The template library describes three basic components: sections, regions, and templates.  

模板库描述了三个基本组件：**区块**、**区域**和**模板**。

• A section is a reusable component that renders HTML or JSP.   
• A region describes content by defining sections. A template controls the layout of regions and sections in a rendered page.  

• 一个**section**是可复用的组件，用于渲染HTML或JSP。  
• 一个**region**通过定义sections来描述内容。模板控制渲染页面中regions和sections的布局。

A region can be defined and rendered as shown in Example 7.26.  

可按示例7.26所示方式定义和渲染区域。

# Example 7.26 A Region and Sections  

<region:render template $=$ 'portal.jsp'> <region:put section $\varepsilon$ 'banner' content $=$ 'banner.jsp' /> <region:put section $=$ 'controlpanel' content $=$ 'ProfilePane.jsp' /> <region:put section $\varepsilon$ 'mainpanel' content $=$ 'mainpanel.jsp' /> <region:put section $=$ 'footer' content $=1$ footer.jsp' />   
</region:render>  

<region:render template $=$ 'portal.jsp'> <region:put section $\varepsilon$ 'banner' content $=$ 'banner.jsp' /> <region:put section $=$ 'controlpanel' content $=$ 'ProfilePane.jsp' /> <region:put section $\varepsilon$ 'mainpanel' content $=$ 'mainpanel.jsp' /> <region:put section $=$ 'footer' content $=1$ footer.jsp' />   
</region:render>

A region defines its content by matching logical section names with a portion of content, such as banner.jsp.  

区域通过将逻辑区块名称（如`banner.jsp`）与内容片段进行匹配来定义其内容。

The layout for the region and its sections is defined by a template, to which each region is associated. In this case, the template is named portal.jsp, as defined in Example 7.27.  

区域及其分区的布局由模板定义，每个区域均与模板相关联。本例中，如示例7.27所定义，该模板名为portal.jsp。

# Example 7.27 Template Definition  

<region:render section $=$ 'banner'/>   
<table width $="100\%$ "> <tr align $\varepsilon$ "left" valign $\cdot^{=}$ "middle"> <td width $\varepsilon$ "20%"> $<!--$ menu region --> <region:render section $\equiv$ 'controlpanel' /> </td> <td width $\varepsilon$ "70%" align $\equiv$ "center"> $<!--$ contents -- <region:render section $\equiv$ 'mainpanel' /> </td> </tr>   
</table>  

<region:render section $=$ 'banner'/>   
<table width $="100\%$ "> <tr align $\varepsilon$ "left" valign $\cdot^{=}$ "middle"> <td width $\varepsilon$ "20%"> $<!--$ 菜单区域 --> <region:render section $\equiv$ 'controlpanel' /> </td> <td width $\varepsilon$ "70%" align $\equiv$ "center"> $<!--$ 内容区域 --> <region:render section $\equiv$ 'mainpanel' /> </td> </tr>   
</table>

A site with numerous views and a single consistent layout has one JSP containing code that looks similar to the template definition in Example 7.27, and many JSPs that look similar to Example 7.26, defining alternate regions and sections.  

一个具有众多视图且采用统一布局的站点，会包含一个类似示例7.27模板定义的JSP文件，以及多个类似示例7.26的JSP文件，这些文件定义了不同的区域和区块。

Sections are JSP fragments that are used as subviews to build a composite whole as defined by a template. The banner.jsp section is shown in Example 7.28.  

**节段**是JSP片段，它们作为子视图用于构建由模板定义的复合整体。示例7.28展示了`banner.jsp`节段。

# Example 7.28 Section Subview-banner.jsp  

<table width $\varepsilon$ "100%" bgcolor $=$ "#C0C0C0">  
<tr align $\equiv$ "left" valign $\varepsilon$ "middle"><td width $\equiv$ "100%"><TABLE ALIGN $\cong$ "left" BORDER $=1$ WIDTH $=$ "100%"><TR ALIGN $\cong$ "left" VALIGN $\cong$ "middle"><TD>Logo</TD><TD $>$ <center>Sun Java Center</TD></TR></TABLE></td>  
</tr>  
</table>  

<table width="100%" bgcolor="#C0C0C0">  
<tr align="left" valign="middle"><td width="100%"><TABLE ALIGN="left" BORDER=1 WIDTH="100%"><TR ALIGN="left" VALIGN="middle"><TD>Logo</TD><TD> <center>Sun Java Center</TD></TR></TABLE></td>  
</tr>  
</table>  

注：原文中存在特殊符号（如$\varepsilon$、$\equiv$、$\cong$），根据HTML规范修正为标准属性格式。保留所有HTML标签及英文专有名词"Sun Java Center"不翻译。

Composite views are a modular, flexible and extensible way to build JSP views for your J2EE application.  

组合视图是一种模块化、灵活且可扩展的方式，用于为您的J2EE应用程序构建JSP视图。

# Related Patterns  

# View Helper  

The Composite View pattern may be used as the view in the View Helper pattern.  

组合视图模式可作为视图助手模式中的视图使用。

# Composite [GoF]  

The Composite View pattern is based on the Composite pattern, which describes part-whole hierarchies where a composite object is comprised of numerous pieces, all of which are treated as logically equivalent.  

组合视图模式基于组合模式，该模式描述了部分-整体的层次结构，其中组合对象由多个部分组成，所有这些部分在逻辑上被视为等效。

# Service to Worker  

# Context  

The system controls flow of execution and access to business data, from which it creates presentation content.  

该系统控制执行流程和业务数据访问，并据此生成呈现内容。

# Note  

The Service to Worker pattern, like the Dispatcher View pattern, describes a common combination of other patterns from the catalog. Both of these macro patterns describe the combination of a controller and dispatcher with views and helpers. While describing this common structure, they emphasize related but different usage patterns.  

服务工作者（Service to Worker）模式与分发器视图（Dispatcher View）模式类似，均描述了模式目录中其他模式的常见组合方式。这两种宏观模式都展现了控制器与分发器结合视图及辅助组件的结构。在描述这一通用架构时，它们强调了相关但不同的使用模式。

# Problem  

The problem is a combination of the problems solved by the Front Controller and View Helper patterns in the presentation tier. There is no centralized component for managing access control, content retrieval, or view management, and there is duplicate control code scattered throughout various views. Additionally, business logic and presentation formatting logic are intermingled within these views, making the system less flexible, less reusable, and generally less resilient to change.  

该问题综合了表现层中**前端控制器**与**视图助手**模式所解决的多个问题。当前系统缺乏用于集中管理访问控制、内容检索或视图管理的核心组件，且重复的控制代码分散在各个视图中。此外，业务逻辑与表现层格式化逻辑在这些视图中相互混杂，导致系统灵活性降低、可复用性减弱，整体上对变更的适应能力较差。

Intermingling business logic with view processing also reduces modularity and provides a poor separation of roles among Web production and software development teams.  

将业务逻辑与视图处理混杂会降低模块化程度，导致Web生产团队与软件开发团队之间的职责分离不清晰。

# Forces  

• Authentication and authorization checks are completed per request.   
· Scriptlet code within views should be minimized.   
• Business logic should be encapsulated in components other than the view.   
• Control flow is relatively complex and based on values from dynamic content. View management logic is relatively sophisticated, with multiple views potentially mapping to the same request.  

• 每个请求均需完成身份验证与授权检查  
· 视图中的脚本代码应保持最小化  
• 业务逻辑应封装在视图之外的组件中  
• 控制流基于动态内容取值且较为复杂，视图管理逻辑相对精密，单个请求可能映射多个视图

# Solution  

Combine a controller and dispatcher with views and helpers (see “Front Controller” and “View Helper”) to handle client requests and prepare a dynamic presentation as the response. Controllers delegate content retrieval to helpers, which manage the population of the intermediate model for the view. A dispatcher is responsible for view management and navigation and can be encapsulated either within a controller or a separate component.  

将控制器与分发器结合视图及辅助组件（参见“前端控制器”与“视图助手”）共同处理客户端请求，并生成动态响应内容。控制器将内容获取逻辑委托给助手组件，由助手负责为视图填充中间模型数据。分发器承担视图管理与导航职责，可被封装在控制器内部或作为独立组件存在。

Service to Worker describes the combination of the Front Controller and View Helper patterns with a dispatcher component.  

服务工作者模式描述了前端控制器与视图助手模式的结合，并包含一个调度器组件。

While this pattern and the Dispatcher View pattern describe a similar structure, the two patterns suggest a different division of labor among the components. In Service to Worker, the controller and the dispatcher have more responsibilities.  

虽然该模式与Dispatcher View模式描述了类似的结构，但两种模式对组件间的职责划分存在差异。在Service to Worker模式中，控制器与Dispatcher承担了更多职责。

Since the Service to Worker and Dispatcher View patterns represent a common combination of other patterns from the catalog, each warrants its own name to promote efficient communication among developers. Unlike the Service to Worker pattern, the Dispatcher View pattern suggests deferring content retrieval to the time of view processing.  

由于Service to Worker和Dispatcher View模式代表了模式目录中其他模式的常见组合，因此每种模式都值得拥有自己的名称以促进开发人员之间的高效沟通。与Service to Worker模式不同，Dispatcher View模式建议将内容检索推迟到视图处理阶段进行。

In the Dispatcher View pattern, the dispatcher typically plays a limited to moderate role in view management. In the Service to Worker pattern, the dispatcher typically plays a moderate to large role in view management.  

在Dispatcher View模式中，调度器通常在视图管理中扮演有限至中等的角色。而在Service to Worker模式中，调度器则通常在视图管理中承担中等至较大的职责。

A limited role for the dispatcher occurs when no outside resources are utilized in order to choose the view. The information encapsulated in the request is sufficient to determine the view to dispatch the request. For example,  

当无需借助外部资源来选择视图时，调度器的作用将受到限制。此时请求中封装的信息已足以确定用于派发请求的视图。例如，

http://some.server.com/servlet/Controller?next $=$ login.jsp  

http://some.server.com/servlet/Controller?next $=$ login.jsp

The sole responsibility of the dispatcher component in this case is to dispatch to the view login.jsp.  

在此场景下，调度器组件的唯一职责是分发至视图 login.jsp。

An example of the dispatcher playing a moderate role is the case where the client submits a request directly to a controller with a query parameter that describes an action to be completed:  

调度器发挥适度作用的一个典型场景是：客户端直接向控制器提交请求，并通过查询参数指定待执行的操作。

http://some.server.com/servlet/Controller?action $\cdot^{=}$ login  

http://some.server.com/servlet/Controller?action $\cdot^{=}$ login

The responsibility of the dispatcher component here is to translate the logical name login into the resource name of an appropriate view, such as login.jsp, and dispatch to that view. To accomplish this translation, the dispatcher may access resources such as an XML configuration file that specifies the appropriate view to display.  

此处调度器组件的职责是将逻辑名称`login`转换为对应视图的资源名称（如`login.jsp`），并将请求派发至该视图。为实现此转换，调度器可访问诸如XML配置文件等资源，这些文件规定了需展示的具体视图。

On the other hand, in the Service to Worker pattern, the dispatcher might be more sophisticated. The dispatcher may invoke a business service to determine the appropriate view to display.  

另一方面，在Service to Worker模式中，调度器可能更为复杂。该调度器可能会调用业务服务来确定要显示的合适视图。

The shared structure of Service to Worker and Dispatcher View consists of a controller working with a dispatcher, views, and helpers.  

Service to Worker与Dispatcher View的共享结构由控制器、调度器、视图和辅助组件协同工作构成。

# Structure  

The class diagram in Figure 7.20 represents the Service to Worker pattern.  

图7.20中的类图展示了Service to Worker模式。

# Figure 7.20. Service to Worker class diagram  

![](images/dfc0686dfeb685480f78a009af30e56f34f07cb7a2dc973b666339f9f1b341b8.jpg)  

# Participants and Responsibilities  

Figure 7.21 shows the sequence diagram that represents the Service to Worker pattern.  

图7.21展示了表示Service to Worker模式的序列图。

![](images/e3c889c39c4c4580bd56c6f5cde4b1bc87d190b581b82d751e9eaeaabfcdf72a.jpg)  
Figure 7.21. Service to Worker sequence diagram  

图7.21. Service to Worker模式时序图

As stated, Service to Worker and Dispatcher View represent a similar structure. The main difference is that Service to Worker describes architectures with more behavior “up front” in the controller and dispatcher, while Dispatcher View describes architectures with more behavior moved back to the time of view processing. Thus, the two patterns suggest a continuum, where behavior is either encapsulated closer to the front or moved farther back in the process flow.  

如前所述，Service to Worker 和 Dispatcher View 呈现了相似的结构。主要区别在于：Service to Worker 描述的架构将更多行为"前置"在控制器和调度器中，而 Dispatcher View 描述的架构则将更多行为推迟到视图处理阶段执行。因此，这两种模式体现了一个连续区间——行为要么被封装在流程的前端，要么被后移至流程的更后端。

# Controller  

The controller is typically the initial contact point for handling a request. It works with a dispatcher to complete view management and navigation. The controller manages authentication, authorization, content retrieval, validation, and other aspects of request handling. It delegates to helpers to complete portions of this work.  

控制器通常是处理请求的初始接触点。它与调度器协作完成视图管理和导航工作。控制器负责管理身份验证、授权、内容检索、验证等请求处理环节，并通过委托给辅助组件来完成这些工作的各个部分。

# Dispatcher  

A dispatcher is responsible for view management and navigation, managing the choice of the next view to present to the user and providing the mechanism for vectoring control to this resource.  

分发器负责视图管理与导航，管理向用户呈现的下一视图选择，并提供将控制流转至该资源的机制。

A dispatcher can be encapsulated within a controller (see “Front Controller”) or it can be a separate component working in coordination with the controller. The dispatcher can provide static dispatching to the view or it may provide a more sophisticated dynamic dispatching mechanism.  

调度器可以封装在控制器内部（参见“前端控制器”模式），也可以作为独立组件与控制器协同工作。调度器可提供静态视图分发功能，亦可实现更复杂的动态分发机制。

The dispatcher uses the RequestDispatcher object (supported in the servlet specification), but it also typically encapsulates some additional processing. The more responsibilities that this component encapsulates, the more it fits into the Service to Worker pattern. Conversely, when the dispatcher plays a more limited role, it fits more closely into the Dispatcher View pattern.  

分发器使用Servlet规范支持的`RequestDispatcher`对象，但通常还会封装额外的处理逻辑。该组件封装的责任越多，就越符合"服务到工作者"模式；反之，当分发器仅承担有限职责时，则更贴近"分发器视图"模式。

# View  

A View represents and displays information to the client. The information that is used in a display is retrieved from a model. Helpers support views by encapsulating and adapting a model for use in a display.  

视图（View）负责向客户端呈现并展示信息。显示所用的信息从模型中获取。助手（Helper）通过封装和适配模型以支持视图的展示功能。

# Helper  

A helper is responsible for helping a view or controller complete its processing. Thus, helpers have numerous responsibilities, including gathering data required by the view and storing this intermediate model, in which case the helper is sometimes referred to as a value bean. Additionally, helpers may adapt this data model for use by the view. Helpers can service requests for data from the view by simply providing access to the raw data or by formatting the data as Web content.  

助手（helper）负责协助视图或控制器完成其处理流程。因此，助手承担多项职责，包括收集视图所需数据并存储这些中间模型（此时助手有时被称为值Bean）。此外，助手可能对数据模型进行适配以供视图使用。助手可通过两种方式响应视图的数据请求：直接提供原始数据访问，或将数据格式化为Web内容。

A view may work with any number of helpers, which are typically implemented as JavaBeans (JSP $1.0+)$ and custom tags (JSP $1.1+\cdot$ . Additionally, a helper may represent a Command object or a delegate (see “Business Delegate”).  

视图可与任意数量的辅助对象协作，这些辅助对象通常以 **JavaBeans**（JSP 1.0+）和自定义标签（JSP 1.1+）形式实现。此外，辅助对象也可表现为 **Command 对象** 或委托（参见“业务委托”模式）。

# ValueBean  

A value bean is another name for a helper that is responsible for holding intermediate model state for use by a view. A typical case, as shown in the sequence diagram in Figure 7.12, has the business service returning a value bean in response to a request. In this case, ValueBean fulfills the role of a Value Object (see “Value Object”).  

值对象Bean（ValueBean）是辅助类的别称，其职责是持有供视图使用的中间模型状态。如图7.12序列图所示，典型场景中业务服务会响应请求返回一个值对象Bean。此时ValueBean承担着值对象（参见"值对象"章节）的角色。

# BusinessService  

The business service is a role that is fulfilled by the service the client is seeking to access. Typically, the business service is accessed via a Business delegate. The business delegate's role is to provide control and protection for the business service (see the “Business Delegate”).  

业务服务是由客户端试图访问的服务所实现的角色。通常，业务服务通过**业务委托（Business Delegate）**进行访问。业务委托的作用是为业务服务提供控制与保护（参见“业务委托”章节）。

# Strategies  

# Servlet Front Strategy  

See “Servlet Front Strategy”.  

参见“Servlet前端策略”。

# JSP Front Strategy  

See “JSP Front Strategy”.  

参见“JSP前端策略”。

# JSP View Strategy  

See “JSP View Strategy”.  

参见“JSP视图策略”。

# Servlet View Strategy  

See “Servlet View Strategy”.  

参见“Servlet视图策略”。

# JavaBean Helper Strategy  

See “JavaBean Helper Strategy”.  

参见“JavaBean Helper 策略”。

# Custom Tag Helper Strategy  

See “Custom Tag Helper Strategy”.  

参见“自定义标签助手策略”。

# Dispatcher in Controller Strategy  

See “Dispatcher in Controller Strategy”.  

参见“控制器中的分发器策略”。

As stated, the Service to Worker and Dispatcher View patterns suggest a continuum, where behavior is encapsulated closer to the front or moved farther back in the process flow. Figure 7.22 describes a scenario in which the controller is heavily loaded with upfront work, but the dispatcher functionality is minimal.  

如前所述，服务到工作者（Service to Worker）与调度器视图（Dispatcher View）模式呈现出一个连续体，其中行为逻辑要么封装在流程前端，要么被推送到处理流程的更后端。图7.22描述了一个场景：控制器承担了大量前期工作，而调度器功能则极为精简。

![](images/980f597909eec792214cfa56bb47e9802faf5ec5bdab4085c9da32d47dbb4c4e.jpg)  
Figure 7.22. Folding the dispatcher into the controller  

图7.22 将dispatcher整合至controller

# Transformer Helper Strategy  

See “Transformer Helper Strategy”.  

参见“Transformer Helper Strategy”。

# Consequences  

# Centralizes Control and Improves Modularity and Reuse  

This pattern suggests providing a central place to handle system services and business logic across multiple requests. The controller manages business logic processing and request handling. Keep in mind, though, that as control centralizes, it is possible to introduce a single point of failure.  

该模式建议提供一个集中位置来处理跨多个请求的系统服务和业务逻辑。控制器负责管理业务逻辑处理与请求调度。但需注意，随着控制权的集中化，可能会引入单点故障风险。

The pattern also promotes cleaner application partitioning and encourages reuse. Common code is moved into a controller and reused per request and moved into helper components, to which controllers and views delegate. The improved modularity and reuse means less duplication, which typically means a more bug-free environment.  

该模式还能促进更清晰的应用分层并鼓励复用。公共代码被移至控制器中按请求复用，或封装到辅助组件中供控制器和视图委托调用。增强的模块化与复用性意味着更少的重复代码，这通常能构建出更少缺陷的环境。

# Improves Application Partitioning  

Using helpers results in a cleaner separation of the view from the business processing in an application. Helpers, in the form of JavaBeans (JSP $1.0+)$ and Custom tags (JSP $1.1+\cdot$ ), provide a place for business logic to be factored out of the JSP. If the business logic is left in a JSP, large projects result in cumbersome and unwieldy scriptlet code.  

使用辅助类能更清晰地分离应用程序中的视图与业务处理。以JavaBeans（JSP 1.0+）和自定义标签（JSP 1.1+）形式存在的辅助类，为业务逻辑从JSP中剥离提供了实现途径。若将业务逻辑保留在JSP中，大型项目会导致脚本代码臃肿且难以维护。

# Improves Role Separation  

Separating the formatting logic from the application business logic also reduces dependencies on the same resources among individuals fulfilling different roles. Without this separation, for example, a software developer would own code that is embedded within HTML markup, while a Web production team member would need to modify page layout and design components that are intermingled with business logic. Because neither individual fulfilling these roles is familiar with the implementation specifics of the other individual's work, it raises the likelihood of modifications accidentally introducing bugs into the system.  

将格式化逻辑与应用程序业务逻辑分离还能降低不同角色人员对相同资源的依赖。若不进行这种分离，例如软件开发人员将拥有嵌入HTML标记中的代码，而网页制作团队成员则需要修改与业务逻辑混杂的页面布局和设计组件。由于履行这些角色的任何一方都不熟悉对方工作的具体实现细节，这增加了修改时意外将缺陷引入系统的可能性。

# Sample Code  

The following sample code shows an implementation of the Service to Worker pattern, using a controller servlet, a command helper, a dispatcher component, and a view. The implementation includes the Servlet Front Strategy, Command and Controller Strategy, JSP View Strategy, and JavaBean Helper Strategy. A very basic composite view is used as well. A screen shot of the resulting display is shown in Figure 7.23.  

以下示例代码展示了**Service to Worker**模式的实现，采用控制器Servlet、命令助手、分发器组件和视图构成。该实现包含**Servlet前端策略**、**命令与控制器策略**、**JSP视图策略**以及**JavaBean助手策略**，同时使用了一个非常基础的组合视图。图7.23展示了最终呈现效果的屏幕截图。

![](images/d86aba3320770e2760778e08aee42ed223c24dd330ce855bc498f9bbdc06ca02.jpg)  
Figure 7.23. Service to Worker sample screen shot  

图7.23 Service to Worker示例屏幕截图

Example 7.29 shows the controller servlet, which delegates to a Command object (Command and Controller Strategy) to complete the control processing. The Command object is retrieved via a factory invocation, which returns the generic Command type, an interface shown in Example 7.30. The sample code uses a LogManager to log messages. The screen shots in Figure 7.23 and Figure 7.28 show these messages displayed at the bottom of the page, for the purposes of this example.  

示例7.29展示了控制器Servlet，它通过委托给一个Command对象（Command与Controller策略模式）来完成控制处理。该Command对象通过工厂调用获取，工厂返回的是通用Command类型——一个如示例7.30所示的接口。示例代码使用LogManager来记录日志消息。图7.23和图7.28中的屏幕截图显示这些消息出现在页面底部，这是本示例特意展示的效果。

# Example 7.29 Controller Servlet with Command and Controller Strategy  

public class Controller extends HttpServlet { /\*\* Processes requests for both HTTP \* <code>GET</code> and <code>POST</code> methods. @param request servlet request $\star$ @param response servlet response \*/ protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { String next;  

public class Controller extends HttpServlet { /** 处理HTTP的<code>GET</code>和<code>POST</code>方法请求。@param request servlet请求 $\star$ @param response servlet响应 */ protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { String next;

try { // Log pattern info LogManager.recordStrategy(request, "Service To Worker", " ServletFront Strategy;" $^+$ " JSPView Strategy; JavaBean helper Strategy"); LogManager.logMessage(request, getSignature(), "Process incoming request. "); // Use a helper object to gather parameter // specific information. RequestHelper helper $=$ new RequestHelper(request,response); LogManager.logMessage(request, getSignature(), "Getting command object helper"); // Get command object helper Command command $=$ helper.getCommand(); // delegate processing to the command object, // passing request and response objects along next $=$ command.execute(helper); /\*\* If the above command returns a value, we $\star$ will dispatch from the controller. In this \* example, though, the command will use a \* separate dispatcher component to choose a $\star$ view and dispatch to that view. The command \* object delegates to this dispatcher $\star$ component in its execute method, above, and \* control should not return to this point \*\*/   
}   
catch (Exception e) { LogManager.logMessage( "EmployeeController(CommandStrategy)", e.getMessage() ); /\*\* ApplicationResources provides a simple API $\star$ for retrieving constants and other \* preconfigured values\*\*/ next $=$ ApplicationResources.getInstance(). getErrorPage(e);   
} - 215 -  

try {  
    // 记录模式信息  
    LogManager.recordStrategy(request, "Service To Worker", " ServletFront Strategy;" $^+$ " JSPView Strategy; JavaBean helper Strategy");  
    LogManager.logMessage(request, getSignature(), "处理传入请求。");  
    // 使用辅助对象收集参数特定信息  
    RequestHelper helper $=$ new RequestHelper(request,response);  
    LogManager.logMessage(request, getSignature(), "获取命令对象辅助器");  
    // 获取命令对象辅助器  
    Command command $=$ helper.getCommand();  
    // 将处理委托给命令对象，同时传递请求和响应对象  
    next $=$ command.execute(helper);  
    /**  
     * 如果上述命令返回一个值，我们将从控制器进行派发。  
     * 但在本示例中，该命令将使用单独的派发器组件来选择视图并派发至该视图。  
     * 命令对象在其execute方法（如上所述）中委托给此派发器组件，  
     * 控制流不应返回到此点  
     */  
}  
catch (Exception e) {  
    LogManager.logMessage( "EmployeeController(CommandStrategy)", e.getMessage() );  
    /**  
     * ApplicationResources提供简单API用于检索常量和其他预配置值  
     */  
    next $=$ ApplicationResources.getInstance().getErrorPage(e);  
} - 215 -

dispatch(request, response, next);  

dispatch(request, response, next);

/\*\* Handles the HTTP <code>GET $<$ </code> method. $\star$ @param request servlet request   
$\star$ @param response servlet response \*/   
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { processRequest(request, response);   
/\*\* Handles the HTTP <code>POST</code> method. $\star$ @param request servlet request $\star$ @param response servlet response \*/   
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { processRequest(request, response);   
/\*\* Returns a short description of the servlet. \*/   
public String getServletInfo() { return getSignature();   
}   
/\*\* dispatcher method \*/   
protected void dispatch(HttpServletRequest request, HttpServletResponse response, String page) throws javax.servlet.ServletException, java.io.IOException { RequestDispatcher dispatcher $=$ getServletContext().getRequestDispatcher(page); dispatcher.forward(request, response);   
public void init(ServletConfig config) throws ServletException { super.init(config);  

/** 处理 HTTP <code>GET</code> 方法。  
* @param request servlet 请求  
* @param response servlet 响应  
*/  
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException {  
    processRequest(request, response);  
}  

/** 处理 HTTP <code>POST</code> 方法。  
* @param request servlet 请求  
* @param response servlet 响应  
*/  
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException {  
    processRequest(request, response);  
}  

/** 返回该 servlet 的简短描述。*/  
public String getServletInfo() {  
    return getSignature();  
}  

/** 分发方法 */  
protected void dispatch(HttpServletRequest request, HttpServletResponse response, String page) throws javax.servlet.ServletException, java.io.IOException {  
    RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(page);  
    dispatcher.forward(request, response);  
}  

public void init(ServletConfig config) throws ServletException {  
    super.init(config);  
}

public void destroy() { } private String getSignature() { return "ServiceToWorker--Controller";  

public void destroy() { } private String getSignature() { return "ServiceToWorker--Controller";

# Example 7.30 Command Interface  

public interface Command {  

public interface Command {

public String execute(RequestHelper helper) throws javax.servlet.ServletException, java.io.IOException;  

public String execute(RequestHelper helper) throws javax.servlet.ServletException, java.io.IOException;

![](images/019bcec22afcb43050a777aefcea58f3a834a8cf4f9e977fa0ae93c1210d61e7.jpg)  

Each Command Object helper implements this generic interface, which is an example of the GoF Command pattern. The Command object is an instance of the ViewAccountDetails class, which is shown in Example 7.31. The command instance delegates to an AccountingAdapter to make an invocation to the business tier via business delegate. The adapter class is shown in Example 7.32. It uses a separate dispatcher component to determine the next view to which control should be dispatched and to actually dispatch to this view.  

每个命令对象辅助类都实现了这个通用**接口**，这是GoF命令模式的典型应用。该命令对象是`ViewAccountDetails`类的实例（如示例7.31所示），该命令实例通过**业务委托**将调用委托给`AccountingAdapter`以访问业务层。适配器类如示例7.32所示，它使用独立的调度器组件来确定控制权应传递的下一个视图，并实际完成向该视图的调度。

# Example 7.31 ViewAccountDetailsCommand  

ublic class ViewAccountDetailsCommand implements   
Command {   
public ViewAccountDetailsCommand() { }   
// view account details operation   
public String execute(RequestHelper helper) throws javax.servlet.ServletException,   
java.io.IOException { /\*\* This will tell the user that a system error \* has occured and will typically not be seen. It \* should be stored in a resource file \*\*/ String systemerror $=$ "/jspdefaultprocessingerror.jsp"; LogManager.logMessage(helper.getRequest(), "ViewAccountDetailsCommand", "Get Account Details from an adapter object"); /\*\* Use an adapter to retrieve data from business \* service, and store it in a request attribute. $\star$ Note: Object creation could be avoided via $\star$ factory, but for example purposes object \* instantiation is shown \*\*/ AccountingAdapter adapter $=$ new AccountingAdapter(); adapter.setAccountInfo(helper); LogManager.logMessage(helper.getRequest(),   
"ViewAccountDetailsCommand", "processing complete"); /\*\* Note: Object creation could be avoided via \* factory, but for example purposes object \* instantiation is shown\*\*/ Dispatcher dispatcher $=$ new Dispatcher(); dispatcher.dispatch(helper); /\*\* This return string will not be sent in a \* normal execution of this scenario, because \* control is forwarded to another resource \* before reaching  this point. Some commands do \* return a String,  though, so the return value \* is included for  correctness. \*\*/ return systemerror;  

public class ViewAccountDetailsCommand implements   
Command {   
public ViewAccountDetailsCommand() { }   
// 查看账户详情操作  
public String execute(RequestHelper helper) throws javax.servlet.ServletException,   
java.io.IOException { /\*\* 该错误提示用户系统错误发生，通常不会显示。应存储于资源文件 \*\*/ String systemerror $=$ "/jspdefaultprocessingerror.jsp"; LogManager.logMessage(helper.getRequest(), "ViewAccountDetailsCommand", "通过适配器对象获取账户详情"); /\*\* 使用适配器从业务服务获取数据，并将其存储为请求属性。$\star$ 注意：可通过工厂模式避免对象创建，$\star$ 但此处为示例展示对象实例化过程 \*\*/ AccountingAdapter adapter $=$ new AccountingAdapter(); adapter.setAccountInfo(helper); LogManager.logMessage(helper.getRequest(),   
"ViewAccountDetailsCommand", "处理完成"); /\*\* 注意：可通过工厂模式避免对象创建，$\star$ 但此处为示例展示对象实例化过程 \*\*/ Dispatcher dispatcher $=$ new Dispatcher(); dispatcher.dispatch(helper); /\*\* 正常执行流程不会返回该字符串，$\star$ 因控制权在到达此处前已转发至其他资源。$\star$ 部分命令会返回String类型值，$\star$ 故保留返回值以保证代码完整性 \*\*/ return systemerror;

# Example 7.32 AccountingAdapter  

public class AccountingAdapter { public void setAccountInfo( RequestHelper requestHelper) { LogManager.logMessage( requestHelper.getRequest(), "Retrieving data from business tier"); // retrieve data from business tier via // delegate. Omit try/catch block for brevity. AccountDelegate delegate $=$ new AccountDelegate(); AccountVO account $=$ delegate.getAccount( requestHelper.getCustomerId(), requestHelper.getAccountKey()); LogManager.logMessage( requestHelper.getRequest(), "Store account value object in request attribute"); // transport data using request object requestHelper.getRequest().setAttribute( "account", account);  

public class AccountingAdapter { public void setAccountInfo( RequestHelper requestHelper) { LogManager.logMessage( requestHelper.getRequest(), "从业务层获取数据"); // 通过委托从业务层获取数据 // 为简洁起见省略try/catch块 AccountDelegate delegate $=$ new AccountDelegate(); AccountVO account $=$ delegate.getAccount( requestHelper.getCustomerId(), requestHelper.getAccountKey()); LogManager.logMessage( requestHelper.getRequest(), "将账户值对象存入请求属性"); // 使用请求对象传输数据 requestHelper.getRequest().setAttribute( "account", account);

The invocation on the business service via the delegate yields an Account Value object, which the adapter stores in a request attribute for use by the view. Example 7.33 shows accountdetails.jsp, the JSP to which the request is dispatched. The Value object is imported via the standard <jsp:useBean> tag and its properties accessed with the standard ${<}\mathrm{j}$ sp:getProperty $\mathrm{\sim}$ tag. Also, the view uses a very simple composite strategy, doing a translation-time inclusion of the trace.jsp subview, which is responsible for displaying log information on the display solely for example purposes.  

通过委托调用业务服务会返回一个Account值对象，适配器将其存储在请求属性中供视图使用。示例7.33展示了请求被分发到的JSP页面accountdetails.jsp。该值对象通过标准<jsp:useBean>标签导入，其属性则通过标准${<}\mathrm{j}$sp:getProperty$\mathrm{\sim}$标签访问。此外，该视图采用了一种非常简单的组合策略，在转换时包含了trace.jsp子视图，该子视图仅用于示例目的，负责在界面上显示日志信息。

# Example 7.33 View - accountdetails.jsp  

<html>  

<html>

<head><title>AccountDetails</title></head> <body>  

<head><title>账户详情</title></head> <body>

<jsp:useBean id $\equiv$ "account" scope $=$ "request" class $_{\mathrm{s}}=$ "corepatterns.util.AccountVO" />  

<jsp:useBean id="account" scope="request" class="corepatterns.util.AccountVO" />

<h2><center> Account Detail for <jsp:getProperty name $=$ "account" property $=$ "owner" />   
</h2> <br><br>   
<table border $=3>$   
<tr>   
<td>   
Account Number :   
</td>   
<td>   
<jsp:getProperty name $=$ "account" property $=$ "number" />   
</td>   
</tr>   
<tr>   
<td>   
Account Type:   
</td>   
<td>   
<jsp:getProperty name $=$ "account" property $=$ "type" />   
</td>   
</tr>   
<tr>   
<td>   
Account Balance:   
</td>   
<td>   
<jsp:getProperty name $=$ "account" property $=$ "balance" />   
</td>   
</tr>   
<tr>   
<td>   
OverDraft Limit:   
</td>   
<td>   
<jsp:getProperty name $=$ "account" property $=$ "overdraftLimit" />   
</td>   
</tr>   
</table>   
<br>   
<br>   
</center>   
<%@ include file $=$ "/jsp/trace.jsp" %>   
</body>   
</html>  

<h2><center>账户详情：<jsp:getProperty name $=$ "account" property $=$ "owner" />   
</h2> <br><br>   
<table border $=3>$   
<tr>   
<td>   
账号：   
</td>   
<td>   
<jsp:getProperty name $=$ "account" property $=$ "number" />   
</td>   
</tr>   
<tr>   
<td>   
账户类型：   
</td>   
<td>   
<jsp:getProperty name $=$ "account" property $=$ "type" />   
</td>   
</tr>   
<tr>   
<td>   
账户余额：   
</td>   
<td>   
<jsp:getProperty name $=$ "account" property $=$ "balance" />   
</td>   
</tr>   
<tr>   
<td>   
透支限额：   
</td>   
<td>   
<jsp:getProperty name $=$ "account" property $=$ "overdraftLimit" />   
</td>   
</tr>   
</table>   
<br>   
<br>   
</center>   
<%@ include file $=$ "/jsp/trace.jsp" %>   
</body>   
</html>

# Related Patterns  

# Front Controller and View Helper  

The Service to Worker pattern is the result of combining the View Helper pattern with a dispatcher, in coordination with the Front Controller pattern.  

服务工作者(Service to Worker)模式是视图助手(View Helper)模式与前端控制器(Front Controller)模式协同工作时，结合调度器(dispatcher)所形成的复合模式。

# Dispatcher View  

The Dispatcher View pattern is another name for the combination of the Front Controller pattern with a dispatcher, and the View Helper pattern. The Service to Worker and the Dispatcher View patterns are identical with respect to the components involved, but differ in the division of labor among those components. The Dispatcher View pattern suggests deferring content retrieval to the time of view processing. Also, the dispatcher plays a more limited role in view management, as the choice of view is typically already included in the request.  

Dispatcher View 模式是 **前端控制器模式** 与分发器及 **视图助手模式** 组合的别称。**Service to Worker** 模式与 Dispatcher View 模式在组件构成上完全一致，但各组件间的职责划分存在差异。Dispatcher View 模式主张将内容获取延迟至视图处理阶段执行，且分发器在视图管理中的作用更为有限——因为视图选择通常已包含在请求中。

# Dispatcher View  

# Context  

System controls flow of execution and access to presentation processing, which is responsible for generating dynamic content.  

系统控制执行流程及对呈现处理的访问，后者负责生成动态内容。

# Note  

The Dispatcher View pattern, like the Service to Worker pattern, describes a common combination of other patterns from the catalog. Both of these macro  

Dispatcher View模式与Service to Worker模式类似，描述了目录中其他模式的常见组合方式。这两种宏观模式

patterns describe the combination of a controller and dispatcher with views and helpers. While describing this common structure, they emphasize related but different usage patterns.  

模式描述了控制器与调度器结合视图和辅助组件的组合方式。在阐述这一通用结构时，它们强调了相关但不同的使用模式。

# Problem  

The problem is a combination of the problems solved by the Front Controller and View Helper patterns in the presentation tier. There is no centralized component for managing access control, content retrieval or view management, and there is duplicate control code scattered throughout various views. Additionally, business logic and presentation formatting logic are intermingled within these views, making the system less flexible, less reusable, and generally less resilient to change.  

该问题综合了表现层中**前端控制器模式**与**视图助手模式**所解决的痛点。当前系统缺乏集中式组件来管理访问控制、内容检索或视图管理，且重复的控制代码分散在各个视图中。此外，业务逻辑与呈现格式化逻辑在这些视图中相互混杂，导致系统灵活性降低、可复用性减弱，整体上对变更的适应能力较差。

Intermingling business logic with view processing also reduces modularity and provides a poor separation of roles among Web production and software development teams.  

将业务逻辑与视图处理混杂在一起会降低模块化程度，并导致网页制作团队与软件开发团队之间的职责分离不清。

# Forces  

• Authentication and authorization checks are completed per request.   
• Scriptlet code within views should be minimized.   
• Business logic should be encapsulated in components other than the view.   
• Control flow is relatively simple and is typically based on values encapsulated with the request. View management logic is limited in complexity.  

• 每个请求均需完成身份验证与授权检查  
• 应尽量减少视图中的脚本片段代码  
• 业务逻辑应封装在视图之外的组件中  
• 控制流相对简单，通常基于请求封装的值。视图管理逻辑的复杂度受到严格控制

# Solution  

Combine a controller and dispatcher with views and helpers (see “Front Controller” and “View Helper”) to handle client requests and prepare a dynamic presentation as the response. Controllers do not delegate content retrieval to helpers, because these activities are deferred to the time of view processing. A dispatcher is responsible for view management and navigation and can be encapsulated either within a controller, a view, or a separate component.  

将控制器与分发器结合视图和辅助组件（参见“前端控制器”和“视图助手”）来处理客户端请求，并准备动态呈现作为响应。控制器不会将内容检索委托给辅助组件，因为这些操作会延迟到视图处理阶段执行。分发器负责视图管理与导航，可被封装在控制器、视图或独立组件中。

Dispatcher View describes the combination of the Front Controller and View Helper patterns with a dispatcher component. While this pattern and the Service to Worker pattern describe a similar structure, the two patterns suggest a different division of labor among the components. The controller and the dispatcher typically have limited responsibilities, as compared to the Service to Worker pattern, since the  

Dispatcher View模式描述了前端控制器（Front Controller）与视图助手（View Helper）模式结合调度器组件的架构。虽然该模式与Service to Worker模式具有相似结构，但两者对组件职责划分存在差异。相较于Service to Worker模式，Dispatcher View中的控制器和调度器通常承担更有限的职责，因为

upfront processing and view management logic are basic. Furthermore, if centralized control of the underlying resources is considered unnecessary, then the controller is removed and the dispatcher may be moved into a view.  

前置处理与视图管理逻辑是基础功能。此外，若认为无需对底层资源进行集中控制，则可移除控制器，并将调度器移至视图中实现。

Since the Service to Worker and Dispatcher View patterns represent a common combination of other patterns from the catalog, each warrants its own name to promote efficient communication among developers. Unlike the Service to Worker pattern, the Dispatcher View pattern suggests deferring content retrieval to the time of view processing.  

由于Service to Worker和Dispatcher View模式代表了目录中其他模式的常见组合，因此每种模式都需要自己的名称以促进开发人员之间的高效沟通。与Service to Worker模式不同，Dispatcher View模式建议将内容检索推迟到视图处理阶段进行。

In the Dispatcher View pattern, the dispatcher typically plays a limited to moderate role in view management. In the Service to Worker pattern, the dispatcher typically plays a moderate to large role in view management.  

在Dispatcher View模式中，调度器通常在视图管理中扮演有限至中等角色。而在Service to Worker模式中，调度器通常在视图管理中承担中等至重要角色。

A limited role for the dispatcher occurs when no outside resources are utilized in order to choose the view. The information encapsulated in the request is sufficient to determine the view to dispatch the request. For example:  

当无需借助外部资源来选择视图时，调度器的作用就较为有限。此时请求中封装的信息已足以确定要分派请求的视图。例如：

http://some.server.com/servlet/Controller?next $=$ login.jsp  

http://some.server.com/servlet/Controller?next=login.jsp

The sole responsibility of the dispatcher component in this case is to dispatch to the view login.jsp.  

在此场景下，调度器组件的唯一职责是分派至视图 login.jsp。

An example of the dispatcher playing a moderate role is the case where the client submits a request directly to a controller with a query parameter that describes an action to be completed:  

调度器发挥适度作用的一个典型场景是：客户端直接向控制器提交请求，并通过查询参数指定待执行的操作。

http://some.server.com/servlet/Controller?action $\cdot^{=}$ login  

http://some.server.com/servlet/Controller?action $\cdot^{=}$ login

The responsibility of the dispatcher component here is to translate the logical name login into the resource name of an appropriate view, such as login.jsp, and dispatch to that view. To accomplish this translation, the dispatcher may access resources such as an XML configuration file that specifies the appropriate view to display.  

此处**dispatcher**组件的职责是将逻辑名称`login`转换为对应视图的资源名称（例如`login.jsp`），并将请求派发至该视图。为实现这种转换，**dispatcher**可访问诸如XML配置文件等资源，这些文件规定了需要展示的具体视图。

On the other hand, in the Service to Worker pattern, the dispatcher might be more sophisticated. The dispatcher may invoke a business service to determine the appropriate view to display.  

另一方面，在Service to Worker模式中，调度器可能更为复杂。该调度器会调用业务服务来确定需要显示的合适视图。

The shared structure of these two patterns, as mentioned above, consists of a controller working with a dispatcher, views, and helpers.  

如上所述，这两种模式的共享结构由一个与**Dispatcher**（调度器）、**Views**（视图）及**Helpers**（辅助类）协同工作的**Controller**（控制器）构成。

# Structure  

Figure 7.24 shows the class diagram that represents the Dispatcher View pattern.  

图7.24展示了表示Dispatcher View模式的类图。

# Figure 7.24. Dispatcher View class diagram  

![](images/dd65c203505b9d2c76327eb821bfb1a2d3f12c7b9f1cc8bd2d9b3a1cbc30a7d1.jpg)  

# Participants and Responsibilities  

Figure 7.25 shows the Dispatcher View sequence pattern.  

图7.25展示了Dispatcher View序列模式。

# Figure 7.25. Dispatcher View sequence diagram  

![](images/050812102166bd796e5d966e9c6fc1c336c0fda3fc9190b9ad7abb9ac98998e6.jpg)  

While the controller responsibilities are limited to system services, such as authentication and authorization, it is often still beneficial to centralize these aspects of the system. Notice also that, unlike in Service to Worker, the dispatcher does not make invocations on a business service in order to complete its view management processing.  

虽然控制器的职责仅限于系统服务（例如认证与授权），但集中管理这些系统层面通常仍具有优势。还需注意的是，与Service to Worker模式不同，调度器在完成视图管理处理时并不会调用业务服务。

The dispatcher functionality may be encapsulated in its own component. At the same time, when the responsibilities of the dispatcher are limited, as described by this pattern, the dispatcher functionality is often folded into another component, such as the controller or the view (see “Dispatcher in Controller Strategy” and “Dispatcher in View Strategy”).  

调度器功能可封装为独立组件。同时，当调度器职责如该模式所述较为限定时，其功能通常会被整合至其他组件（如控制器或视图）中（参见“控制器策略中的调度器”与“视图策略中的调度器”）。

In fact, the dispatcher functionality may even be completed by the container, in the case where there is no extra application-level logic necessary. An example is a view called main.jsp that is given the alias name first. The container will process the following request, translate the alias name to the physical resource name, and dispatch directly to that resource:  

实际上，当不需要额外的应用层逻辑时，**分发器功能**甚至可由**容器**直接完成。例如某个别名为`first`的视图`main.jsp`，容器将处理以下请求：将别名转换为物理资源名称，并直接分发至该资源：

http://some.server.com/first --> /mywebapp/main.jsp  

http://some.server.com/first --> /mywebapp/main.jsp

In this case, we are left with the View Helper pattern, with the request being handled directly by the view. Since the view is the initial contact point for handling a request, custom tag helpers are typically used in these cases to perform business processing or to delegate this processing to other components. See the listing in Example 7.35 in the “Sample Code” section for an implementation sample.  

这种情况下，我们采用视图助手模式，由视图直接处理请求。由于视图是处理请求的初始接触点，通常会使用自定义标签助手来执行业务处理或将处理委托给其他组件。具体实现示例请参见“示例代码”章节中的示例7.35清单。

Thus, the Dispatcher View pattern describes a continuum of related scenarios, moving from a scenario that is very structurally similar to Service to Worker to one that is similar to View Helper.  

因此，**Dispatcher View**模式描述了一系列相关场景的连续体，从结构上非常类似于**Service to Worker**的场景，逐步过渡到类似于**View Helper**的场景。

# Controller  

The controller is typically the initial contact point for handling a request. The controller manages authentication and authorization, and delegates to a dispatcher to do view management.  

控制器通常是处理请求的初始接触点。控制器负责管理身份验证与授权，并委托调度器执行视图管理。

# Dispatcher  

A dispatcher is responsible for view management and navigation, managing the choice of the next view to present to the user and providing the mechanism for vectoring control to this resource.  

分发器负责视图管理与导航，管理向用户呈现的下一个视图的选择，并提供将控制向量化导向该资源的机制。

A dispatcher can be encapsulated within a controller (see “Front Controller”) or can be a separate component working in coordination. The dispatcher can provide static dispatching to the view or may provide a more sophisticated dynamic dispatching mechanism.  

调度器可以封装在控制器内部（参见“前端控制器”），也可以作为独立组件协同工作。调度器可提供静态视图分发，亦可实现更复杂的动态分发机制。

# View  

A view represents and displays information to the client. The information that is used in a display is retrieved from a model. Helpers support views by encapsulating and adapting a model for use in a display.  

视图负责向客户端呈现和展示信息。显示所用的信息从模型中获取。助手通过封装和适配模型以支持视图在显示中的使用。

# Helper  

A helper is responsible for helping a view or controller complete its processing. Thus, helpers have numerous responsibilities, including gathering data required by the view and storing this intermediate model, in which case the helper is sometimes referred to as a value bean. Additionally, helpers may adapt this data model for use by the view. Helpers can service requests for data from the view by simply providing access to the raw data or by formatting the data as Web content.  

助手（helper）负责协助视图或控制器完成其处理流程。因此，助手承担多项职责，包括收集视图所需数据并存储这些中间模型（此时助手有时被称为值Bean）。此外，助手可能对数据模型进行适配以供视图使用。助手可通过直接提供原始数据访问权限，或将数据格式化为Web内容的方式，来响应视图的数据请求。

A view may work with any number of helpers, which are typically implemented as JavaBeans (JSP $1.0+)$ and custom tags (JSP $1.1+\cdot$ . Additionally, a helper may represent a Command object or a Delegate (see “Business Delegate”).  

视图可以与任意数量的辅助对象协作，这些辅助对象通常以 **JavaBeans**（JSP 1.0+）和自定义标签（JSP 1.1+）的形式实现。此外，辅助对象可能表现为 **Command** 对象或 **Delegate**（参见“业务委托”模式）。

# ValueBean  

A value bean is another name for a helper that is responsible for holding intermediate model state for use by a view. A typical case, as shown in the sequence diagram in Figure 7.12, has the business service returning a value bean in response to a request. In this case, ValueBean fulfills the role of a Value Object (see “Value Object”).  

值对象Bean（ValueBean）是辅助类的另一种称谓，其职责在于维护供视图使用的中间模型状态。如图7.12序列图所示，典型场景中业务服务会响应请求返回一个值对象Bean。此时ValueBean承担着**值对象**（参见“值对象”章节）的角色。

# BusinessService  

The business service is a role that is fulfilled by the service the client is seeking to access. Typically, the business service is accessed via a business delegate. The business delegate's role is to provide control and protection for the business service (see “Business Delegate”).  

业务服务是由客户端试图访问的服务所实现的角色。通常，业务服务通过业务委托进行访问。业务委托的作用是为业务服务提供控制与保护（参见“业务委托”模式）。

# Strategies  

# Servlet Front Strategy  

See “Servlet Front Strategy”.  

参见“Servlet Front 策略”。

# JSP Front Strategy  

See “JSP Front Strategy”.  

参见“JSP前端策略”。

# JSP View Strategy  

See “JSP View Strategy”.  

参见“JSP视图策略”。

# Servlet View Strategy  

See “Servlet View Strategy”.  

参见“Servlet视图策略”。

# JavaBean Helper Strategy  

See “JavaBean Helper Strategy”.  

参见“JavaBean Helper 策略”。

# Custom Tag Helper Strategy  

See “Custom Tag Helper Strategy”.  

参见“自定义标签助手策略”。

# Dispatcher in Controller Strategy  

See “Dispatcher in Controller Strategy”.  

参见“控制器中的分发器策略”。

As stated, the Service to Worker and Dispatcher View patterns suggest a continuum, where behavior is encapsulated closer to the front in Service to Worker or moved farther back in Dispatcher View.  

如前所述，Service to Worker与Dispatcher View模式体现了一个连续统，其中行为封装在Service to Worker中更靠近前端，而在Dispatcher View中则被推向更靠后的位置。

Figure 7.26 shows the interactions for this strategy.  

图7.26展示了该策略的交互流程。

![](images/86a2cab0350ac74d8485f5d10fc44824655dadf6c072860b4253e10be0aa9808.jpg)  
Figure 7.26. Dispatcher in Controller Strategy  

图7.26 控制器策略中的Dispatcher

The controller does not create an explicit dispatcher object. Instead, the controller takes care of dispatching to the view. Alternatively, one could implement a dispatcher to which the controller can delegate the dispatching function.  

控制器并不显式创建分发器对象，而是自行处理向视图的分发逻辑。另一种实现方式是构建一个独立的分发器，由控制器委托其执行分发功能。

# Dispatcher in View Strategy  

If the controller is removed due to its limited role, the dispatcher may be moved into a view. This design can be useful in cases where there is typically one view that maps to a specific request, but where a secondary view may be used on an infrequent basis. For example, based on some information in the request or results of some processing in a view, a custom tag helper in the view might vector control to a secondary view. A typical case is when a client request is submitted to a specific view, and will be serviced by that view in almost every case. Consider the case where the user has not been authenticated, but requests access to one of the few protected JSPs on a site. Since the site has only a few protected pages, and limited dynamic content, authentication can be performed within those JSPs, instead of using a site-wide centralized controller. Those pages that need authentication include a custom tag helper at the top of the page. This helper performs the authentication check and either displays the page for the user or forwards the user to an authentication page.  

若控制器因其有限职责被移除，调度器可被移至视图层。该设计适用于以下场景：通常存在与特定请求直接映射的主视图，但偶尔会使用次要视图。例如，基于请求中的某些信息或视图处理结果，视图中的自定义标签助手可能将控制流转至次要视图。典型用例是客户端请求提交至特定视图时，该视图在绝大多数情况下都能直接处理请求。以用户未通过认证却试图访问站点中少数受保护JSP页面为例：由于站点仅含少量受保护页面且动态内容有限，认证逻辑可直接内置于这些JSP中，而无需使用全站集中式控制器。需要认证的页面在顶部包含自定义标签助手，该助手执行认证检查后，要么向用户展示页面，要么将其重定向至认证页面。

Figure 7.27 represents this scenario.  

图7.27展示了该场景。

![](images/7db097b60589f42bb5f1aa089d9cb68c6258ed3ba7d1a3bfd9768cef4ee7b44b.jpg)  
Figure 7.27. Dispatcher in View Strategy  

图7.27 视图策略中的Dispatcher

# Transformer Helper Strategy  

See “Transformer Helper Strategy”.  

参见“Transformer Helper Strategy”。

# Consequences  

# Centralizes Control and Improves Reuse and Maintainability  

Control processing is handled in a central place for multiple requests. It is easier to manage these activities and perform dispatching from a centralized point, since a central access point means code is reused across multiple requests, reducing duplication and easing maintenance.  

控制处理在中心位置统一管理多个请求。由于集中访问点意味着代码可在多个请求间复用，因此更易于管理这些活动并执行调度，从而减少重复代码并降低维护难度。

# Improves Application Partitioning  

Use of helpers results in a cleaner separation of the view from an application's business processing. The helpers, in the form of JavaBeans $(\mathtt{J S P1.0+})$ and Custom tags (JSP $1.1+\cdot$ ), provide a place for business logic to be factored out of the JSP, where scriptlet code quickly becomes cumbersome and unwieldy in large projects.  

使用辅助类能实现视图与业务处理的更清晰分离。这些辅助类以JavaBeans $(\mathtt{JSP1.0+})$ 和自定义标签（JSP $1.1+\cdot$）的形式存在，为业务逻辑提供了从JSP中抽离的载体——在大型项目中，脚本片段代码会迅速变得臃肿且难以维护。

# Improves Role Separation  

Separating the formatting logic from the application business logic also reduces dependencies that individuals fulfilling different roles might have on the same resources. For example, a software developer would own code that is embedded within HTML markup, while a Web production team member would need to modify page layout and design components that are intermingled with business logic. Because neither individual fulfilling these roles may be familiar with the implementation specifics of the other individual's work, there is the likelihood of inadvertent modifications introducing bugs into the system.  

将格式化逻辑与应用程序业务逻辑分离，还能减少不同角色人员对相同资源的依赖。例如，软件开发人员负责嵌入HTML标记中的代码，而网页制作团队成员则需要修改与业务逻辑混杂的页面布局和设计组件。由于担任这些角色的个体可能都不熟悉对方工作的具体实现细节，无意间的修改很可能会将缺陷引入系统。

# Sample Code  

The following sample code shows an implementation of the Dispatcher View pattern, using a controller servlet and a view with JavaBean and custom tag helpers. The implementation includes the Servlet Front Strategy, Dispatcher in Controller Strategy, JSP View Strategy, and custom tag and JavaBean helper strategies. A very basic composite view is used as well. A screen shot of the resulting display is shown in Figure 7.28.  

以下示例代码展示了**Dispatcher View**模式的实现，采用控制器Servlet与结合JavaBean及自定义标签助手的视图。该实现包含**Servlet前端策略**、**控制器中的Dispatcher策略**、**JSP视图策略**以及自定义标签与JavaBean助手策略，同时使用了一个非常基础的复合视图。图7.28展示了最终呈现效果的屏幕截图。

Example 7.34 shows the controller servlet, which simply completes an authentication check and passes control to the appropriate view. Notice that the controller does not directly delegate to any helper components in order to make invocations to the business tier via a Delegate. These responsibilities are deferred to the view, which is called accountdetails.jsp and can be seen in Example 7.35. The sample code uses a LogManager to log messages. These messages are displayed at the bottom of the output page, for the purposes of this example, and can be seen in the screen shots in Figure 7.23 and Figure 7.28.  

示例7.34展示了控制器Servlet，它仅完成身份验证检查并将控制权传递给相应的视图。请注意，该控制器并未直接委托任何辅助组件来通过Delegate调用业务层。这些职责被推迟到视图中处理，该视图名为accountdetails.jsp，如示例7.35所示。示例代码使用LogManager记录日志消息，出于本示例目的，这些消息显示在输出页面底部，效果如图7.23和图7.28的屏幕截图所示。

# Example 7.34 Dispatcher View Controller Servlet  

public class Controller extends HttpServlet {  

public class Controller extends HttpServlet {

/\*\* Processes requests for both HTTP $\star$ <code>GET $<$ /code> and <code $>$ POST $<$ /code> methods. $\star$ @param request servlet request \* @param response servlet response \*/   
protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { String nextview; try { LogManager.recordStrategy(request, "Dispatcher View", Servlet Front Strategy; " + "JSP View Strategy; Custom tag helper Strategy"); LogManager.logMessage(request, getSignature(), "Process incoming request. "); // Use a helper object to gather parameter // specific information. RequestHelper helper $=$ new RequestHelper(request, response); LogManager.logMessage(request, getSignature(), " Authenticate user"); Authenticator auth $=$ new BasicAuthenticator(); auth.authenticate(helper); //This is an oversimplification for the sake of // simplicity. Typically, there will be a // mapping from logical name to resource name a // this point LogManager.logMessage(request, getSignature(), "Getting nextview"); nextview $=$ request.getParameter("nextview"); LogManager.logMessage(request, getSignature(), "Dispatching to view: " $^+$ nextview);   
catch (Exception e) { LogManager.logMessage( "Handle exception appropriately", e.getMessage() ); /\*\* ApplicationResources provides a simple API $\star$ for retrieving constants and other \* preconfigured values\*\*/ nextview $=$ ApplicationResources.getInstance(). getErrorPage(e); } dispatch(request, response, nextview);   
}   
/\*\* Handles the HTTP <code>GET $<$ </code> method. \* @param request servlet request $\star$ @param response servlet response \*/   
protected void doGet(HttpServletRequest request, HttpServletResponse response)   
throws ServletException, java.io.IOException { processRequest(request, response);   
/\*\* Handles the HTTP <code>POST</code> method. \* @param request servlet request \* @param response servlet response \*/   
protected void doPost(HttpServletRequest request, HttpServletResponse response)   
throws ServletException, java.io.IOException { processRequest(request, response);   
/\*\* Returns a short description of the servlet. \*/   
public String getServletInfo() { return getSignature();   
public void init(ServletConfig config) throws ServletException { super.init(config);   
public void destroy() { }   
/\*\* \* dispatcher method $^\star/$   
protected void dispatch(HttpServletRequest request, HttpServletResponse response, String page) throws javax.servlet.ServletException, java.io.IOException { RequestDispatcher dispatcher $=$ getServletContext(). getRequestDispatcher(page); dispatcher.forward(request, response);   
private String getSignature() { return "DispatcherView-Controller";  

/\*\* 处理HTTP <code>GET</code>和<code>POST</code>方法的请求。  
\* @param request servlet请求  
\* @param response servlet响应  
\*/  
protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException {  
    String nextview;  
    try {  
        LogManager.recordStrategy(request, "Dispatcher View", "Servlet Front Strategy; " + "JSP View Strategy; Custom tag helper Strategy");  
        LogManager.logMessage(request, getSignature(), "处理传入请求");  
        // 使用辅助对象收集参数特定信息  
        RequestHelper helper = new RequestHelper(request, response);  
        LogManager.logMessage(request, getSignature(), "用户认证");  
        Authenticator auth = new BasicAuthenticator();  
        auth.authenticate(helper);  
        // 此处为简化处理，实际通常会有逻辑名称到资源名称的映射  
        LogManager.logMessage(request, getSignature(), "获取nextview");  
        nextview = request.getParameter("nextview");  
        LogManager.logMessage(request, getSignature(), "分发至视图: " + nextview);  
    } catch (Exception e) {  
        LogManager.logMessage("妥善处理异常", e.getMessage());  
        /\*\* ApplicationResources提供简单API用于获取常量和其他预配置值\*\*/  
        nextview = ApplicationResources.getInstance().getErrorPage(e);  
    }  
    dispatch(request, response, nextview);  
}  

/\*\* 处理HTTP <code>GET</code>方法。  
\* @param request servlet请求  
\* @param response servlet响应  
\*/  
protected void doGet(HttpServletRequest request, HttpServletResponse response)  
    throws ServletException, java.io.IOException {  
    processRequest(request, response);  
}  

/\*\* 处理HTTP <code>POST</code>方法。  
\* @param request servlet请求  
\* @param response servlet响应  
\*/  
protected void doPost(HttpServletRequest request, HttpServletResponse response)  
    throws ServletException, java.io.IOException {  
    processRequest(request, response);  
}  

/\*\* 返回Servlet的简短描述。  
\*/  
public String getServletInfo() {  
    return getSignature();  
}  

public void init(ServletConfig config) throws ServletException {  
    super.init(config);  
}  

public void destroy() { }  

/\*\* 分发方法 \*/  
protected void dispatch(HttpServletRequest request, HttpServletResponse response, String page)  
    throws javax.servlet.ServletException, java.io.IOException {  
    RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(page);  
    dispatcher.forward(request, response);  
}  

private String getSignature() {  
    return "DispatcherView-Controller";  
}

Notice that the view uses custom tag helpers to manage content retrieval, since this activity was not completed in the controller. When custom tags are used in this manner, they typically become thin facades for standalone components to which  

请注意，该视图使用自定义标签助手来管理内容检索，因为此操作未在控制器中完成。当以这种方式使用自定义标签时，它们通常会成为独立组件的薄门面，这些组件...

they delegate to complete this processing. This way, the general processing logic is loosely coupled to the tag implementation. If custom tags are not used with Dispatcher View, then too much scriptlet code typically ends up in the JSP, a situation to be avoided.  

它们通过委托来完成这一处理过程。这种方式使得通用处理逻辑与标签实现保持松耦合。如果自定义标签未与Dispatcher View模式配合使用，通常会导致JSP中出现过多脚本代码，这种情况应当避免。

# Example 7.35 View – accountdetails.jsp  

<%@ taglib uri $=$ "/web--INF/corepatternstaglibrary.tld" prefix $\equiv$ "corepatterns" %>   
<html>   
<head> $<$ <title>AccountDetails</title></head>   
<body>   
<corepatterns:AccountQuery queryParams $=$ "custid,acctkey" scope $=$ "request" />   
<h2><center> Account Detail for <corepatterns:Account attribute $=$ "owner" / $\mid><$ /h2> <br><br>   
<tr> <td>Account Number :</td> <td><corepatterns:Account attribute $=$ "number" /></td>   
</tr>   
<tr> <td>Account Type:</td> <td><corepatterns:Account attribute $=$ "type" /></td>   
</tr>   
<tr> <td>Account Balance:</td> <td><corepatterns:Account attribute $=$ "balance" / $><$ /td>   
</tr>   
<tr> <td $>$ OverDraft Limit:</td> <td><corepatterns:Account attribute $=$ "overdraftLimit" / $^{\prime}><$ /td>   
</tr>   
<table border $=3>$   
</table>   
</corepatterns:AccountQuery>  

<%@ taglib uri="/web--INF/corepatternstaglibrary.tld" prefix="corepatterns" %>  
<html>  
<head><title>账户详情</title></head>  
<body>  
<corepatterns:AccountQuery queryParams="custid,acctkey" scope="request" />  
<h2><center>账户详情 - <corepatterns:Account attribute="owner" /></h2><br><br>  
<tr><td>账户号码：</td><td><corepatterns:Account attribute="number" /></td>  
</tr>  
<tr><td>账户类型：</td><td><corepatterns:Account attribute="type" /></td>  
</tr>  
<tr><td>账户余额：</td><td><corepatterns:Account attribute="balance" /></td>  
</tr>  
<tr><td>透支限额：</td><td><corepatterns:Account attribute="overdraftLimit" /></td>  
</tr>  
<table border=3>  
</table>  
</corepatterns:AccountQuery>

<br> <br>  

<br> <br>

</center>   
<%@ include file $=$ "/jsp/trace.jsp" %>   
</body>   
</html>  

</center>   
<%@ include file="/jsp/trace.jsp" %>   
</body>   
</html>

# Related Patterns  

# Front Controller  

The Service to Worker pattern is the result of combining the View Helper pattern with a dispatcher in coordination with the Front Controller pattern  

服务工作者(Service to Worker)模式是视图助手(View Helper)模式与前端控制器(Front Controller)模式协同调度器(Dispatcher)相结合的产物

# View Helper  

The Service to Worker pattern is the result of combining the View Helper pattern with a dispatcher in coordination with the Front Controller pattern.  

服务工作者模式（Service to Worker）是视图助手模式与前端控制器模式协同调度器相结合的产物。

# Service to Worker  

The Service to Worker pattern is another name for the combination of the Front Controller pattern with a dispatcher and the View Helper pattern. The Service to Worker and Dispatcher View patterns are identical with respect to the components involved, but differ in the division of labor among those components. The Dispatcher View pattern suggests deferring content retrieval to the time of view processing. Also, the dispatcher plays a more limited role in view management, as the choice of view is typically already included in the request.  

服务工作者模式（Service to Worker）是前端控制器模式（Front Controller）与调度器及视图助手模式（View Helper）组合的另一种称谓。服务工作者模式与调度器视图模式（Dispatcher View）在涉及组件方面完全相同，但各组件间的职责划分存在差异。调度器视图模式建议将内容检索延迟至视图处理阶段执行。此外，调度器在视图管理中的作用更为有限，因为视图选择通常已包含在请求中。

# Chapter 8. BUSINESS TIER PATTERNS  

# Topics in This Chapter  

• Business Delegate • Value Object • Session Facade • Composite Entity • Value Object Assembler • Value List Handler • Service Locator  

• 业务委托模式  
• 值对象模式  
• 会话门面模式  
• 组合实体模式  
• 值对象组装器模式  
• 值列表处理器模式  
• 服务定位器模式

# Business Delegate  

# Context  

A multitiered, distributed system requires remote method invocations to send and receive data across tiers. Clients are exposed to the complexity of dealing with distributed components.  

多层分布式系统需要通过远程方法调用来实现跨层数据收发。客户端需直面处理分布式组件的复杂性。

# Problem  

Presentation-tier components interact directly with business services. This direct interaction exposes the underlying implementation details of the business service application program interface (API) to the presentation tier. As a result, the presentation-tier components are vulnerable to changes in the implementation of the business services: When the implementation of the business services change, the exposed implementation code in the presentation tier must change too.  

表示层组件直接与业务服务交互。这种直接交互会将业务服务应用程序接口（API）的底层实现细节暴露给表示层。因此，表示层组件容易受到业务服务实现变更的影响：当业务服务的实现发生变化时，表示层中暴露的实现代码也必须随之修改。

Additionally, there may be a detrimental impact on network performance because presentation-tier components that use the business service API make too many invocations over the network. This happens when presentation-tier components use the underlying API directly, with no client-side caching mechanism or aggregating service.  

此外，这可能会对网络性能产生不利影响，因为使用业务服务API的表示层组件会通过网络发起过多调用。当表示层组件直接调用底层API且未采用客户端缓存机制或聚合服务时，就会出现这种情况。

Lastly, exposing the service APIs directly to the client forces the client to deal with the networking issues associated with the distributed nature of EJB technology.  

最后，将服务API直接暴露给客户端会迫使客户端处理与EJB技术分布式特性相关的网络问题。

# Forces  

• Presentation-tier clients need access to business services. Different clients, such as devices, Web clients, and thick clients, need access to business service. Business services APIs may change as business requirements evolve.   
? It is desirable to minimize coupling between presentation-tier clients and the business service, thus hiding the underlying implementation details of the service, such as lookup and access. Clients may need to implement caching mechanisms for business service information. It is desirable to reduce network traffic between client and business services.  

• **表现层客户端**需要访问业务服务。不同客户端（如设备、Web客户端和富客户端）均需访问业务服务。业务服务接口可能随业务需求变化而调整。  
• 应尽量降低表现层客户端与业务服务间的耦合度，从而隐藏服务的底层实现细节（如查找与访问机制）。客户端可能需要为业务服务信息实现缓存机制。同时需减少客户端与业务服务间的网络流量。

# Solution  

# Use a Business Delegate to reduce coupling between presentation-tier clients and business services. The Business Delegate hides the underlying implementation details of the business service, such as lookup and access details of the EJB architecture.  

The Business Delegate acts as a client-side business abstraction; it provides an abstraction for, and thus hides, the implementation of the business services. Using a Business Delegate reduces the coupling between presentation-tier clients and the system's business services. Depending on the implementation strategy, the Business Delegate may shield clients from possible volatility in the implementation of the business service API. Potentially, this reduces the number of changes that must be made to the presentation-tier client code when the business service API or its underlying implementation changes.  

业务委托模式充当客户端业务抽象层，它为业务服务提供抽象接口从而隐藏其具体实现。通过使用业务委托，可有效降低表示层客户端与系统业务服务之间的耦合度。根据具体实现策略的不同，业务委托能够隔离客户端免受业务服务API实现变更带来的影响。当业务服务API或其底层实现发生变更时，该模式可显著减少表示层客户端代码所需的修改量。

However, interface methods in the Business Delegate may still require modification if the underlying business service API changes. Admittedly, though, it is more likely that changes will be made to the business service rather than to the Business Delegate.  

然而，若底层业务服务API发生变更，业务委托中的**接口**方法仍可能需要修改。不过应当承认，相较于业务委托层，业务服务层发生变更的可能性通常更高。

Often, developers are skeptical when a design goal such as abstracting the business layer causes additional upfront work in return for future gains. However, using this pattern or its strategies results in only a small amount of additional upfront work and provides considerable benefits. The main benefit is hiding the details of the underlying service. For example, the client can become transparent to naming and lookup services. The Business Delegate also handles the exceptions from the business services, such as java.rmi.Remote exceptions, JMS exceptions and so on. The Business Delegate may intercept such service level exceptions and generate application level exceptions instead. Application level exceptions are easier to handle by the clients, and may be user friendly. The Business Delegate may also tranparently perform any retry or recovery operations necessary in the event of a service failure without exposing the client to the problem until it is determined that the problem is not resolvable. These gains present a compelling reason to use the pattern.  

开发者通常会对这样的设计目标持怀疑态度：抽象业务层需要额外的前期工作，以换取未来的收益。然而，采用此模式或其策略仅需少量额外的前期投入，却能带来显著优势。其主要价值在于隐藏底层服务的实现细节——例如，客户端可完全无需感知命名与查找服务的存在。Business Delegate 还会处理来自业务服务的异常（如 `java.rmi.Remote` 异常、JMS 异常等），它能拦截这类服务级异常并转换为应用级异常。应用级异常更便于客户端处理，且对用户更友好。当服务发生故障时，Business Delegate 还能透明执行必要的重试或恢复操作，仅在确定问题无法解决时才向客户端暴露异常。这些优势充分证明了该模式的应用价值。

Another benefit is that the delegate may cache results and references to remote business services. Caching can significantly improve performance, because it limits unnecessary and potentially costly round trips over the network.  

另一个优势在于，委托层可以缓存结果及远程业务服务的引用。通过缓存机制能显著提升性能，因为它减少了网络中不必要的、可能代价高昂的往返通信。

A Business Delegate uses a component called the Lookup Service. The Lookup Service is responsible for hiding the underlying implementation details of the business service lookup code. The Lookup Service may be written as part of the Delegate, but we recommend that it be implemented as a separate component, as outlined in the Service Locator pattern (See “Service Locator”.).  

业务委托模式使用名为**查找服务**的组件。该查找服务负责隐藏业务服务查询代码的底层实现细节。查找服务可作为委托的一部分编写，但我们建议按照**服务定位器模式**（参见“Service Locator”）将其实现为独立组件。

When the Business Delegate is used with a Session Facade, typically there is a one-to-one relationship between the two. This one-to-one relationship exists because logic that might have been encapsulated in a Business Delegate relating to its interaction with multiple business services (creating a one-to-many relationship) will often be factored back into a Session Facade.  

当业务委托（Business Delegate）与会话门面（Session Facade）配合使用时，二者通常存在一对一关系。这种一对一关系的存在，是因为原本可能封装在业务委托中、涉及与多个业务服务交互的逻辑（形成一对多关系），往往会被重构到会话门面中。

Finally, it should be noted that this pattern could be used to reduce coupling between other tiers, not simply the presentation and the business tiers.  

最后需要指出的是，该模式不仅可用于降低表示层与业务层之间的耦合度，还可用于解耦其他层级之间的依赖关系。

# Structure  

Figure 8.1 shows the class diagram representing the Business Delegate pattern. The client requests the BusinessDelegate to provide access to the underlying business service. The BusinessDelegate uses a LookupService to locate the required BusinessService component.  

图8.1展示了表示业务委托模式的类图。客户端请求BusinessDelegate提供对底层业务服务的访问权限。BusinessDelegate通过LookupService定位所需的BusinessService组件。

![](images/c954dad4af543bef2604e09a2035229393b6a912085780ae8038286de61a4032.jpg)  
Figure 8.1. BusinessDelegate class diagram  

图 8.1. BusinessDelegate 类图

# Participants and Responsibilities  

Figure 8.2 and Figure 8.3 show sequence diagrams that illustrate typical interactions for the Business Delegate pattern.  

图8.2和图8.3展示了说明**业务委托模式**典型交互的时序图。

![](images/12a6fb0104a4973d2dd5e55eab8b7b911c2e7f605fbcd5df33c05f9ecb650d81.jpg)  
Figure 8.2. BusinessDelegate sequence diagram  

图8.2. BusinessDelegate序列图

![](images/90269f85ae3d4b0e03b6c7b60b42eb696a820934c66b87b8acd34a8ea59d41a2.jpg)  
Figure 8.3. BusinessDelegate with ID sequence diagram  

图8.3 带ID序列图的BusinessDelegate

The BusinessDelegate uses a LookupService for locating the business service. The business service is used to invoke the business methods on behalf of the client. The Get ID method shows that the BusinessDelegate can obtain a String version of the handle (such as EJBHandle object) for the business service and return it to the client as a String. The client can use the String version of the handle at a later time to reconnect to the business service it was using when it obtained the handle. This technique will avoid new lookups, since the handle is capable of reconnecting to its business service instance. It should be noted that handle objects are implemented by the container provider and may not be portable across containers from different vendors.  

BusinessDelegate通过LookupService定位业务服务。该业务服务用于代表客户端调用业务方法。Get ID方法表明，BusinessDelegate能够获取业务服务的句柄（例如EJBHandle对象）的字符串形式，并将其作为字符串返回给客户端。客户端后续可利用该字符串形式的句柄重新连接到先前使用的业务服务。由于句柄能够重新连接到其业务服务实例，该技术可避免重复查找操作。需注意，句柄对象由容器供应商实现，在不同厂商的容器间可能不具备可移植性。

The sequence diagram in Figure 8.3 shows obtaining a BusinessService (such as a session or an entity bean) using its handle.  

图8.3中的序列图展示了通过句柄获取BusinessService（例如会话Bean或实体Bean）的过程。

# BusinessDelegate  

The BusinessDelegate's role is to provide control and protection for the business service. The BusinessDelegate can expose two types of constructors to clients. One type of request instantiates the BusinessDelegate without an ID, while the other instantiates it with an ID, where ID is a String version of the reference to a remote object, such as EJBHome or EJBObject.  

`BusinessDelegate` 的作用是为业务服务提供控制与保护。它可向客户端暴露两种类型的构造函数：一种请求实例化时不带 ID 的 `BusinessDelegate`，另一种则携带 ID 进行实例化。此处的 ID 是以字符串形式表示的远程对象引用（例如 `EJBHome` 或 `EJBObject`）。

When initialized without an ID, the BusinessDelegate requests the service from the Lookup Service, typically implemented as a Service Locator (see “Service Locator”), which returns the Service Factory, such as EJBHome. The BusinessDelegate requests that the Service Factory locate, create, or remove a BusinessService, such as an enterprise bean.  

当未指定ID进行初始化时，BusinessDelegate会向查找服务（通常实现为服务定位器，参见“服务定位器”）请求服务，该定位器将返回服务工厂（例如EJBHome）。随后BusinessDelegate要求服务工厂定位、创建或移除业务服务（例如企业级Bean）。

When initialized with an ID string, the BusinessDelegate uses the ID string to reconnect to the BusinessService. Thus, the BusinessDelegate shields the client from the underlying implementation details of BusinessService naming and lookup. Furthermore, the presentation-tier client never directly makes a remote invocation on a BusinessSession; instead, the client uses the BusinessDelegate.  

当使用ID字符串初始化时，BusinessDelegate会通过该ID字符串重新连接到BusinessService。因此，BusinessDelegate将客户端与BusinessService的命名和查找底层实现细节隔离开来。此外，表示层客户端永远不会直接对BusinessSession进行远程调用，而是通过BusinessDelegate完成操作。

# LookupService  

The BusinessDelegate uses the LookupService to locate the BusinessService. The LookupService encapsulates the implementation details of BusinessService lookup.  

BusinessDelegate通过LookupService定位BusinessService。LookupService封装了BusinessService查找的实现细节。

# BusinessService  

The BusinessService is a business-tier component, such as an enterprise bean or a JMS component, that provides the required service to the client.  

`BusinessService` 是一种业务层组件，例如企业级 Bean 或 JMS 组件，用于向客户端提供所需服务。

# Strategies  

# Delegate Proxy Strategy  

The Business Delegate exposes an interface that provides clients access to the underlying methods of the business service API. In this strategy, a Business Delegate provides proxy function to pass the client methods to the session bean it is encapsulating. The Business Delegate may additionally cache any necessary data, including the remote references to the session bean's home or remote objects to improve performance by reducing the number of lookups. The Business Delegate may also convert such references to String versions (IDs) and vice versa, using the services of a Service Locator.  

业务委托模式通过暴露一个接口，使客户端能够访问业务服务API的底层方法。在该策略中，业务委托提供代理功能，将客户端方法传递至其封装的会话Bean。业务委托还可缓存包括会话Bean的Home或远程对象引用在内的必要数据，通过减少查找次数来提升性能。此外，业务委托可利用服务定位器的功能，将这些引用转换为字符串形式（ID）或执行反向转换。

The example implementation for this strategy is discussed in the “Sample Code” section of this pattern.  

该策略的示例实现详见本模式“示例代码”章节。

# Delegate Adapter Strategy  

The Business Delegate proves to be a nice fit in a B2B environment when communicating with J2EE services. Disparate systems may use an XML as the integration language. Integrating one system to another typically requires an Adapter [GoF] to meld the two disparate systems. Figure 8.4 gives an example.  

业务委托模式在B2B环境中与J2EE服务通信时被证明是一种理想选择。异构系统可采用XML作为集成语言。系统间的集成通常需要一个适配器[GoF]来融合两个异构系统。图8.4展示了相关示例。

![](images/81b8c35325c357c9c3762e12ace9dea205aa38e79f10c90bc599e50f13ce4e13.jpg)  
Figure 8.4. Using the Business Delegate pattern with an Adapter strategy  

图8.4 结合适配器策略使用业务委托模式

# Consequences  

Reduces Coupling, Improves Manageability  

降低耦合度，提升可管理性

The Business Delegate reduces coupling between the presentation tier and the business tier by hiding all business-tier implementation details. It is easier to manage changes because they are centralized in one place, the Business Delegate.  

业务委托模式通过隐藏所有业务层的实现细节，降低了表示层与业务层之间的耦合度。由于变更集中在业务委托这一处进行管理，因此更易于维护。

# Translates Business Service Exceptions  

The Business Delegate is responsible for translating any network or infrastructure-related exceptions into business exceptions, shielding clients from knowledge of the underlying implementation specifics.  

业务委托（Business Delegate）负责将所有与网络或基础设施相关的异常转换为业务异常，使客户端无需了解底层实现细节。

# Implements Failure Recovery and Thread Synchronization  

The Business Delegate on encountering a business service failure, may implement automatic revovery features without exposing the problem to the client. If the recovery succeeds, the client need not know about the failure. If the recovery attempt does not succeed, then the Business Delegate needs to inform the client of the failure. Additionally, the business delegate methods may be synchronized, if necessary.  

当业务委托(Business Delegate)遭遇业务服务故障时，可实施自动恢复机制而无需向客户端暴露问题。若恢复成功，客户端无需知晓此次故障；若恢复尝试未果，则业务委托需向客户端通知该故障。此外，业务委托方法可根据需求进行同步处理。

# Exposes Simpler, Uniform Interface to Business Tier  

The Business Delegate, to better serve its clients, may provide a variant of the interface provided by the underlying enterprise beans.  

业务委托（Business Delegate）可为底层企业级Bean提供的接口提供变体实现，以便更好地服务其客户端。

# Impacts Performance  

The Business Delegate may provide caching services (and better performance) to the presentation tier for common service requests.  

业务委托模式可为常见服务请求向表示层提供缓存服务（及更优的性能）。

# Introduces Additional Layer  

The Business Delegate may be seen as adding an unnecessary layer between the client and the service, thus introducing added complexity and decreasing flexibility. Some developers may feel that it is an extra effort to develop Business Delegates with implementations that use the Delegate Proxy strategy. At the same time, the benefits of the pattern typically outweigh such drawbacks.  

业务委托模式可能会被视为在客户端与服务之间添加了不必要的层级，从而引入额外复杂性并降低灵活性。部分开发者可能认为采用委托代理策略实现业务委托需要额外开发工作量。但通常情况下，该模式带来的优势往往能超越这些缺点。

# Hides Remoteness  

While location transparency is one of the benefits of this pattern, a different problem may arise due to the developer treating a remote service as if it was a local one. This may happen if the client developer does not understand that the Business Delegate is a client side proxy to a remote service. Typically, a method invocations on the Business Delegate results in a remote method invocation under the wraps. Ignoring this, the developer may tend to make numerous method invocations to perform a single task, thus increasing the network traffic.  

虽然位置透明性是该模式的优势之一，但开发者将远程服务当作本地服务使用时可能会引发另一个问题。当客户端开发者未能理解**Business Delegate**实质上是远程服务的客户端代理时，这种情况就会发生。通常对**Business Delegate**的方法调用会隐式转换为远程方法调用。若忽视这一点，开发者可能通过多次方法调用来完成单一任务，从而导致网络流量激增。

# Sample Code  

# Implementing the Business Delegate Pattern  

Consider a Professional Services Application (PSA), where a Web-tier client needs to access a session bean that implements the Session Facade pattern. The Business Delegate pattern can be applied to design a Delegate class ResourceDelegate, which encapsulates the complexity of dealing with the session bean ResourceSession. The ResourceDelegate implementation for this example is shown in Example 8.1, and the corresponding remote interface for the Session Facade bean ResourceSession is shown in Example 8.2.  

以一个专业服务应用（PSA）为例，当Web层客户端需要访问实现了会话门面（Session Facade）模式的会话Bean时，可采用业务委托（Business Delegate）模式设计委托类`ResourceDelegate`，该类封装了与会话Bean `ResourceSession`交互的复杂性。本例中的`ResourceDelegate`实现如示例8.1所示，对应的会话门面Bean `ResourceSession`远程接口如示例8.2所示。

# Example 8.1 Implementing Business Delegate Pattern - ResourceDelegate  

// imports  

// 导入声明

public class ResourceDelegate { // Remote reference for Session Facade private ResourceSession session; // Class for Session Facade's Home object private static final Class homeClazz $=$ corepatterns.apps.psa.ejb.ResourceSessionHome.class // Default Constructor. Looks up home and connects // to session by creating a new one public ResourceDelegate() throws ResourceException { try { ResourceSessionHome home $=$ (ResourceSessionHome) ServiceLocator.getInstance().getHome( "Resource", homeClazz); session $=$ home.create(); catch(ServiceLocatorException ex) { // Translate Service Locator exception into  

public class ResourceDelegate { // Session Facade的远程引用  
private ResourceSession session;  
// Session Facade的Home对象类  
private static final Class homeClazz $=$ corepatterns.apps.psa.ejb.ResourceSessionHome.class  

// 默认构造函数。查找Home并通过创建新实例连接到Session  
public ResourceDelegate() throws ResourceException {  
    try {  
        ResourceSessionHome home $=$ (ResourceSessionHome) ServiceLocator.getInstance().getHome(  
            "Resource", homeClazz);  
        session $=$ home.create();  
    catch(ServiceLocatorException ex) {  
        // 将Service Locator异常转换为

// application exception throw new ResourceException(...); } catch(CreateException ex) { // Translate the Session create exception into // application exception throw new ResourceException(...); } catch(RemoteException ex) { // Translate the Remote exception into // application exception throw new ResourceException(...);   
// Constructor that accepts an ID (Handle id) and   
// reconnects to the prior session bean instead   
// of creating a new one   
public BusinessDelegate(String id) throws ResourceException { super(); reconnect(id);   
}   
// Returns a String ID the client can use at a   
// later time to reconnect to the session bean   
public String getID() { try { return ServiceLocator.getId(session); } catch (Exception e) { // Throw an application exception   
// method to reconnect using String ID   
public void reconnect(String id) throws ResourceException { try { session $=$ (ResourceSession) ServiceLocator.getService(id); } catch (RemoteException ex) { // Translate the Remote exception into // application exception throw new ResourceException(...); }  

// 应用异常  
throw new ResourceException(...);  
} catch(CreateException ex) {  
    // 将Session创建异常转换为应用异常  
    throw new ResourceException(...);  
} catch(RemoteException ex) {  
    // 将远程异常转换为应用异常  
    throw new ResourceException(...);  

// 接受ID（Handle id）的构造函数  
// 重新连接到先前的会话Bean而非创建新实例  
public BusinessDelegate(String id) throws ResourceException {  
    super();  
    reconnect(id);  
}  

// 返回客户端可用于后续重新连接会话Bean的字符串ID  
public String getID() {  
    try {  
        return ServiceLocator.getId(session);  
    } catch (Exception e) {  
        // 抛出应用异常  

// 通过字符串ID重新连接的方法  
public void reconnect(String id) throws ResourceException {  
    try {  
        session = (ResourceSession) ServiceLocator.getService(id);  
    } catch (RemoteException ex) {  
        // 将远程异常转换为应用异常  
        throw new ResourceException(...);  
    }

// The following are the business methods // proxied to the Session Facade. If any service // exception is encountered, these methods convert // them into application exceptions such as // ResourceException, SkillSetException, and so // forth.  

// 以下是被代理至会话门面的业务方法。若遇到任何服务异常，  
// 这些方法会将其转换为应用异常，例如  
// ResourceException、SkillSetException等。

public ResourceVO setCurrentResource( String resourceId) throws ResourceException { try { return session.setCurrentResource(resourceI } catch (RemoteException ex) { // Translate the service exception into // application exception throw new ResourceException(...);   
public ResourceVO getResourceDetails() throws ResourceException { try { return session.getResourceDetails(); } catch(RemoteException ex) { // Translate the service exception into // application exception throw new ResourceException(...);   
public void setResourceDetails(ResourceVO vo) throws ResourceException { try { session.setResourceDetails(vo); } catch(RemoteException ex) { throw new ResourceException(...); }   
public void addNewResource(ResourceVO vo) throws ResourceException { try { session.addResource(vo); } catch(RemoteException ex) {  

public ResourceVO setCurrentResource( String resourceId) throws ResourceException { try { return session.setCurrentResource(resourceI } catch (RemoteException ex) { // 将服务异常转换为应用异常 throw new ResourceException(...);   
public ResourceVO getResourceDetails() throws ResourceException { try { return session.getResourceDetails(); } catch(RemoteException ex) { // 将服务异常转换为应用异常 throw new ResourceException(...);   
public void setResourceDetails(ResourceVO vo) throws ResourceException { try { session.setResourceDetails(vo); } catch(RemoteException ex) { throw new ResourceException(...); }   
public void addNewResource(ResourceVO vo) throws ResourceException { try { session.addResource(vo); } catch(RemoteException ex) {

throw new ResourceException(...); // all other proxy method to session bean  

抛出新的 ResourceException(...); // 所有其他代理方法均委托给会话 Bean

# Example 8.2 Remote Interface for ResourceSession  

imports   
ublic interface ResourceSession extends EJBObject {   
public ResourceVO setCurrentResource( String resourceId) throws RemoteException, ResourceException;   
public ResourceVO getResourceDetails() throws RemoteException, ResourceException;   
public void setResourceDetails(ResourceVO resource) throws RemoteException, ResourceException;   
public void addResource(ResourceVO resource) throws RemoteException, ResourceException;   
public void removeResource() throws RemoteException, ResourceException;   
// methods for managing blockout time by the   
// resource   
public void addBlockoutTime(Collection blockoutTime) throws RemoteException, BlockoutTimeException;   
public void updateBlockoutTime( Collection blockoutTime) throws RemoteException, BlockoutTimeException;   
public void removeBlockoutTime( Collection blockoutTime) throws RemoteException, BlockoutTimeException;   
public void removeAllBlockoutTime() throws RemoteException, BlockoutTimeException;   
// methods for resource skillsets time by the   
//resource   
public void addSkillSets(Collection skillSet) throws RemoteException, SkillSetException;   
public void updateSkillSets(Collection skillSet) throws RemoteException, SkillSetException;   
public void removeSkillSet(Collection skillSet) throws RemoteException, SkillSetException;  

imports  
public interface ResourceSession extends EJBObject {  
public ResourceVO setCurrentResource( String resourceId) throws RemoteException, ResourceException;  
public ResourceVO getResourceDetails() throws RemoteException, ResourceException;  
public void setResourceDetails(ResourceVO resource) throws RemoteException, ResourceException;  
public void addResource(ResourceVO resource) throws RemoteException, ResourceException;  
public void removeResource() throws RemoteException, ResourceException;  
// 用于管理资源屏蔽时间的方法  
public void addBlockoutTime(Collection blockoutTime) throws RemoteException, BlockoutTimeException;  
public void updateBlockoutTime( Collection blockoutTime) throws RemoteException, BlockoutTimeException;  
public void removeBlockoutTime( Collection blockoutTime) throws RemoteException, BlockoutTimeException;  
public void removeAllBlockoutTime() throws RemoteException, BlockoutTimeException;  
// 用于管理资源技能集的方法  
public void addSkillSets(Collection skillSet) throws RemoteException, SkillSetException;  
public void updateSkillSets(Collection skillSet) throws RemoteException, SkillSetException;  
public void removeSkillSet(Collection skillSet) throws RemoteException, SkillSetException;

# Related Patterns  

# Service Locator  

The Service Locator pattern may be used to create the Business Delegate's Service Locator, hiding the implementation details of any business service lookup and access code.  

服务定位器模式可用于创建业务委托的服务定位器，从而隐藏任何业务服务查找和访问代码的实现细节。

# Proxy [GoF]  

A Business Delegate may act as a proxy, providing a stand-in for objects in the business tier.  

业务委托（Business Delegate）可作为代理，为业务层中的对象提供替身。

# Adapter [GoF]  

A Business Delegate may use the Adapter pattern to provide coupling for disparate systems.  

业务委托（Business Delegate）可采用适配器模式为异构系统提供耦合支持。

# Broker [POSA1]  

A Business Delegate performs the role of a broker to decouple the business tier objects from the clients in other tiers.  

业务委托（Business Delegate）扮演代理角色，用于将业务层对象与其他层中的客户端解耦。

# Value Object  

# Context  

Application clients need to exchange data with enterprise beans.  

应用客户端需要与企业级Bean进行数据交换。

# Problem  

J2EE applications implement server-side business components as session beans and entity beans. Some methods exposed by the business components return data to the client. Often, the client invokes a business object's get methods multiple times until it obtains all the attribute values.  

J2EE应用将服务端业务组件实现为会话Bean和实体Bean。业务组件暴露的某些方法会向客户端返回数据。客户端通常需要多次调用业务对象的get方法，直至获取所有属性值。

Session beans represent the business services and are not shared between users. A session bean provides coarse-grained service methods when implemented per the Session Facade pattern.  

会话Bean代表业务服务，且不在用户间共享。当按照会话门面模式实现时，会话Bean提供粗粒度的服务方法。

Entity beans, on the other hand, are multiuser, transactional objects representing persistent data. An entity bean exposes the values of attributes by providing an accessor method (also referred to as a getter or get method) for each attribute it wishes to expose.  

另一方面，实体Bean是多用户、支持事务的对象，用于表示持久化数据。实体Bean通过为每个需要暴露的属性提供访问器方法（也称为getter或get方法）来公开属性值。

Every method call made to the business service object, be it an entity bean or a session bean, is potentially remote. Thus, in an EJB application such remote invocations use the network layer regardless of the proximity of the client to the bean, creating a network overhead. Enterprise bean method calls may permeate the network layers of the system even if the client and the EJB container holding the entity bean are both running in the same JVM, OS, or physical machine. Some vendors may implement mechanisms to reduce this overhead by using a more direct access approach and bypassing the network.  

对业务服务对象（无论是实体Bean还是会话Bean）的每次方法调用都可能是远程的。因此，在EJB应用中，此类远程调用无论客户端与Bean的物理距离如何都会使用网络层，从而产生网络开销。即使客户端和承载实体Bean的EJB容器运行在同一个JVM、操作系统或物理机器上，企业Bean的方法调用仍可能穿透系统的网络层。部分供应商可能通过采用更直接的访问机制绕过网络，以降低此类开销。

As the usage of these remote methods increases, application performance can significantly degrade. Therefore, using multiple calls to get methods that return single attribute values is inefficient for obtaining data values from an enterprise bean.  

随着这些远程方法使用频率的增加，应用程序性能会显著下降。因此，通过多次调用返回单个属性值的get方法从企业级Bean获取数据值的做法效率低下。

# Forces  

All access to an enterprise bean is performed via remote interfaces to the bean. Every call to an enterprise bean is potentially a remote method call with network overhead. Typically, applications have a greater frequency of read transactions than update transactions. The client requires the data from the business tier for presentation, display, and other read-only types of processing. The client updates the data in the business tier much less frequently than it reads the data. The client usually requires values for more than one attribute or dependent object from an enterprise bean. Thus, the client may invoke multiple remote calls to obtain the required data.  

对企业级Bean的所有访问均通过其远程接口执行。每次对企业级Bean的调用本质上都是带有网络开销的远程方法调用。通常情况下，应用程序读取事务的频率远高于更新事务。客户端需要从业务层获取数据以进行展示、呈现等只读类处理，其更新业务层数据的频率远低于读取频率。客户端通常需要从企业级Bean获取多个属性值或依赖对象，因此可能需要发起多次远程调用来获取所需数据。

The number of calls made by the client to the enterprise bean impacts network performance. Chattier applications—those with increased traffic between client and server tiers—often degrade network performance.  

客户端对企业级Bean的调用次数会影响网络性能。通信密集型应用（即客户端与服务器层间流量较高的应用）通常会导致网络性能下降。

# Solution  

Use a Value Object to encapsulate the business data. A single method call is used to send and retrieve the value object. When the client requests the enterprise bean for the business data, the enterprise bean can construct the value object, populate it with its attribute values, and pass it by value to the client.  

使用值对象封装业务数据。通过单一方法调用来发送和检索该值对象。当客户端向企业级Bean请求业务数据时，企业级Bean可构造该值对象，用其属性值填充后，按值传递给客户端。

Clients usually require more than one value from an enterprise bean. To reduce the number of remote calls and to avoid the associated overhead, it is best to use value objects to transport the data from the enterprise bean to its client.  

客户端通常需要从企业级Bean获取多个值。为减少远程调用次数并避免相关开销，最佳实践是使用值对象将数据从企业级Bean传输至客户端。

When an enterprise bean uses a value object, the client makes a single remote method invocation to the enterprise bean to request the value object instead of numerous remote method calls to get individual attribute values. The enterprise bean then constructs a new value object instance, copies values into the object and returns it to the client. The client receives the value object and can then invoke accessor (or getter) methods on the value object to get the individual attribute values from the value object. Or, the implementation of the value object may be such that it makes all attributes public. Because the value object is passed by value to the client, all calls to the value object instance are local calls instead of remote method invocations.  

当企业级Bean使用值对象时，客户端只需通过一次远程方法调用来请求该值对象，而非通过多次远程调用来获取单个属性值。企业级Bean会构造一个新的值对象实例，将属性值复制到该对象中并返回给客户端。客户端接收值对象后，可通过调用其访问器（或getter）方法从值对象中获取各属性值。或者，值对象的实现可能将所有属性设为公开。由于值对象以传值方式传递给客户端，对该值对象实例的所有调用均为本地调用，而非远程方法调用。

# Structure  

Figure 8.5 shows the class diagram that represents the Value Object pattern in its simplest form.  

图8.5展示了以最简形式呈现的**值对象模式**类图。

![](images/f83958e6afcb7149559033dc80725494460e092bba31e7c946397145d547c7ef.jpg)  
Figure 8.5. Value Object class diagram  

图8.5 值对象类图

As shown in this class diagram, the value object is constructed on demand by the enterprise bean and returned to the remote client. However, the Value Object pattern can adopt various strategies, depending on requirements. The “Strategies” section explains these approaches.  

如该**类图**所示，该值对象由企业级Bean按需构造并返回给远程客户端。然而**值对象模式**可根据需求采用多种策略，具体方法详见“策略”章节。

# Participants and Responsibilities  

Figure 8.6 contains the sequence diagram that shows the interactions for the Value Object pattern.  

图8.6展示了**值对象模式**交互过程的序列图。

![](images/8b859780d0833b385422eed7c278093298db658721352273dd6f5a45789e09ee.jpg)  
Figure 8.6. Value Object sequence diagram  

图8.6 值对象序列图

# Client  

This represents the client of the enterprise bean. The client can be an end-user application, as in the case of a rich client application that has been designed to directly access the enterprise beans. The client can be Business Delegates (see “Business Delegate”) or a different BusinessObject  

这代表企业级Bean的客户端。该客户端可以是终端用户应用程序，例如专为直接访问企业级Bean而设计的富客户端应用；也可以是业务委托（参见“业务委托模式”）或其他业务对象。

# BusinessObject  

The BusinessObject represents a role in this pattern that can be fulfilled by a session bean, an entity bean, or a Data Access Object (DAO). The BusinessObject is responsible for creating the value object and returning it to the client upon request. The BusinessObject may also receive data from the client in the form of a value object and use that data to perform an update.  

在该模式中，**BusinessObject** 可由会话Bean、实体Bean或数据访问对象（DAO）承担其角色。BusinessObject 负责创建值对象并根据客户端请求返回该对象。它亦可接收客户端以值对象形式提交的数据，并利用这些数据执行更新操作。

# ValueObject  

The ValueObject is an arbitrary serializable Java object referred to as a value object. A value object class may provide a constructor that accepts all the required attributes to create the value object. The constructor may accept all entity bean attribute values that the value object is designed to hold. Typically, the members in the value object are defined as public, thus eliminating the need for get and set methods. If some protection is necessary, then the members could be defined as protected or private, and methods are provided to get the values. By offering no methods to set the values, a value object is protected from modification after its creation. If only a few members are allowed to be modified to facilitate updates, then methods to set the values can be provided. Thus, the value object creation varies depending on an application's requirements. It is a design choice as to whether the value object's attributes are private and accessed via getters and setters, or all the attributes are made public.  

值对象（ValueObject）是一个可序列化的任意Java对象。值对象类可提供接受所有必需属性的构造函数以创建该对象，该构造函数可接收值对象设计持有的所有实体Bean属性值。通常，值对象中的成员被定义为`public`，从而无需提供get和set方法。若需保护性控制，成员可定义为`protected`或`private`，并通过方法提供值访问。通过不提供设值方法，可确保值对象在创建后不被修改。若需允许部分成员被修改以支持更新，则可提供相应的设值方法。因此，值对象的创建方式取决于应用需求。其属性是私有并通过getter/setter访问，还是全部公开，属于设计选择范畴。

# Strategies  

The first two strategies discussed are applicable when the enterprise bean is implemented as a session bean or as an entity bean. These strategies are called Updatable Value Objects Strategy and Multiple Value Objects Strategy  

前两种讨论的策略适用于将企业级Bean实现为会话Bean或实体Bean的场景。这些策略分别称为**可更新值对象策略**和**多值对象策略**。

The following strategies are applicable only when the BusinessObject is implemented as an entity bean: Entity Inherits Value Object Strategy and Value Object Factory Strategy  

以下策略仅当**BusinessObject**作为实体Bean实现时适用：**实体继承值对象策略**与**值对象工厂策略**

# Updatable Value Objects Strategy  

In this strategy, the value object not only carries the values from the BusinessObject to the client, but also can carry the changes required by the client back to the business object.  

在该策略中，值对象不仅负责将业务对象的值传递给客户端，还能将客户端所需的变更回传给业务对象。

Figure 8.7 is a class diagram showing the relationship between the BusinessObject and the value object.  

图8.7展示了BusinessObject与值对象之间关系的类图。

![](images/cd5742ffbd4e5e31814793485a87800bc24eecb3977b291cf3ee7b6fef643dfe.jpg)  
Figure 8.7. Updatable Value Object strategy – class diagram  

图8.7 可更新值对象策略——类图

The BusinessObject creates the value object. Recall that a client may need to access the BusinessObject values not only to read them but to modify these values. For the client to be able to modify the BusinessObject attribute values, the BusinessObject must provide mutator methods. Mutator methods are also referred to as setters or set methods.  

`BusinessObject`创建值对象。需要注意的是，客户端不仅可能需要读取`BusinessObject`的值，还可能需修改这些值。为了让客户端能够修改`BusinessObject`的属性值，`BusinessObject`必须提供修改方法（mutator methods），这些方法也被称为setter或set方法。

Instead of providing fine-grained set methods for each attribute, which results in network overhead, the BusinessObject can expose a coarse-grained setData() method that accepts a value object as an argument. The value object passed to this method holds the updated values from the client. Since the value object has to be mutable, the value object class has to provide set methods for each attribute that can be modified by the client. The set methods for the value object can include field level validations and integrity checks as needed. Once the client obtains a value object from the BusinessObject, the client invokes the necessary set methods locally to change the attribute values. Such local changes do not impact the BusinessObject until the setData() method is invoked.  

业务对象无需为每个属性提供细粒度的set方法（这会导致网络开销），而是可以暴露一个粗粒度的`setData()`方法，该方法接受值对象作为参数。传递给此方法的值对象持有来自客户端的更新值。由于值对象必须是可变的，其类需要为每个可被客户端修改的属性提供set方法。值对象的set方法可按需包含字段级验证和完整性检查。当客户端从业务对象获取值对象后，会在本地调用必要的set方法修改属性值。在调用`setData()`方法前，这些本地变更不会影响业务对象。

The setData() method serializes the client's copy of the value object and sends it to the BusinessObject. The BusinessObject receives the modified value object from the client and merges the changes into its own attributes. The merging operation may complicate the design of the BusinessObject and the value object; the “Consequences” section discusses these potential complications. One strategy to use here is to update only attributes that have changed, rather than updating all attributes. A change flag placed in the value object can be used to determine the attributes to update, rather than doing a direct comparison.  

`setData()`方法将客户端持有的值对象副本序列化后发送至`BusinessObject`。`BusinessObject`接收来自客户端的修改后值对象，并将其变更合并到自身属性中。这种合并操作可能会使`BusinessObject`和值对象的设计复杂化，"Consequences"章节将探讨这些潜在问题。此处可采用的一种策略是仅更新已变更的属性，而非全部属性。通过在值对象中设置变更标志位来确定需更新的属性，而非直接进行属性比对。

There is an impact on the design using the updatable value objects in terms of update propagation, synchronization, and version control.  

使用可更新值对象会对设计产生影响，涉及更新传播、同步和版本控制等方面。

Figure 8.8 shows the sequence diagram for the entire update interaction.  

图8.8展示了整个更新交互过程的时序图。

![](images/d985851ae900041379fa607ca4b209a037a4f93bece42fde5483f7d46615836a.jpg)  
Figure 8.8. Updatable Value Object strategy – sequence diagram  

图8.8 可更新值对象策略——序列图

# Multiple Value Objects Strategy  

Some application business objects can be very complex. In such cases, it is possible that a single business object produces different value objects, depending on the client request. There exists a one-to-many relationship between the business object and the many value objects it can produce. In these circumstances, this strategy may be considered.  

某些应用业务对象可能非常复杂。在这种情况下，单个业务对象可能根据客户端请求生成不同的值对象。业务对象与其可生成的多个值对象之间存在一对多关系。此时可考虑采用此策略。

For instance, when the business object is implemented as a session bean, typically applying the Session Facade pattern, the bean may interact with numerous other business components to provide the service. The session bean produces its value object from different sources. Similarly, when the BusinessObject is implemented as a coarse-grained entity bean, typically applying the Composite Entity pattern, the entity bean will have complex relationships with a number of dependent objects. In both these cases, it is good practice to provide mechanisms to produce value objects that actually represent parts of the underlying coarse-grained components.  

例如，当业务对象以会话Bean形式实现时（通常采用会话门面模式），该Bean可能与众多其他业务组件交互以提供服务。会话Bean会从不同来源生成其值对象。类似地，当业务对象以粗粒度实体Bean形式实现时（通常采用组合实体模式），该实体Bean将与多个依赖对象保持复杂关系。在这两种情况下，最佳实践是提供机制来生成实际表示底层粗粒度组件部分内容的值对象。

For example, in a trading application, a Composite Entity that represents a customer portfolio can be a very coarse-grained complex component that can produce value objects that provide data for parts of the portfolio, like customer information, lists of stocks held, and so on. A similar example is a customer manager session bean that provides services by interacting with a number of other BusinessObjects and components to provide its service. The customer manager bean can produce discrete small value objects, like customer address, contact list, and so on, to represent parts of its model.  

例如，在交易应用程序中，表示客户投资组合的**组合实体**可以是一个粒度非常粗的复杂组件，它能生成**值对象**来为投资组合的各个部分提供数据，如客户信息、持有的股票列表等。类似的例子是客户管理器会话Bean，它通过与其他多个**业务对象**和组件交互来提供服务。该客户管理器Bean可以生成离散的小型值对象（如客户地址、联系人列表等）来表示其模型的各个部分。

For both these scenarios, it is possible to adopt and apply the Multiple Value Objects Strategy so that the business component, whether a session bean or an entity bean, can create multiple types of value objects. In this strategy, the business entity provides various methods to get different value objects. Each such method creates and returns a different type of value object. The class diagram for this strategy is shown Figure 8.9.  

在这两种场景下，均可采用**多值对象策略**，使得业务组件（无论是会话Bean还是实体Bean）能够创建多种类型的值对象。该策略中，业务实体提供多种方法来获取不同的值对象。每个此类方法都会创建并返回一种不同类型的值对象。此策略的类图如图8.9所示。

![](images/d3387157669c005806605f69fbe1f558837b403cef4e1fcde2758bc054134ca3.jpg)  
Figure 8.9. Multiple Value Objects strategy class diagram  

图8.9 多值对象策略类图

When a client needs a value object of type ValueObjectA, it invokes the entity's getDataA() method requesting ValueObjectA. When it needs a value object of type ValueObjectB, it invokes the entity's getDataB() method requesting ValueObjectB, and so on. This is shown in the sequence diagram in Figure 8.10.  

当客户端需要类型为ValueObjectA的值对象时，它会调用实体的`getDataA()`方法请求ValueObjectA。当需要类型为ValueObjectB的值对象时，则调用实体的`getDataB()`方法请求ValueObjectB，以此类推。该流程如图8.10的序列图所示。

![](images/da6820717377cc938b2f417823d5b0014e0e33171dea871a0548cb57756f02e2.jpg)  
Figure 8.10. Multiple Value Objects strategy sequence diagram  

图8.10 多值对象策略时序图

# Entity Inherits Value Object Strategy  

When the BusinessObject is implemented as an entity bean and the clients typically need to access all the data from the entity bean, then the entity bean and the value object both have the same attributes. In this case, since there exists a one-to-one relationship between the entity bean and its value object, the entity bean may be able to use inheritance to avoid code duplication.  

当**BusinessObject**以实体Bean形式实现且客户端通常需要访问实体Bean的所有数据时，实体Bean与值对象将具有相同的属性。由于此时实体Bean与其值对象之间存在一对一关系，可通过继承机制避免代码重复。

In this strategy, the entity bean extends (or inherits from) the value object class. The only assumption is that the entity bean and the value object share the same attribute definitions. The class diagram for this strategy is shown in Figure 8.11.  

在该策略中，实体Bean继承（或扩展）值对象类。唯一的前提条件是实体Bean与值对象需保持相同的属性定义。此策略的类图如图8.11所示。

![](images/481e0b9520a8760025677e32a0f8c946647564f28c7986a2a55a194949d8a8b3.jpg)  
Figure 8.11. Entity Inherits Value Object strategy class diagram  

图 8.11. 实体继承值对象策略类图

The ValueObject implements one or more getData() methods as discussed in the Multiple Value Objects Strategy. When the entity inherits this value object class, the client invokes an inherited getData() method on the entity bean to obtain a value object.  

ValueObject 实现了在**多值对象策略**中讨论的一个或多个 getData() 方法。当实体继承该值对象类时，客户端通过调用实体 Bean 上继承的 getData() 方法来获取值对象。

Thus, this strategy eliminates code duplication between the entity and the value object. It also helps manage changes to the value object requirements by isolating the change to the value object class and preventing the changes from affecting the entity bean.  

因此，该策略消除了实体与值对象之间的代码重复。它还能通过将变更隔离在值对象类中，防止这些变更影响实体Bean，从而有效管理值对象需求的变动。

This strategy has a trade-off related to inheritance. If the value object is shared through inheritance, then changes to this value object class will affect all its subclasses, potentially mandating other changes to the hierarchy.  

该策略在继承方面存在权衡。若值对象通过继承共享，则对该值对象类的修改将影响其所有子类，可能强制要求对继承层次结构进行其他变更。

The sequence diagram in Figure 8.12 demonstrates this strategy.  

图8.12中的序列图展示了该策略。

![](images/3e849332bfa710d433e5116c6a28ad5b6549afbc87ba79f24017177bdf7b05fe.jpg)  
Figure 8.12. Entity Inherits Value Object strategy sequence diagram  

图 8.12. 实体继承值对象策略的序列图

The sample implementation for the Entity Inherits Value Object Strategy is shown in Example 8.10 (ContactVO – Value Object Class) and Example 8.11 (ContactEntity – Entity Bean Class).  

示例8.10（ContactVO——值对象类）和示例8.11（ContactEntity——实体Bean类）展示了实体继承值对象策略的参考实现。

# Value Object Factory Strategy  

The Entity Inherits Value Object Strategy can be further extended to support multiple value objects for an entity bean by employing a value object factory to create value objects on demand using reflection. This results in an even more dynamic strategy for value object creation.  

实体继承值对象策略可通过采用值对象工厂进一步扩展，以支持实体Bean的多个值对象，该工厂利用反射按需创建值对象。这将形成更为动态的值对象创建策略。

To achieve this, define a different interface for each type of value object that must be returned. The entity bean implementation of value object superclass must implement all these interfaces. Furthermore, you must create a separate implementation class for each defined interface, as shown in the class diagram for this strategy in Figure 8.13.  

为此，需为每种必须返回的值对象类型定义不同的接口。值对象超类的实体Bean实现必须实现所有这些接口。此外，必须为每个已定义的接口创建单独的实现类，如图8.13中该策略的类图所示。

![](images/e2e9db6182d1f8f8dac67eea516404d0298dc86916d7bc6d8882d2b5200cdb09.jpg)  
Figure 8.13. Value Object Factory strategy class  

图8.13. 值对象工厂策略类

Once all interfaces have been defined and implemented, create a method in the ValueObjectFactory that is passed two arguments:  

在所有接口定义并实现后，在ValueObjectFactory中创建一个接收两个参数的方法：

• The entity bean instance for which a value object must be created. The interface that identifies the kind of value object to create.  

• 需要为其创建值对象的实体Bean实例。标识要创建的值对象类型的接口。

The ValueObjectFactory can then instantiate an object of the correct class, set its values, and return the newly created value object instance.  

ValueObjectFactory随后可以实例化正确类的对象，设置其值，并返回新创建的值对象实例。

The sequence diagram for this strategy is shown in Figure 8.14.  

该策略的序列图如图8.14所示。

# Figure 8.14. Value Object Factory strategy sequence  

diagram  

图表

![](images/76c55eb55711a89dd370967e9c5d0a11d5b26c13de9af37906074110d9521726.jpg)  

The client requests the value object from the BusinessEntity. The BusinessEntity passes the required value object's class to the ValueObjectFactory, which creates a new value object of that given class. The ValueObjectFactory uses reflection to dynamically obtain the class information for the value object class and construct a new value object instance. Getting values from and setting values into the BusinessEntity by the ValueObjectFactory is accomplished by using dynamic invocation.  

客户端向BusinessEntity请求值对象。BusinessEntity将所需值对象的类传递给ValueObjectFactory，后者创建该给定类的新值对象实例。ValueObjectFactory通过反射机制动态获取值对象类的信息，并构造新的值对象实例。ValueObjectFactory通过动态调用方式实现从BusinessEntity获取值以及向BusinessEntity设值的操作。

An example implementation for this strategy is shown in the “Sample Code” section for “Implementing Value Object Factory Strategy”.  

该策略的示例实现参见“实现值对象工厂策略”章节中的“示例代码”部分。

The benefits of applying the Value Object Factory Strategy are as follows:  

采用值对象工厂策略的优势如下：

There is less code to write in order to create value objects. The same value object factory class can be reused by different enterprise beans. When a value object class definition changes, the value object factory automatically handles this change without any additional coding effort. This increases maintainability and is less error prone to changes in value object definitions.  

创建值对象所需的代码量更少。同一个值对象工厂类可被不同企业级Bean复用。当值对象类定义发生变更时，值对象工厂会自动处理这种变化，无需额外编码工作。这提高了可维护性，并降低了因值对象定义变更导致错误的风险。

The Value Object Factory Strategy has the following consequences:  

值对象工厂策略会产生以下影响：

It is based on the fact that the enterprise bean implementation extends (inherits) from the complete value object. The complete value object needs to implement all the interfaces defined for different value objects that the entity bean needs to supply. Naming conventions must be adhered to in order to make this strategy work. Since reflection is used to dynamically inspect and construct value objects, there is a slight performance loss in construction. However, when the overall communication time is considered, such loss may be negligible in comparison.  

该方案基于企业级Bean实现需继承完整值对象这一事实。完整值对象需实现实体Bean所需提供的各类值对象所定义的全部接口。为使该策略生效，必须遵循特定的命名规范。由于采用反射机制动态检查并构建值对象，在对象构造阶段会存在轻微性能损耗。但若考量整体通信耗时，此类损耗相较之下通常可忽略不计。

There is a trade-off associated with this strategy. Its power and flexibility must be weighed against the performance overhead associated with runtime reflection.  

采用此策略需要权衡利弊。其强大功能与灵活性必须与运行时反射带来的性能开销进行权衡。

# Consequences  

# Simplifies Entity Bean and Remote Interface  

The entity bean provides a getData() method to get the value object containing the attribute values. This may eliminate having multiple get methods implemented in the bean and defined in the bean's remote interface. Similarly, if the entity bean provides a setData() method to update the entity bean attribute values in a single method call, it may eliminate having multiple set methods implemented in the bean and defined in the bean's remote interface.  

该实体Bean提供了`getData()`方法用于获取包含属性值的值对象。这种方式可以避免在Bean中实现多个get方法并在其远程接口中定义。类似地，若实体Bean提供`setData()`方法通过单次方法调用更新实体Bean属性值，则可避免在Bean中实现多个set方法并在其远程接口中定义。

# Transfers More Data in Fewer Remote Calls  

Instead of multiple client calls over the network to the BusinessObject to get attribute values, this solution provides a single method call. At the same time, this one method call returns a greater amount of data to the client than the individual accessor methods each returned. When considering this pattern, you must consider the trade-off between fewer network calls versus transmitting more data per call. Alternatively, you can provide both individual attribute accessor methods (fine-grained get and set methods) and value object methods (coarse-grained get and set methods). The developer can choose the appropriate technique depending on the requirement.  

该解决方案通过单次方法调用替代了客户端多次网络调用`BusinessObject`获取属性值的操作，同时该方法返回的数据量比逐个访问器方法返回的总和更大。采用此模式时，必须在减少网络调用次数与每次调用传输更多数据之间权衡。另一种方案是同时提供单个属性访问器方法（细粒度的get/set方法）和值对象方法（粗粒度的get/set方法），开发者可根据实际需求选择合适的技术方案。

# Reduces Network Traffic  

A value object transfers the values from the entity bean to the client in one remote method call. The value object acts as a data carrier and reduces the number of remote network method calls required to obtain the attribute values from the entity beans. The reduced chattiness of the application results in better network performance.  

值对象通过一次远程方法调用将实体Bean中的值传输至客户端。该对象作为数据载体，减少了从实体Bean获取属性值所需的远程网络方法调用次数。应用程序通信量的降低带来了更优的网络性能。

# Reduces Code Duplication  

By using the Entity Inherits Value Object Strategy and the Value Object Factory Strategy, it is possible to reduce or eliminate the duplication of code between the entity and its value object. However, with the use of Value Object Factory Strategy, there could be increased complexity in implementation. There is also a runtime cost associated with this strategy due to the use of dynamic reflection. In most cases, the Entity Inherits Value Object Strategy may be sufficient to meet the needs.  

通过采用**实体继承值对象策略**与**值对象工厂策略**，能够减少或消除实体与其值对象间的代码重复。然而，**值对象工厂策略**的使用可能会增加实现复杂度，且由于动态反射的引入会带来运行时开销。在多数场景下，**实体继承值对象策略**已足以满足需求。

# May Introduce Stale Value Objects  

Adopting the Updatable Value Objects Strategy allows the client to perform modifications on the local copy of the value object. Once the modifications are completed, the client can invoke the entity's setData() method and pass the modified value object to the entity. The entity receives the modifications and merges the new (modified) values with its attributes. However, there may be a problem with stale value objects. The entity updates its values, but it is unaware of other clients that may have previously requested the same value object. These clients may be holding in their local cache value object instances that no longer reflect the current copy of the entity's data. Because the entity is not aware of these clients, it is not possible to propagate the update to the stale value objects held by other clients.  

采用**可更新值对象策略**允许客户端对值对象的本地副本执行修改。修改完成后，客户端可调用实体的`setData()`方法，将修改后的值对象传递给实体。实体接收修改并将新值（修改后的值）与其属性合并。  

但该策略可能存在**值对象过期**问题：实体更新了自身值，却无法感知其他可能已请求过相同值对象的客户端。这些客户端可能在本地缓存中持有不再反映实体当前数据状态的值对象实例。由于实体无法感知这些客户端，故无法将更新传播至其他客户端持有的过期值对象。

# May Increase Complexity due to Synchronization and Version Control  

The entity merges modified values into its own stored values when it receives a mutable value object from a client. However, the entity must handle the situation where two or more clients simultaneously request conflicting updates to the entity's values. Allowing such updates may result in data conflicts.  

当实体从客户端接收到可变值对象时，它会将修改后的值合并到自身存储的值中。然而，实体必须处理两个或多个客户端同时请求对实体值进行冲突更新的情况。允许此类更新可能导致数据冲突。

Version control is one way of avoiding such conflict. As one of its attributes, the entity can include a version number or a last-modified time stamp. The version number or time stamp is copied over from the entity bean into the value object. An update transaction can resolve conflicts using the time stamp or version number attribute. If a client holding a stale value object tries to update the entity, the entity can detect the stale version number or time stamp in the value object and inform the client of this error condition. The client then has to obtain the latest value object and retry the update. In extreme cases this can result in client starvation—the client might never accomplish its updates.  

版本控制是避免此类冲突的一种方式。作为其属性之一，实体可以包含版本号或最后修改时间戳。该版本号或时间戳会从实体Bean复制到值对象中。更新事务可通过时间戳或版本号属性解决冲突。若持有过期值对象的客户端尝试更新实体，实体能检测到值对象中的过期版本号或时间戳，并向客户端反馈此错误状态。此时客户端必须获取最新值对象并重试更新。极端情况下，这可能导致客户端陷入饥饿状态——客户端可能永远无法完成其更新操作。

# Concurrent Access and Transactions  

When two or more clients concurrently access the BusinessObject, the container applies the transaction semantics of the EJB architecture. If, for an Enterprise bean, the transaction isolation level is set to   
TRANSACTION_SERIALIZED in the deployment descriptor, the container provides the maximum protection to the transaction and ensures its integrity. For example, suppose the workflow for the first transaction involves obtaining a value object, then subsequently modifying the BusinessObject attributes in the process. The second transaction, since it is isolated to serialized transactions, will obtain the value object with the correct (most recently updated) values. However, for transactions with lesser restrictions than serialized, protection is less rigid, leading to inconsistencies in the value objects obtained by competing accesses. In addition, problems related to synchronization, stale value objects, and version control will have to be dealt with.  

当两个或多个客户端并发访问`BusinessObject`时，容器会应用EJB架构的事务语义。如果企业级Bean在部署描述符中将事务隔离级别设置为`TRANSACTION_SERIALIZED`，容器将为事务提供最高级别的保护并确保其完整性。例如，假设第一个事务的工作流程涉及获取值对象，随后在过程中修改`BusinessObject`属性。由于第二个事务被隔离为串行化事务，它将获取具有正确（最近更新）值的值对象。然而，对于隔离级别低于串行化的事务，保护机制较为宽松，这会导致竞争访问所获取的值对象出现不一致。此外，还需处理与同步、过期值对象和版本控制相关的问题。

# Sample Code  

# Implementing the Value Object Pattern  

Consider an example where a business object called Project is modeled and implemented as an entity bean. The Project entity bean needs to send data to its clients in a value object when the client invokes its getProjectData() method. The value object class for this example, ProjectVO, is shown in Example 8.3  

假设一个业务对象`Project`被建模并实现为实体Bean。当客户端调用其`getProjectData()`方法时，`Project`实体Bean需要将数据通过值对象发送给客户端。本例中的值对象类`ProjectVO`如示例8.3所示。

# Example 8.3 Implementing the Value Object Pattern - Value Object Class  

// Value Object to hold the details for Project   
public class ProjectVO implements java.io.Serializable { public String projectId; public String projectName; public String managerId; public String customerId; public Date startDate; public Date endDate; public boolean started; public boolean completed; public boolean accepted; public Date acceptedDate; public String projectDescription; public String projectStatus;   
// Value object constructors...  

// 用于承载项目详情的值对象  
public class ProjectVO implements java.io.Serializable { public String projectId; public String projectName; public String managerId; public String customerId; public Date startDate; public Date endDate; public boolean started; public boolean completed; public boolean accepted; public Date acceptedDate; public String projectDescription; public String projectStatus;   
// 值对象构造函数...

The sample code for the entity bean that uses this value object is shown in Example 8.4.  

使用该值对象的实体Bean示例代码如例8.4所示。

# Example 8.4 Implementing the Value Object Pattern - Entity Bean Class  

blic class ProjectEntity implements EntityBean { private EntityContext context;   
public String projectId;   
public String projectName;   
public String managerId;   
public String customerId;   
public Date startDate;   
public Date endDate;   
public boolean started;   
public boolean completed;   
public boolean accepted;   
public Date acceptedDate;   
public String projectDescription;   
public String projectStatus;   
private boolean closed;   
// other attributes...   
private ArrayList commitments;   
// Method to get value object for Project data public ProjectVO getProjectData() {   
return createProjectVO();   
}   
// method to create a new value object and // copy data from entity bean into the value // object   
private ProjectVO createProjectVO() {   
ProjectVO proj $=$ new ProjectVO();   
proj.projectId $=$ projectId; proj.projectName $=$ projectName;   
proj.managerId $=$ managerId;   
proj.startDate $=$ startDate;   
proj.endDate $=$ endDate;   
proj.customerId $=$ customerId;   
proj.projectDescription $=$ projectDescription;   
proj.projectStatus $=$ projectStatus;   
proj.started $=$ started;   
proj.completed $=$ completed;   
proj.accepted $=$ accepted;   
proj.closed $=$ closed;   
return proj;  

public class ProjectEntity implements EntityBean {  
private EntityContext context;  
public String projectId;  
public String projectName;  
public String managerId;  
public String customerId;  
public Date startDate;  
public Date endDate;  
public boolean started;  
public boolean completed;  
public boolean accepted;  
public Date acceptedDate;  
public String projectDescription;  
public String projectStatus;  
private boolean closed;  
// 其他属性...  
private ArrayList commitments;  

// 获取项目数据值对象的方法  
public ProjectVO getProjectData() {  
    return createProjectVO();  
}  

// 创建新值对象并将实体Bean数据复制到值对象的方法  
private ProjectVO createProjectVO() {  
    ProjectVO proj = new ProjectVO();  
    proj.projectId = projectId;  
    proj.projectName = projectName;  
    proj.managerId = managerId;  
    proj.startDate = startDate;  
    proj.endDate = endDate;  
    proj.customerId = customerId;  
    proj.projectDescription = projectDescription;  
    proj.projectStatus = projectStatus;  
    proj.started = started;  
    proj.completed = completed;  
    proj.accepted = accepted;  
    proj.closed = closed;  
    return proj;  
}

# Implementing the Updatable Value Objects Strategy  

Example 8.4 can be extended to implement Updatable Value Objects Strategy. In this case, the entity bean would provide a setProjectData() method to update the entity bean by passing a value object that contains the data to be used to perform the update. The sample code for this strategy is shown in Example 8.5.  

示例8.4可扩展为实现可更新值对象策略。此时，实体Bean需提供setProjectData()方法，通过传入包含待更新数据的值对象来执行实体Bean的更新操作。该策略的示例代码如示例8.5所示。

# Example 8.5 Implementing Updatable Value Objects Strategy  

public class ProjectEntity implements EntityBean { private EntityContext context; // attributes and other methods as in Example 8.4 // method to set entity values with a value object public void setProjectData(ProjectVO updatedProj) { mergeProjectData(updatedProj); // method to merge values from the value object into // the entity bean attributes private void mergeProjectData(ProjectVO updatedProj)  

public class ProjectEntity implements EntityBean { private EntityContext context; // 属性及其他方法同示例8.4 // 通过值对象设置实体值的方法 public void setProjectData(ProjectVO updatedProj) { mergeProjectData(updatedProj); // 将值对象中的数据合并到实体Bean属性的方法 private void mergeProjectData(ProjectVO updatedProj)

// version control check may be necessary here // before merging changes in order to   
// prevent losing updates by other clients projectId $=$ updatedProj.projectId;   
projectName $=$ updatedProj.projectName;   
managerId $=$ updatedProj.managerId;   
startDate $=$ updatedProj.startDate;   
endDate $=$ updatedProj.endDate;   
customerId $=$ updatedProj.customerId;   
projectDescription $=$   
updatedProj.projectDescription;   
projectStatus $=$ updatedProj.projectStatus; started $=$ updatedProj.started;   
completed $=$ updatedProj.completed;   
accepted $=$ updatedProj.accepted;   
closed $=$ updatedProj.closed;  

// 此处可能需要版本控制检查 // 在合并变更前  
// 以防止其他客户端的更新丢失  
projectId $=$ updatedProj.projectId;  
projectName $=$ updatedProj.projectName;  
managerId $=$ updatedProj.managerId;  
startDate $=$ updatedProj.startDate;  
endDate $=$ updatedProj.endDate;  
customerId $=$ updatedProj.customerId;  
projectDescription $=$  
updatedProj.projectDescription;  
projectStatus $=$ updatedProj.projectStatus;  
started $=$ updatedProj.started;  
completed $=$ updatedProj.completed;  
accepted $=$ updatedProj.accepted;  
closed $=$ updatedProj.closed;

# Implementing the Multiple Value Objects Strategy  

Consider an example where a Resource entity bean is accessed by clients to request different value objects. The first type of value object, ResourceVO, is used to transfer data for a small set of attributes. The second type of value object, ResourceDetailsVO, is used to transfer data for a larger set of attributes. The client can use the former value object if it needs only the most basic data represented by that value object, and can use the latter if it needs more detailed information. Note that this strategy can be applied in producing two or more value objects that contain different data, and not just subset-superset as shown here.  

考虑一个示例场景：客户端通过访问Resource实体Bean来请求不同的值对象。第一种值对象ResourceVO用于传输少量属性集的数据；第二种值对象ResourceDetailsVO则用于传输更大属性集的数据。当客户端仅需获取该值对象所表示的最基础数据时，可采用前者；若需更详细信息，则可选用后者。需注意，此策略可推广至生成包含不同数据的两个或多个值对象，而不仅限于本文所示的子集-超集关系。

The sample code for the two value objects for this example are shown in Example 8.6 and Example 8.7. The sample code for the entity bean that produces these value objects is shown in Example 8.8, and finally the entity bean client is shown in Example 8.9.  

本示例中两个值对象的示例代码如**示例8.6**和**示例8.7**所示。生成这些值对象的实体Bean代码展示在**示例8.8**中，最终实体Bean客户端的实现见**示例8.9**。

# Example 8.6 Multiple Value Objects Strategy - ResourceVO  

// ResourceVO: This class holds basic information // about the resource public class ResourceVO implements  

// ResourceVO: 该类保存资源的基本信息  
public class ResourceVO implements

java.io.Serializable { public String resourceId;   
public String lastName;   
public String firstName;   
public String department;   
public String grade;  

java.io.Serializable {  
public String resourceId;  
public String lastName;  
public String firstName;  
public String department;  
public String grade;  

（注：根据规则3，代码块及变量名保持原样不翻译）

# Example 8.7 Multiple Value Objects Strategy - ResourceDetailsVO  

// ResourceDetailsVO This class holds detailed   
// information about resource   
public class ResourceDetailsVO { public String resourceId; public String lastName; public String firstName; public String department; public String grade; // other data... public Collection commitments; public Collection blockoutTimes; public Collection skillSets;   
}  

// ResourceDetailsVO 该类用于保存资源的详细信息  
public class ResourceDetailsVO { public String resourceId; public String lastName; public String firstName; public String department; public String grade; // 其他数据... public Collection commitments; public Collection blockoutTimes; public Collection skillSets;   
}

# Example 8.8 Multiple Value Objects Strategy - Resource Entity Bean  

// imports   
public class ResourceEntity implements EntityBean { // entity bean attributes entity bean business methods // Multiple Value Object method : Get ResourceVO public ResourceVO getResourceData() {  

// imports   
public class ResourceEntity implements EntityBean { // 实体Bean属性 实体Bean业务方法 // 多值对象方法：获取ResourceVO public ResourceVO getResourceData() {

create new ResourceVO instance and copy // attribute values from entity bean into VO return createResourceVO(); Multiple Value Object method : Get // ResourceDetailsVO public ResourceDetailsVO getResourceDetailsData() { create new ResourceDetailsVO instance and copy // attribute values from entity bean into VO return createResourceDetailsVO(); // other entity bean methods  

创建新的 ResourceVO 实例并复制 // 将实体 Bean 属性值复制到值对象中  
return createResourceVO();  

多值对象方法：获取 // ResourceDetailsVO  
public ResourceDetailsVO getResourceDetailsData() {  
    创建新的 ResourceDetailsVO 实例并复制 // 将实体 Bean 属性值复制到值对象中  
    return createResourceDetailsVO();  
    // 其他实体 Bean 方法

# Example 8.9 Multiple Value Objects Strategy - Entity Bean Client  

private ResourceEntity resourceEntity;   
private static final Class homeClazz $=$   
corepatterns.apps.psa.ejb.ResourceEntityHome.class;   
try { ResourceEntityHome home $=$ (ResourceEntityHome) ServiceLocator.getInstance().getHome( "Resource", homeClazz); resourceEntity $=$ home.findByPrimaryKey( resourceId);   
} catch(ServiceLocatorException ex) { // Translate Service Locator exception into // application exception throw new ResourceException(...); } catch(FinderException ex) { // Translate the entity bean finder exception into // application exception throw new ResourceException(...);   
} catch(RemoteException ex) { // Translate the Remote exception into // application exception throw new ResourceException(...);   
// retrieve basic Resource data   
ResourceVO vo $=$ resourceEntity.getResourceData();   
// retrieve detailed Resource data   
ResourceDetailsVO $=$ resourceEntity.getResourceDetailsData();  

private ResourceEntity resourceEntity;   
private static final Class homeClazz $=$   
corepatterns.apps.psa.ejb.ResourceEntityHome.class;   
try { ResourceEntityHome home $=$ (ResourceEntityHome) ServiceLocator.getInstance().getHome( "Resource", homeClazz); resourceEntity $=$ home.findByPrimaryKey( resourceId);   
} catch(ServiceLocatorException ex) { // 将服务定位器异常转换为应用异常 throw new ResourceException(...); } catch(FinderException ex) { // 将实体Bean查找异常转换为应用异常 throw new ResourceException(...);   
} catch(RemoteException ex) { // 将远程异常转换为应用异常 throw new ResourceException(...);   
// 获取基础资源数据   
ResourceVO vo $=$ resourceEntity.getResourceData();   
// 获取详细资源数据   
ResourceDetailsVO $=$ resourceEntity.getResourceDetailsData();

# Implementing the Entity Inherits Value Object Strategy  

Consider an example where an entity bean ContactEntity inherits all its properties from a value object ContactVO. Example 8.10 shows the code sample for an example value object ContactVO that illustrates this strategy.  

假设一个示例场景，其中实体Bean `ContactEntity` 从值对象 `ContactVO` 继承所有属性。示例8.10展示了采用该策略的值对象 `ContactVO` 的代码示例。

# Example 8.10 Entity Inherits Value Object Strategy – Value Object Class  

// This is the value object class inherited by   
// the entity bean   
public class ContactVO implements java.io.Serializable {  

// 该值对象类由实体Bean继承  
public class ContactVO implements java.io.Serializable {

// public members public String firstName; public String lastName; public String address; // default constructor public ContactVO() {}  

// 公共成员  
public String firstName;  
public String lastName;  
public String address;  
// 默认构造函数  
public ContactVO() {}

// constructor accepting all values public ContactVO(String firstName, String lastName, String address){ init(firstName, lastName, address);  

// 接收所有参数的构造函数  
public ContactVO(String firstName, String lastName, String address){  
    init(firstName, lastName, address);

// constructor to create a new VO based   
// using an existing VO instance   
public ContactVO(ContactVO contact) { init (contact.firstName, contact.lastName, contact.address);   
// method to set all the values   
public void init(String firstName, String lastName, String address) { this.firstName $=$ firstName; this.lastName $=$ lastName; this.address $=$ address;   
}   
// create a new value object   
public ContactVO getData() { return new ContactVO(this);   
}  

// 基于现有VO实例创建新VO的构造函数  
public ContactVO(ContactVO contact) {  
    init(contact.firstName, contact.lastName, contact.address);  
}  

// 设置所有值的方法  
public void init(String firstName, String lastName, String address) {  
    this.firstName = firstName;  
    this.lastName = lastName;  
    this.address = address;  
}  

// 创建新的值对象  
public ContactVO getData() {  
    return new ContactVO(this);  
}

The entity bean sample code relevant to this pattern strategy is shown in Example 8.11.  

该模式策略相关的实体Bean示例代码如示例8.11所示。

# Example 8.11 Entity Inherits Value Object Strategy - Entity Bean Class  

public class ContactEntity extends ContactVO implements javax.ejb.EntityBean { // the client calls the getData method // on the ContactEntity bean instance. // getData() is inherited from the value object // and returns the ContactVO value object  

public class ContactEntity extends ContactVO implements javax.ejb.EntityBean { // 客户端调用ContactEntity Bean实例的getData方法 // getData()方法继承自值对象 // 并返回ContactVO值对象

# Implementing Value Object Factory Strategy  

Example 8.12 demonstrates the Value Object Factory strategy. The entity bean extends a complete value object called CustomerContactVO. The CustomerContactVO value object implements two interfaces, Customer and Contact. The CustomerVO value object implements Customer, and the ContactVO value object implements Contact.  

示例8.12展示了值对象工厂策略。该实体Bean继承了一个完整的值对象`CustomerContactVO`。`CustomerContactVO`值对象实现了`Customer`和`Contact`两个接口，其中`CustomerVO`值对象实现`Customer`接口，`ContactVO`值对象实现`Contact`接口。

# Example 8.12 Value Object Factory Strategy – Value Objects and Interfaces  

public interface Contact  

public interface Contact

extends java.io.Serializable { public String getFirstName(); public String getLastName(); public String getContactAddress(); public void setFirstName(String firstName); public void setLastName(String lastName); public void setContactAddress(String address);   
public class ContactVO implements Contact { // member attributes public String firstName; public String LastName; public String contactAddress; // implement get and set methods per the // Contact interface here. }   
public interface Customer extends java.io.Serializable { public String getCustomerName(); public String getCustomerAddress(); public void setCustomerName(String customerName); public void setCustomerAddress(String customerAddress);  

继承 java.io.Serializable {  
    public String getFirstName();  
    public String getLastName();  
    public String getContactAddress();  
    public void setFirstName(String firstName);  
    public void setLastName(String lastName);  
    public void setContactAddress(String address);  

public class ContactVO 实现 Contact {  
    // 成员属性  
    public String firstName;  
    public String LastName;  
    public String contactAddress;  
    // 在此实现 Contact 接口的 get 和 set 方法  
}  

public interface Customer 继承 java.io.Serializable {  
    public String getCustomerName();  
    public String getCustomerAddress();  
    public void setCustomerName(String customerName);  
    public void setCustomerAddress(String customerAddress);

public class CustomerVO implements Customer { public String customerName;  

public class CustomerVO implements Customer { public String customerName;

public String customerAddress;  

public String customerAddress;

// implement get and set methods per the // Customer interface here.  

// 根据Customer接口实现get和set方法

public class CustomerContactVO implements Customer, Contact { public String firstName; public String lastName; public String contactAddress; public String customerName; public String customerAddress; // implement get and set methods per the // Customer and Contact interfaces here.  

public class CustomerContactVO implements Customer, Contact {  
    public String firstName;  
    public String lastName;  
    public String contactAddress;  
    public String customerName;  
    public String customerAddress;  
    // 在此根据Customer和Contact接口实现get和set方法

The entity bean code sample to obtain these three different value objects is shown Example 8.13.  

获取这三个不同值对象的实体Bean代码示例见示例8.13。

# Example 8.13 Value Object Factory Strategy - Entity Bean Class  

public class CustomerContactEntity extends CustomerContactVO implements javax.ejb.EntityBean { // implement other entity bean methods...not shown // define constant to hold class name // complete value object. This is required by // the ValueObjectFactory.createValueObject(...) public static final String COMPLETE_VO_CLASSNAME $=$ "CustomerContactVO"; // method to return CustomerContactVO value object public CustomerContactVO getCustomerContact() { return (CustomerContactVO) ValueObjectFactory.createValueObject( this, "CustomerContactVO", COMPLETE_VO_CLASSNAME);  

public class CustomerContactEntity extends CustomerContactVO implements javax.ejb.EntityBean { // 实现其他实体Bean方法...此处省略 // 定义常量存储类名 // 完整值对象。该常量是 // ValueObjectFactory.createValueObject(...)所必需的 public static final String COMPLETE_VO_CLASSNAME $=$ "CustomerContactVO"; // 返回CustomerContactVO值对象的方法 public CustomerContactVO getCustomerContact() { return (CustomerContactVO) ValueObjectFactory.createValueObject( this, "CustomerContactVO", COMPLETE_VO_CLASSNAME);

// method to return CustomerVO value object public CustomerVO getCustomer() { return (CustomerVO) ValueObjectFactory.createValueObject( this, "CustomerVO", COMPLETE_VO_CLASSNAME); // method to return ContactVO value object public ContactVO getContact() { return (ContactVO) ValueObjectFactory.createValueObject( this, "ContactVO", COMPLETE_VO_CLASSNAME); // other entity bean business methods  

// 返回CustomerVO值对象的方法  
public CustomerVO getCustomer() {  
    return (CustomerVO) ValueObjectFactory.createValueObject(  
        this, "CustomerVO", COMPLETE_VO_CLASSNAME);  

// 返回ContactVO值对象的方法  
public ContactVO getContact() {  
    return (ContactVO) ValueObjectFactory.createValueObject(  
        this, "ContactVO", COMPLETE_VO_CLASSNAME);  

// 其他实体Bean业务方法

The ValueObjectFactory class is shown in Example 8.14.  

`ValueObjectFactory` 类如示例 8.14 所示。

# Example 8.14 Value Object Factory Strategy - Factory Class  

import java.util.HashMap;   
import java.lang.\*;   
\*\*   
$\star$ The factory class that creates a value object for a $\star$ given EJB.   
public class ValueObjectFactory {   
/\*\*   
$\star$ Use a HashMap to cache class information for   
$\star$ value object classes   
$^\star/$   
private static HashMap classDataInfo $=$ new HashMap();  

import java.util.HashMap;   
import java.lang.\*;   
\*\*   
$\star$ 该工厂类用于为指定EJB创建值对象  
public class ValueObjectFactory {   
/\*\*   
$\star$ 使用HashMap缓存值对象类的  
$\star$ 类信息  
$^\star/$   
private static HashMap classDataInfo $=$ new HashMap();

eate a value object for the given object. The   
ven object must be an EJB Implementation and hav   
superclass that acts as the class for the entity   
lue object. Only the fields defined in this   
perclass are copied in to the value object.   
ic static java.io.Serializable   
eateValueObject(Object ejb,   
String whichVOType,   
String completeVOType) {   
try {   
// Get the class data for the complete   
// value object type   
ClassData cData $=$ getClassData (completeVOType);   
// Get class data for the requested VO type   
ClassData voCData $=$ getClassData (whichVOType);   
// Create the value object of the requested   
// value object type...   
java.lang.Object whichVO $=$ Class.forName(whichVOType).newInstance();   
// get the VO fields for the requested VO   
// from the ClassData for the requested VO   
java.lang.reflect.Field[] voFields $=$ voCData.arrFields;   
// get all fields for the complete VO   
// from the ClassData for complete VO   
java.lang.reflect.Field[] beanFields $=$ cData.arrFields;   
// copy the common fields from the complete VO   
// to the fields of the requested VO   
for (int $\mathrm{~\small~\underline{~}{~\sigma~}~}=0$ ; $\begin{array}{r l}{\perp}&{{}<}\end{array}$ voFields.length; $\dot{{\bf{\Phi}}}_{\mathrm{{{1}}}}+{\bf{\Phi}}+$ ) { try { String voFieldName $=$ voFields[i].getName(); for (int $\dot{\beth}=0$ ; j $<$ beanFields.length; ${\dot{\vec{\jmath}}}++$ ) { // if the field names are same, copy value if ( voFieldName.equals( beanFields[j].getName())) { // Copy value from matching field // from the bean instance into the new // value object created earlier  

为给定对象创建值对象。该对象必须是EJB实现，并具有作为实体类父类的超类。仅复制此超类中定义的字段到值对象中。

```java
public static java.io.Serializable 
createValueObject(Object ejb, 
    String whichVOType, 
    String completeVOType) {
    try {
        // 获取完整值对象类型的类数据
        ClassData cData = getClassData(completeVOType);
        // 获取请求VO类型的类数据
        ClassData voCData = getClassData(whichVOType);
        // 创建请求值对象类型的实例
        java.lang.Object whichVO = Class.forName(whichVOType).newInstance();
        // 从请求VO的ClassData中获取VO字段
        java.lang.reflect.Field[] voFields = voCData.arrFields;
        // 从完整VO的ClassData中获取所有字段
        java.lang.reflect.Field[] beanFields = cData.arrFields;
        // 将完整VO中的公共字段复制到请求VO的字段中
        for (int i = 0; i < voFields.length; i++) {
            try {
                String voFieldName = voFields[i].getName();
                for (int j = 0; j < beanFields.length; j++) {
                    // 如果字段名相同，则复制值
                    if (voFieldName.equals(beanFields[j].getName())) {
                        // 将匹配字段的值从bean实例复制到先前创建的新值对象中
```

voFields[i].set(whichVO, beanFields[j].get(ejb)); break; catch (Exception e) { // handle exceptions that may be thrown // by the reflection methods... // return the requested value object return (java.io.Serializable)whichVO; catch (Exception ex) { // Handle all exceptions here... } return null;  

voFields[i].set(whichVO, beanFields[j].get(ejb)); break; catch (Exception e) { // 处理可能由反射方法抛出的异常... // 返回请求的值对象 return (java.io.Serializable)whichVO; catch (Exception ex) { // 在此处理所有异常... } return null;

\*\*   
$\star$ Return a ClassData object that contains the information needed to create   
$\star$ a value object for the given class. This information is only obtained from the   
$\star$ class using reflection once, after that it will be   
$\star$ obtained from the classDataInfo HashMap.   
private static ClassData getClassData(String className){ ClassData cData $=$ (ClassData)classDataInfo.get(className); try { if (cData $==$ null) { // Get the class of the given object and the // value object to be created java.lang.reflect.Field[] arrFields ; java.lang.Class ejbVOClass $=$ Class.forName(className); // Determine the fields that must be copied arrFields $=$ ejbVOClass.getDeclaredFields(); cData $=$ new ClassData(ejbVOClass, arrFields); classDataInfo.put(className, cData); } catch (Exception e) { // handle exceptions here... } return cData; }   
/\*\*   
\* Inner Class that contains class data for the   
$\star$ value object classes   
\*/   
class ClassData { // value object Class public Class clsValueObject; // value object fields public java.lang.reflect.Field[] arrFields; // Constructor public ClassData(Class cls, java.lang.reflect.Field[] fields) clsValueObject $=$ cls; arrFields $=$ fields;  

**  
$\star$ 返回一个包含创建给定类值对象所需信息的ClassData对象。该信息仅通过反射从类中获取一次，之后将从classDataInfo HashMap中获取。  
private static ClassData getClassData(String className){ ClassData cData $=$ (ClassData)classDataInfo.get(className); try { if (cData $==$ null) { // 获取给定对象的类及待创建的值对象  
java.lang.reflect.Field[] arrFields ;  
java.lang.Class ejbVOClass $=$ Class.forName(className);  
// 确定需要复制的字段  
arrFields $=$ ejbVOClass.getDeclaredFields();  
cData $=$ new ClassData(ejbVOClass, arrFields);  
classDataInfo.put(className, cData);  
} catch (Exception e) {  
// 在此处理异常...  
}  
return cData;  
}  

/**  
* 内部类，用于存储值对象类的类数据  
*/  
class ClassData {  
// 值对象类  
public Class clsValueObject;  
// 值对象字段  
public java.lang.reflect.Field[] arrFields;  
// 构造函数  
public ClassData(Class cls, java.lang.reflect.Field[] fields)  
clsValueObject $=$ cls;  
arrFields $=$ fields;

# Related Patterns  

# Session Facade  

The Session Facade, which is the business interface for clients of J2EE applications, frequently uses value objects as an exchange mechanism with participating entity beans. When the facade acts as a proxy to the underlying business service, the value object obtained from the entity beans can be passed to the client.  

会话门面（Session Facade）作为J2EE应用程序客户端的业务接口，常采用值对象作为与参与实体Bean的交换机制。当该门面充当底层业务服务的代理时，从实体Bean获取的值对象可被传递至客户端。

# Value Object Assembler  

The Value Object Assembler is a pattern that builds composite value objects from different data sources. The data sources are usually session beans or entity beans that may be requested to provide their data to the Value Object Assembler as value objects. These value objects are considered to be parts of the composite object that the Value Object Assembler assembles.  

值对象组装器是一种从不同数据源构建复合值对象的模式。这些数据源通常是会话Bean或实体Bean，它们可能被要求以值对象的形式向值对象组装器提供数据。这些值对象被视为值对象组装器所组装复合对象的组成部分。

# Value List Handler  

The Value List Handler is another pattern that provides lists of value objects constructed dynamically by accessing the persistent store at request time.  

值列表处理器（Value List Handler）是另一种模式，它通过请求时访问持久化存储动态构建值对象列表。

# Composite Entity  

The Value Object pattern addresses the need of getting data from BusinessObjects across tiers. This certainly is one aspect of design considerations for entity beans. The Composite Entity pattern discusses issues involved in designing coarse-grained entity beans. The Composite Entity pattern addresses complex requirements and discusses other factors and considerations involved in entity bean design.  

**值对象模式**解决了跨层从业务对象获取数据的需求，这无疑是实体Bean设计考量的重要方面。**组合实体模式**则探讨了粗粒度实体Bean设计中的关键问题，该模式针对复杂需求提出了解决方案，并深入分析了实体Bean设计涉及的其他要素与注意事项。

# Session Facade  

# Context  

Enterprise beans encapsulate business logic and business data and expose their interfaces, and thus the complexity of the distributed services, to the client tier.  

企业级Bean封装了业务逻辑与业务数据，并向客户端层暴露其接口，从而隐藏了分布式服务的复杂性。

# Problem  

In a multitiered J2EE application environment, the following problems arise:  

在多层J2EE应用环境中，会出现以下问题：

Tight coupling, which leads to direct dependence between clients and business objects;   
Too many method invocations between client and server, leading to network performance problems;   
Lack of a uniform client access strategy, exposing business objects to misuse.  

紧耦合导致客户端与业务对象之间直接依赖；  
客户端与服务器间过多的方法调用会引发网络性能问题；  
缺乏统一的客户端访问策略，使得业务对象易被误用。

A multitiered J2EE application has numerous server-side objects that are implemented as enterprise beans. In addition, some other arbitrary objects may provide services, data, or both. These objects are collectively referred to as business objects, since they encapsulate business data and business logic.  

多层J2EE应用包含大量以企业级Bean形式实现的服务器端对象。此外，某些其他任意对象可能提供服务、数据或两者兼具。这些对象统称为业务对象，因为它们封装了业务数据和业务逻辑。

J2EE applications implement business objects that provide processing services as session beans. Coarse-grained business objects that represent an object view of persistent storage and are shared by multiple users are usually implemented as entity beans.  

J2EE应用程序通过会话Bean实现业务对象，这些对象提供处理服务。而代表持久存储对象视图且被多用户共享的粗粒度业务对象，通常以实体Bean形式实现。

Application clients need access to business objects to fulfill their responsibilities and to meet user requirements. Clients can directly interact with these business objects because they expose their interfaces. When you expose business objects to the client, the client must understand and be responsible for the business data object relationships, and must be able to handle business process flow.  

应用客户端需要访问业务对象以履行职责并满足用户需求。由于这些业务对象公开了其接口，客户端可直接与之交互。当向客户端暴露业务对象时，客户端必须理解并负责业务数据对象间的关系，同时需具备处理业务流程的能力。

However, direct interaction between the client and the business objects leads to tight coupling between the two, and such tight coupling makes the client directly dependent on the implementation of the business objects. Direct dependence means that the client must represent and implement the complex interactions regarding business object lookups and creations, and must manage the relationships between the participating business objects as well as understand the responsibility of transaction demarcation.  

然而，客户端与业务对象之间的直接交互会导致二者紧密耦合，这种紧密耦合使得客户端直接依赖于业务对象的**实现**。直接依赖意味着客户端必须表示并实现与业务对象查找和创建相关的复杂交互，还必须管理参与业务对象之间的关系，同时理解**事务**划界的职责。

As client requirements increase, the complexity of interaction between various business objects increases. The client grows larger and more complex to fulfill these requirements. The client becomes very susceptible to changes in the business object layer; in addition, the client is unnecessarily exposed to the underlying complexity of the system.  

随着客户端需求的增长，各业务对象间的交互复杂性也随之提升。为满足这些需求，客户端变得愈发庞大且复杂。客户端极易受到业务对象层变更的影响；此外，客户端还会不必要地暴露于系统底层复杂性的风险中。

Tight coupling between objects also results when objects manage their relationship within themselves. Often, it is not clear where the relationship is managed. This leads to complex relationships between business objects and rigidity in the application. Such lack of flexibility makes the application less manageable when changes are required.  

当对象在内部自行管理其关系时，也会导致对象间的紧耦合。通常，这种关系管理的具体位置并不明确，从而造成业务对象间关系复杂化及应用程序的僵化。这种灵活性的缺失使得应用在需要变更时更难以维护。

When accessing the enterprise beans, clients interact with remote objects. Network performance problems may result if the client directly interacts with all the participating business objects. When invoking enterprise beans, every client invocation is potentially a remote method call. Each access to the business object is relatively fine-grained. As the number of participants increases in a scenario, the number of such remote method calls increases. As the number of remote method calls increases, the chattiness between the client and the server-side business objects increases. This may result in network performance degradation for the application, because the high volume of remote method calls increases the amount of interaction across the network layer.  

当访问企业级Bean时，客户端是与远程对象进行交互的。若客户端直接与所有参与的业务对象交互，可能导致网络性能问题。调用企业级Bean时，每次客户端调用本质上都是远程方法调用。对业务对象的每次访问粒度相对较细。随着场景中参与对象数量的增加，此类远程方法调用的次数也随之上升。远程方法调用次数的增长会导致客户端与服务器端业务对象间的通信频繁度提高。由于大量的远程方法调用增加了网络层的交互量，这可能造成应用程序的网络性能下降。

A problem also arises when a client interacts directly with the business objects. Since the business objects are directly exposed to the clients, there is no unified strategy for accessing the business objects. Without such a uniform client access strategy, the business objects are exposed to clients and may reduce consistent usage.  

当客户端直接与业务对象交互时也会出现问题。由于业务对象直接暴露给客户端，缺乏统一的访问策略。没有这种统一的客户端访问策略，业务对象会暴露给客户端，可能导致使用方式不一致。

# Forces  

Provide a simpler interface to the clients by hiding all the complex   
interactions between business components.   
Reduce the number of business objects that are exposed to the client across the service layer over the network.   
Hide from the client the underlying interactions and interdependencies between business components. This provides better manageability,   
centralization of interactions (responsibility), greater flexibility, and greater ability to cope with changes.   
Provide a uniform coarse-grained service layer to separate business object implementation from business service abstraction.   
Avoid exposing the underlying business objects directly to the client to keep tight coupling between the two tiers to a minimum.  

通过隐藏业务组件间所有复杂交互，向客户端提供更简洁的接口。  
减少通过网络跨服务层暴露给客户端的业务对象数量。  
对客户端隐藏业务组件间的底层交互与依赖关系，从而获得：  
- 更好的可管理性  
- 交互（职责）的集中化  
- 更高的灵活性  
- 更强的变更应对能力  

提供统一的粗粒度服务层，将业务对象实现与业务服务抽象分离。  
避免直接向客户端暴露底层业务对象，将两层间的紧耦合降至最低。

# Solution  

# Use a session bean as a facade to encapsulate the complexity of interactions between the business objects participating in a workflow. The Session Facade manages the business objects, and provides a uniform coarse-grained service access layer to clients.  

The Session Facade abstracts the underlying business object interactions and provides a service layer that exposes only the required interfaces. Thus, it hides from the client's view the complex interactions between the participants. The Session Facade manages the interactions between the business data and business service objects that participate in the workflow, and it encapsulates the business logic associated with the requirements. Thus, the session bean (representing the Session Facade) manages the relationships between business objects. The session bean also manages the life cycle of these participants by creating, locating (looking up), modifying, and deleting them as required by the workflow. In a complex application, the Session Facade may delegate this lifestyle management to a separate object. For example, to manage the lifestyle of participant session and entity beans, the Session Facade may delegate that work to a Service Locator object (see “Service Locator” ).  

会话门面模式（Session Facade）对底层业务对象交互进行抽象，仅暴露必要的**接口**作为服务层。该模式向客户端隐藏了参与者之间的复杂交互细节，负责管理业务流程中业务数据与业务服务对象间的协作，并封装与需求相关的业务逻辑。因此，代表会话门面的**会话Bean**（Session Bean）实际承担着业务对象间关系的协调职责。  

该会话Bean还负责管理参与者的生命周期，包括根据业务流程需求进行创建、查找（lookup）、修改和删除操作。在复杂应用中，会话门面可能将生命周期管理工作委派给独立对象。例如，为管理参与者会话和实体Bean的生命周期，会话门面可将其委托给**服务定位器对象**（Service Locator）处理（参见“服务定位器”章节）。

It is important to examine the relationship between business objects. Some relationships between business objects are transient, which means that the relationship is applicable to only that interaction or scenario. Other relationships may be more permanent. Transient relationships are best modeled as workflow in a facade, where the facade manages the relationships between the business objects. Permanent relationships between two business objects should be studied to determine which business object (if not both objects) maintains the relationship.  

必须深入分析业务对象间的关联关系。业务对象间的某些关联具有**瞬时性**，这意味着该关系仅适用于特定交互或场景；而其他关联则可能具有**持久性**。瞬时性关联最适合通过门面模式中的工作流进行建模——由门面统一管理业务对象间的交互关系。对于两个业务对象间的持久性关联，则需要研究确定由哪个业务对象（或双方共同）来维护这种关系。

# Use Cases and Session Facades  

So, how do you identify the Session Facades through studying use cases? Mapping every use case to a Session Facade will result in too many Session Facades. This defeats the intention of having fewer coarse-grained session beans. Instead, as you derive the Session Facades during your modeling, look to consolidate them into fewer numbers of session beans based on some logical partitioning.  

那么，如何通过分析用例来识别会话门面？将每个用例直接映射到会话门面会导致门面数量激增，这与采用粗粒度会话Bean以减少数量的初衷背道而驰。正确的做法是：在建模过程中推导会话门面时，应根据逻辑划分将其整合为数量更少的会话Bean。

For example, for a banking application, you may group the interactions related to managing an account into a single facade. The use cases Create New Account, Change Account Information, View Account information, and so on all deal with the coarse-grained entity object Account. Creating a session bean facade for each use case is not recommended. Thus, the functions required to support these related use cases could be grouped into a single Session Facade called   
AccountSessionFacade.  

例如，在银行应用中，可将管理账户的相关交互操作归集到单一门面中。诸如"创建新账户"、"修改账户信息"、"查看账户信息"等用例都涉及粗粒度的实体对象Account。不建议为每个用例单独创建会话Bean门面，因此可将支持这些相关用例的功能整合到名为AccountSessionFacade的单一会话门面中。

In this case, the Session Facade will become a highly coarse-grained controller with high-level methods that can facilitate each interaction (that is, createNewAccount, changeAccount, getAccount). Therefore, we recommend that you design Session Facades to aggregate a group of the related interactions into a single Session Facade. This results in fewer Session Facades for the application, and leverages the benefits of the Session Facade pattern.  

在此场景下，Session Facade将演变为一个高度粗粒度的控制器，其高层级方法（如`createNewAccount`、`changeAccount`、`getAccount`）可简化每个交互过程。因此，我们建议将一组相关交互聚合到单个Session Facade中进行设计。这种方式能减少应用中Session Facade的数量，并充分发挥Session Facade模式的优势。

# Structure  

Figure 8.15 shows the class diagram representing the Session Facade pattern.  

图8.15展示了表示**会话门面模式**的类图。

![](images/4d045511f51e06653fa6d12ada48d5ae39316219849a1c6cabfa68ebbd93b978.jpg)  
Figure 8.15. Session Facade class diagram  

图 8.15. 会话门面类图

# Participants and Collaborations  

Figure 8.16 contains the sequence diagram that shows the interactions of a Session Facade with two entity beans, one session bean, and a DAO, all acting as participants in fulfilling the request from the client.  

图8.16展示了会话门面模式与两个实体Bean、一个会话Bean及一个DAO交互的顺序图，这些组件共同协作以完成来自客户端的请求。

![](images/f5af92485353f5b70aee2f258a3739d2de2f225e92aa47ae4e01e96440703f23.jpg)  
Figure 8.16. Session Facade sequence diagram  

图 8.16 会话门面模式时序图

# Client  

This represents the client of the Session Facade, which needs access to the business service. This client can be another session bean (Session Facade) in the same business tier or a business delegate (see “Business Delegate”) in another tier  

这表示会话门面的客户端，需要访问业务服务。该客户端可以是同一业务层中的另一个会话Bean（会话门面），也可以是其他层中的业务委托（参见“业务委托”）。

# SessionFacade  

The SessionFacade is implemented as a session bean. The SessionFacade manages the relationships between numerous BusinessObjects and provides a higher level abstraction to the client. The SessionFacade offers coarse-grained access to the participating BusinessObject represented by the Invoke invocation to the session bean.  

`SessionFacade`以会话Bean的形式实现。该`SessionFacade`负责管理多个`BusinessObject`之间的关联关系，并为客户端提供更高层次的抽象。通过向会话Bean发起`Invoke`调用，`SessionFacade`以粗粒度方式访问所参与的`BusinessObject`。

# BusinessObject  

The BusinessObject is a role object that facilitates applying different strategies, such as session beans entity beans and a DAO (see the next section, “Strategies”). A BusinessObject provides data and/or some service in the class diagram. The SessionFacade interacts with multiple BusinessObject instances to provide the service.  

`BusinessObject`是一种角色对象，用于支持应用不同策略（如会话Bean、实体Bean和DAO，参见下一节“策略”）。在类图中，`BusinessObject`提供数据和/或某些服务。`SessionFacade`通过与多个`BusinessObject`实例交互来提供服务。

# Strategies  

The Session Facade is a business-tier controller object that controls the interactions between the client and the participant business data and business service objects. In a complex application, there may be numerous Session Facades that can intermediate between the client and these objects. You can identify where a Session Facade might be useful by studying the client requirements and interactions typically documented in use cases and scenarios. This analysis enables you to identify a controller layer—composed of Session Facades—that can act as facades for these scenarios.  

会话门面（Session Facade）是一种业务层控制器对象，用于管控客户端与业务数据参与者及业务服务对象之间的交互。在复杂应用中，可能存在多个会话门面作为客户端与这些对象之间的中介。通过分析用例和场景文档中记录的客户端需求与交互模式，可识别出需要引入会话门面的场景。这种分析能帮助您确立由会话门面构成的控制器层，该层可作为这些场景的统一门面。

This section explains different strategies for implementing a Session Facade.  

本节阐述实现会话门面模式的不同策略。

# Session Facade Strategies  

# Stateless Session Facade Strategy  

When implementing the Session Facade, you must first decide whether the facade session bean is a stateful or a stateless session bean. Base this decision on the business process that the Session Facade is modeling.  

在实现会话门面模式时，首先需要确定该门面会话Bean是**有状态**还是**无状态**会话Bean。这一决策应基于会话门面所建模的业务流程。

A business process that needs only one method call to complete the service is a nonconversational business process. Such processes are suitably implemented using a stateless session bean.  

仅需单次方法调用即可完成服务的业务流程属于**非会话型业务流程**。此类流程适合采用**无状态会话Bean**实现。

A careful study of the use cases and scenarios enables you to determine the Session Facade definitions. If the use case is nonconversational, then the client initiates the use case, using a single method in the Session Facade. When the method completes, the use case completes too. There is no need to save the conversational state between one method invocation and the next. In this scenario, the Session Facade can be implemented as a stateless session bean.  

通过仔细研究用例和场景，可以确定会话门面（Session Facade）的定义。若用例属于非会话型，则客户端通过调用会话门面中的单一方法来启动用例。当该方法执行完毕时，用例也随之完成。在此种场景下，无需在多次方法调用之间保存会话状态，因此会话门面可采用**无状态会话Bean**（stateless session bean）实现。

# Stateful Session Facade Strategy  

A business process that needs multiple method calls to complete the service is a conversational business process. The conversational state must be saved between each client method invocation. In this scenario, a stateful session bean may be a more suitable approach for implementing the Session Facade.  

需要多次方法调用才能完成服务的业务流程属于**会话式业务流程**。每次客户端方法调用之间必须保存会话状态。在此场景中，采用**有状态会话Bean**可能是实现**会话门面模式**的更合适方案。

In both the Stateless Session Facade and the Stateful Session Facade strategies, the business object's role can be fulfilled in different ways, as explained next.  

在无状态会话门面（Stateless Session Facade）和有状态会话门面（Stateful Session Facade）策略中，业务对象的角色可通过不同方式实现，具体说明如下。

# Business Objects Strategies  

You can implement a business object as a session bean, entity bean, DAO, or regular Java object. The following strategies discuss each of these choices.  

可将业务对象实现为会话Bean、实体Bean、DAO或常规Java对象。以下策略将逐一探讨这些实现方案。

# Session Bean Strategy  

The business object can be implemented as a session bean. The session bean typically provides a business service and, in some cases, it may also provide business data. When such a session bean needs access to data, it may use a DAO to manipulate the data. The Session Facade can wrap one or more such service-oriented or data-oriented session beans acting as business objects.  

业务对象可实现为会话Bean。会话Bean通常提供业务服务，某些情况下也可提供业务数据。当此类会话Bean需要访问数据时，可通过DAO操作数据。会话门面模式可封装一个或多个此类面向服务或面向数据的会话Bean，使其作为业务对象运作。

# Entity Bean Strategy  

Representing the business object by an entity bean is the most common use of the Session Facade. When multiple entity beans participate in the use case, it is not necessary to expose all the entity beans to the clients. Instead, the Session Facade can wrap these entity beans and provide a coarse-grained method to perform the required business function, thus hiding the complexity of entity bean interactions.  

通过实体Bean表示业务对象是会话门面（Session Facade）最常见的用法。当多个实体Bean参与用例时，无需向客户端暴露所有实体Bean。会话门面可以封装这些实体Bean，并提供粗粒度的方法来执行业务功能，从而隐藏实体Bean交互的复杂性。

# Data Access Object Strategy  

The Session Facade can directly use one or more DAOs to represent the business data. This is done when the application is so simple that it requires no entity beans, or when the application's architecture is based only on session beans and does not use entity beans. Using DAOs inside session beans partially simulates the persistent nature of entity beans.  

会话门面（Session Facade）可直接使用一个或多个DAO来表征业务数据。这种模式适用于以下场景：当应用程序过于简单而无需使用实体Bean时，或当应用架构仅基于会话Bean且不采用实体Bean时。在会话Bean内部使用DAO可在部分场景下模拟实体Bean的持久化特性。

The application might need the services provided by an arbitrary Java object (that is, an object that is not an enterprise bean or a DAO, though a DAO can be viewed as a type of arbitrary Java object). In such cases, the Session Facade accesses this arbitrary Java object to provide the necessary functionality.  

应用程序可能需要由任意Java对象（即非企业级Bean或DAO的对象，尽管DAO可视为一种特殊类型的任意Java对象）提供的服务。在此类场景中，会话门面（Session Facade）会访问该任意Java对象以提供所需功能。

# Consequences  

# Introduces Business-Tier Controller Layer  

Session Facades can represent a control layer between clients and the business tier, as identified through analysis modeling. A Session Facade encompasses the interactions between the client and the business components. In a sophisticated application, you can identify numerous Session Facades that can intermediate between the client and the participating business-tier objects. For simpler applications, one might feel that a Session Facade is not adding much value, as it may act to mostly proxy the client requests to a single business component. However, as applications grow more complex over time, using a Session Facade up front will yield benefit at a later stage.  

会话门面（Session Facade）可作为客户端与业务层之间的控制层，这是通过分析建模所确定的。会话门面封装了客户端与业务组件之间的交互。在复杂的应用程序中，可以定义多个会话门面作为客户端与业务层对象之间的中介。对于简单应用，开发者可能认为会话门面价值有限，因为它可能仅充当将客户端请求代理至单一业务组件的角色。但随着应用复杂度逐步提升，预先采用会话门面模式将在后期阶段显现优势。

# Exposes Uniform Interface  

The underlying interactions between the business components can be very complex. A Session Facade pattern abstracts this complexity and presents the client a simpler interface that is easy to understand and to use. By applying a Session Facade, you can design a service layer that exposes simpler interfaces to the system as a whole. Thus a facade provides a uniform coarse-grained access layer to all types of clients and can protect and hide the underlying participant business components.  

业务组件间的底层交互可能非常复杂。**会话门面模式**（Session Facade）通过抽象这种复杂性，向客户端提供一个更易于理解和使用的简化接口。采用会话门面模式后，可设计出为整个系统暴露简化接口的服务层。因此，门面模式为各类客户端提供了统一的粗粒度访问层，同时能保护和隐藏底层参与的业务组件。

# Reduces Coupling, Increases Manageability  

Using a Session Facade decouples the business objects from the clients, thus reducing tight coupling and the client's dependency on the business objects. It is best to use a Session Facade to manage workflow among business objects, rather than making the business objects aware of each other. A  

使用会话门面模式（Session Facade）能够解耦业务对象与客户端，从而降低紧耦合性以及客户端对业务对象的依赖。最佳实践是通过会话门面来管理业务对象间的工作流，而非让业务对象彼此感知。

business object should only be responsible for its own (data and logic) management. Inter-business object interactions can be abstracted into a workflow in a facade. This provides better manageability, centralization of interactions (responsibility and workflow), greater flexibility, and greater ability to cope with changes.  

业务对象应仅负责其自身（数据与逻辑）的管理。业务对象间的交互可抽象为门面模式中的工作流。这种方式能提供更好的可管理性、交互集中化（职责与工作流）、更高的灵活性，以及更强的应对变更能力。

Separating workflow into a Session Facade eliminates the direct dependency of the client on the participant objects and promotes design flexibility. Although changes to participants may require changes in the Session Facade, centralizing the workflow in the facade makes such changes more manageable. You change only the Session Facade rather than having to change all the clients. Client code is also simpler because it now delegates the workflow responsibility to the Session Facade. The client no longer manages the complex workflow interactions between business objects, nor is the client aware of interdependencies between business objects.  

将工作流分离至会话门面(Session Facade)中，可消除客户端对参与对象的直接依赖，并提升设计灵活性。尽管参与者变更可能需要调整会话门面，但将工作流集中至门面层能使这类变更更易管控。开发者只需修改会话门面，而无需改动所有客户端。客户端代码也因此更简洁——其工作流职责已委托给会话门面。客户端既无需管理业务对象间复杂的工作流交互，也无需感知业务对象间的相互依赖关系。

# Improves Performance, Reduces Fine-Grained Methods  

The Session Facade also impacts performance. The Session Facade reduces network overhead between the client and the server because its use eliminates the direct interaction between the client and the business data and business service objects. Instead, all interactions are routed via the Session Facade in a coarse-grained manner. The Session Facade and its participants are closer to each other, making it more efficient for the facade to manage interactions between the participant objects. All data transfer and method invocations from the facade to the participants are presumably on a relatively high-speed network. The network performance can be further tuned to provide maximum throughput by applying the Value Object pattern for the participant objects where applicable.  

会话门面模式同样会影响性能。该模式通过消除客户端与业务数据及业务服务对象的直接交互，有效降低了客户端与服务器间的网络开销。所有交互均通过会话门面以粗粒度方式进行路由。会话门面与其参与者对象彼此邻近，使得门面能更高效地管理参与者对象间的交互。从门面到参与者的所有数据传输和方法调用都基于相对高速的网络环境。通过适时对参与者对象应用值对象模式，可进一步优化网络性能以实现最大吞吐量。

# Provides Coarse-Grained Access  

A Session Facade is meant to be a highly coarse-grained abstraction of the workflow. Thus, it is not desirable to have one Session Facade per entity bean interaction, which would represent a fine-grained abstraction rather than a coarse-grained one. Analyze the interaction between the client and the application services, using use cases and scenarios to determine the coarseness of the facade. Determine the optimal granularity of the Session Facade for the application by partitioning the application into logical subsystems and providing a Session Facade for each subsystem. However, providing a single facade for the entire system can result in a very large Session Facade whose numerous methods make it inefficient. A single facade may be sufficient for very simple applications that do not warrant subsystems.  

会话门面（Session Facade）应作为工作流的高度粗粒度抽象。因此，为每个实体Bean交互单独设置会话门面并不可取——这会导致细粒度抽象而非粗粒度抽象。应通过用例和场景分析客户端与应用服务的交互，从而确定门面的粗粒度级别。建议将应用程序划分为逻辑子系统，并为每个子系统提供独立的会话门面，以此确定最佳粒度。但若为整个系统提供单一门面，可能导致门面过于庞大，其庞杂的方法集将影响效率。对于无需划分子系统的极简单应用，单一门面可能已足够。

# Centralizes Security Management  

Security policies for the application can be managed at the Session Facade level, since this is the tier presented to the clients. Because of the Session Facade's coarse-grained access, it is easier and more manageable to define security policies at this level rather than at the participating business component level. Business components offer fine-grained control points. It is easier to manage security for Session Facades that provide coarse-grained access, because there are relatively fewer coarse-grained methods to be securely managed.  

应用的**安全策略**可在**会话门面层**进行管理，因为该层是面向客户端的展示层。由于会话门面采用**粗粒度访问**机制，在此层级定义安全策略比在参与的业务组件层级更简单且更易维护。业务组件提供的是**细粒度控制点**。对于提供粗粒度访问的会话门面而言，安全管理更为便捷，因为需要安全管控的粗粒度方法相对较少。  

（注：保留"Session Facade"不翻译为行业通用术语，采用"粗粒度/细粒度"对应"coarse-grained/fine-grained"的技术表述）

# Centralizes Transaction Control  

Because the Session Facade represents the workflow for the use cases, it is more logical to apply transaction management at the Session Facade level. Centralized transaction control has advantages similar to centralized security. The facade offers a central place for managing and defining transaction control in a coarse-grained fashion. It is much more work to do transaction management individually on participant business components, especially since they are more fine-grained than the facade. Also, not using a Session Facade, but rather having the client access the enterprise beans directly, puts the transaction demarcation burden on the client and can produce unwanted results.  

由于Session Facade代表了用例的工作流，在Session Facade层级实施事务管理更为合理。集中式事务控制具有与集中式安全类似的优势。该门面模式为以粗粒度方式管理和定义事务控制提供了中心节点。若在参与业务组件上单独实施事务管理将耗费更多工作量——尤其是这些组件比门面更为细粒度。此外，若不采用Session Facade而让客户端直接访问企业级Bean，会将事务界定负担转嫁给客户端，并可能导致非预期结果。

# Exposes Fewer Remote Interfaces to Clients  

Clients that interact directly with the business data and business service objects cause an increase in chattiness between the client and the server. Increased chattiness may degrade network performance. All access to the business object must be via the higher level of abstraction represented by a facade. Since the facade presents a coarse-grained access mechanism to the business components, this reduces the number of business components that are exposed to the client. Thereby, the scope for application performance degradation is reduced due to the limited number of interactions between the clients and the Session Facade when compared to direct interaction by the client to the individual business components.  

直接与业务数据及业务服务对象交互的客户端会导致客户端与服务器之间的通信频次增加。过高的通信频次可能降低网络性能。所有对业务对象的访问必须通过**门面模式**所代表的高层抽象接口进行。由于门面模式为业务组件提供了粗粒度的访问机制，这减少了暴露给客户端的业务组件数量。相较于客户端直接与各个业务组件交互，通过**会话门面**进行有限次数的交互，从而缩小了应用性能下降的可能性范围。

# Sample Code  

# Implementing the Session Facade  

Consider a Professional Services Application (PSA), where the workflow related to entity beans (such as Project, Resource) is encapsulated in ProjectResourceManagerSession, implemented using the Session Facade pattern. Example 8.15 shows the interaction with Resource and Project entity beans, as well as other business components, like Value List Handlers (see “Value List Handler”) and Value Object Assemblers (see “Value Object Assembler” ).  

考虑一个专业服务应用（PSA），其中与实体Bean（如Project、Resource）相关的工作流被封装在ProjectResourceManagerSession中，采用**会话门面模式**实现。示例8.15展示了与Resource和Project实体Bean的交互，以及其他业务组件（如**值列表处理器**（参见“值列表处理器”）和**值对象组装器**（参见“值对象组装器”））的协作。

# Example 8.15 Implementing Session Facade – Session Bean  

package corepatterns.apps.psa.ejb;  

package corepatterns.apps.psa.ejb;

import java.util.\*;   
import java.rmi.RemoteException;   
import javax.ejb.\*;   
import javax.naming.\*;   
import corepatterns.apps.psa.core.\*;   
import corepatterns.util.ServiceLocator;   
import corepatterns.util.ServiceLocatorException;  

import java.util.\*;   
import java.rmi.RemoteException;   
import javax.ejb.\*;   
import javax.naming.\*;   
import corepatterns.apps.psa.core.\*;   
import corepatterns.util.ServiceLocator;   
import corepatterns.util.ServiceLocatorException;

/ Note: all try/catch details not shown for brevity.  

/ 注：为简洁起见，所有try/catch细节未予展示。

public class ProjectResourceManagerSession implements SessionBean {  

public class ProjectResourceManagerSession implements SessionBean {

private SessionContext context;  

private SessionContext context;

// Remote references for the // entity Beans encapsulated by this facade private Resource resourceEntity $=$ null; private Project projectEntity $=$ null;  

// 该门面封装实体Bean的远程引用  
private Resource resourceEntity = null;  
private Project projectEntity = null;

// default create public void ejbCreate() throws CreateException }  

// 默认创建 public void ejbCreate() throws CreateException }

// create method to create this facade and to   
// establish connections to the required entity   
// beans   
// using primary key values   
public void ejbCreate( String resourceId, String projectId, ...)   
throws CreateException, ResourceException {  

// 创建方法以构建该门面，并  
// 通过主键值建立与所需实体  
// Bean的连接  
public void ejbCreate( String resourceId, String projectId, ...)   
throws CreateException, ResourceException {

try  

尝试

// locate and connect to entity beans connectToEntities(resourceId, projectId, ...); } catch(...) { // Handle exceptions   
// method to connect the session facade to its   
// entity beans using the primary key values   
private void connectToEntities ( String resourceId, String projectId)   
throws ResourceException { resourceEntity $=$ getResourceEntity(resourceId); projectEntity $=$ getProjectEntity(projectId);   
}   
// method to reconnect the session facade to a   
// different set of entity beans using primary key   
// values   
public resetEntities(String resourceId, String projectId, ...)   
throws PSAException { connectToEntities(resourceId, projectId, ...);   
}   
// private method to get Home for Resource   
private ResourceHome getResourceHome()   
throws ServiceLocatorException { return ServiceLocator.getInstance().getHome( "ResourceEntity", ResourceHome.class);   
// private method to get Home for Project   
private ProjectHome getProjectHome()   
throws ServiceLocatorException { return ServiceLocator.getInstance().getHome( "ProjectEntity", ProjectHome.class);   
// private method to get Resource entity   
private Resource getResourceEntity( String resourceId) throws ResourceException { try { ResourceHome home $=$ getResourceHome(); return (Resource) home.findByPrimaryKey(resourceId); } catch(...) { // Handle exceptions   
// private method to get Project entity   
private Project getProjectEntity(String projectId)   
throws ProjectException { // similar to getResourceEntity   
// Method to encapsulate workflow related   
// to assigning a resource to a project.   
// It deals with Project and Resource Entity beans   
public void assignResourceToProject(int numHours)   
throws PSAException { try { if ((projectEntity $==$ null) || (resourceEntity $==$ null)) { // SessionFacade not connected to entities throw new PSAException(...); } // Get Resource data ResourceVO resourceVO $=$ resourceEntity.getResourceData(); // Get Project data ProjectVO projectVO $=$ projectEntity.getProjectData(); // first add Resource to Project projectEntity.addResource(resourceVO); // Create a new Commitment for the Project CommitmentVO commitment $=$ new CommitmentVO(...); // add the commitment to the Resource projectEntity.addCommitment(commitment);  

// 定位并连接实体Bean  
connectToEntities(resourceId, projectId, ...); } catch(...) { // 处理异常  
// 通过主键值将会话门面连接到其实体Bean的方法  
private void connectToEntities ( String resourceId, String projectId)   
throws ResourceException { resourceEntity $=$ getResourceEntity(resourceId); projectEntity $=$ getProjectEntity(projectId);   
}  
// 通过主键值重新将会话门面连接到另一组实体Bean的方法  
public resetEntities(String resourceId, String projectId, ...)   
throws PSAException { connectToEntities(resourceId, projectId, ...);   
}  
// 获取Resource Home的私有方法  
private ResourceHome getResourceHome()   
throws ServiceLocatorException { return ServiceLocator.getInstance().getHome( "ResourceEntity", ResourceHome.class);  
// 获取Project Home的私有方法  
private ProjectHome getProjectHome()   
throws ServiceLocatorException { return ServiceLocator.getInstance().getHome( "ProjectEntity", ProjectHome.class);  
// 获取Resource实体的私有方法  
private Resource getResourceEntity( String resourceId) throws ResourceException { try { ResourceHome home $=$ getResourceHome(); return (Resource) home.findByPrimaryKey(resourceId); } catch(...) { // 处理异常  
// 获取Project实体的私有方法  
private Project getProjectEntity(String projectId)   
throws ProjectException { // 类似于getResourceEntity  
// 封装资源分配到项目相关工作流的方法  
// 该方法处理Project和Resource实体Bean  
public void assignResourceToProject(int numHours)   
throws PSAException { try { if ((projectEntity $==$ null) || (resourceEntity $==$ null)) { // SessionFacade未连接到实体 throw new PSAException(...); } // 获取Resource数据 ResourceVO resourceVO $=$ resourceEntity.getResourceData(); // 获取Project数据 ProjectVO projectVO $=$ projectEntity.getProjectData(); // 首先将Resource添加到Project projectEntity.addResource(resourceVO); // 为Project创建新的Commitment CommitmentVO commitment $=$ new CommitmentVO(...); // 将commitment添加到Resource projectEntity.addCommitment(commitment);

} catch(...) { // Handle exceptions // Similarly implement other business methods to // facilitate various use cases/interactions public void unassignResourceFromProject() throws PSAException { // Methods working with ResourceEntity public ResourceVO getResourceData() throws ResourceException { // Update Resource Entity Bean public void setResourceData(ResourceVO resource) throws ResourceException { // Create new Resource Entity bean public ResourceVO createNewResource(ResourceVO resource) throws ResourceException { // Methods for managing resource's blockout time public void addBlockoutTime(Collection blockoutTime) throws RemoteException,BlockoutTimeException { public void updateBlockoutTime( Collection blockoutTime) throws RemoteException, BlockoutTimeException { public Collection getResourceCommitments() throws RemoteException, ResourceException {  

} catch(...) { // 异常处理 // 类似地实现其他业务方法以 // 支持各种用例/交互场景  
public void unassignResourceFromProject() throws PSAException { // 操作ResourceEntity的方法  
public ResourceVO getResourceData() throws ResourceException { // 更新Resource Entity Bean  
public void setResourceData(ResourceVO resource) throws ResourceException { // 创建新Resource Entity bean  
public ResourceVO createNewResource(ResourceVO resource) throws ResourceException { // 管理资源封锁时间的方法  
public void addBlockoutTime(Collection blockoutTime) throws RemoteException,BlockoutTimeException {  
public void updateBlockoutTime( Collection blockoutTime) throws RemoteException, BlockoutTimeException {  
public Collection getResourceCommitments() throws RemoteException, ResourceException {

// Methods working with ProjectEntity   
public ProjectVO getProjectData()   
throws ProjectException { ...   
// Update Project Entity Bean   
public void setProjectData(ProjectVO project)   
throws ProjectException {   
// Create new Project Entity bean   
public ProjectVO createNewProject(ProjectVO project)   
throws ProjectException {   
// Other session facade method examples   
// This proxies a call to a Value Object Assembler   
// to obtain a composite value object.   
// See Value Object Assembler pattern   
public ProjectCVO getProjectDetailsData()   
throws PSAException { try { ProjectVOAHome projectVOAHome $=$ (ProjectVOAHome) ServiceLocator.getInstance().getHome( "ProjectVOA", ProjectVOAHome.class); // Value Object Assembler session bean ProjectVOA projectVOA $=$ projectVOAHome.create(...); return projectVOA.getData(...); } catch (...) { // Handle / throw exceptions }   
// These method proxies a call to a ValueListHandler   
// to get a list of projects. See Value List Handler   
// pattern.   
public Collection getProjectsList(Date start,   
Date end) throws PSAException { try { ProjectListHandlerHome projectVLHHome $=$ (ProjectVLHHome) ServiceLocator.getInstance().getHome( "ProjectListHandler", ProjectVLHHome.class); // Value List Handler session bean ProjectListHandler projectListHandler $=$ projectVLHHome.create(); return projectListHandler.getProjects( start, end); } catch (...) { // Handle / throw exceptions   
public void ejbActivate() {   
public void ejbPassivate() { context $=$ null;   
public void setSessionContext(SessionContext ctx) this.context $=$ ctx;   
public void ejbRemove() {  

// 处理ProjectEntity的方法  
public ProjectVO getProjectData()   
throws ProjectException { ...   
// 更新Project Entity Bean  
public void setProjectData(ProjectVO project)   
throws ProjectException {   
// 创建新的Project Entity bean  
public ProjectVO createNewProject(ProjectVO project)   
throws ProjectException {   
// 其他会话门面方法示例  
// 该方法代理对值对象组装器的调用  
// 以获取组合值对象  
// 参见值对象组装器模式  
public ProjectCVO getProjectDetailsData()   
throws PSAException { try { ProjectVOAHome projectVOAHome $=$ (ProjectVOAHome) ServiceLocator.getInstance().getHome( "ProjectVOA", ProjectVOAHome.class); // 值对象组装器会话bean ProjectVOA projectVOA $=$ projectVOAHome.create(...); return projectVOA.getData(...); } catch (...) { // 处理/抛出异常 }   
// 该方法代理对值列表处理器的调用  
// 以获取项目列表。参见值列表处理器  
// 模式  
public Collection getProjectsList(Date start,   
Date end) throws PSAException { try { ProjectListHandlerHome projectVLHHome $=$ (ProjectVLHHome) ServiceLocator.getInstance().getHome( "ProjectListHandler", ProjectVLHHome.class); // 值列表处理器会话bean ProjectListHandler projectListHandler $=$ projectVLHHome.create(); return projectListHandler.getProjects( start, end); } catch (...) { // 处理/抛出异常   
public void ejbActivate() {   
public void ejbPassivate() { context $=$ null;   
public void setSessionContext(SessionContext ctx) this.context $=$ ctx;   
public void ejbRemove() {

The remote interface for the Session Facade is listed in Example 8.16.  

会话门面的远程接口如示例8.16所示。

# Example 8.16 Implementing Session Facade - Remote Interface  

package corepatterns.apps.psa.ejb;  

package corepatterns.apps.psa.ejb;

mport java.rmi.RemoteException;   
mport javax.ejb.\*;   
mport corepatterns.apps.psa.core.\*;   
// Note: all try/catch details not shown for brevity. public interface ProjectResourceManager   
extends EJBObject {   
public resetEntities(String resourceId,   
String projectId, ...)   
throws RemoteException, ResourceException ;   
public void assignResourceToProject(int numHours)   
throws RemoteException, ResourceException ;   
public void unassignResourceFromProject()   
throws RemoteException, ResourceException ;   
public ResourceVO getResourceData()   
throws RemoteException, ResourceException ;   
public void setResourceData(ResourceVO resource)   
throws RemoteException, ResourceException ;   
public ResourceVO createNewResource(ResourceVO   
resource)   
throws ResourceException ;   
public void addBlockoutTime(Collection blockoutTime) throws RemoteException,BlockoutTimeException ;   
public void updateBlockoutTime(Collection blockoutTime) throws RemoteException,BlockoutTimeException ;   
public Collection getResourceCommitments()   
throws RemoteException, ResourceException;   
public ProjectVO getProjectData()   
throws RemoteException, ProjectException ;   
public void setProjectData(ProjectVO project)  

import java.rmi.RemoteException;  
import javax.ejb.*;  
import corepatterns.apps.psa.core.*;  
// 注意：为简洁起见，省略所有try/catch细节  
public interface ProjectResourceManager  
extends EJBObject {  
public resetEntities(String resourceId,  
String projectId, ...)  
throws RemoteException, ResourceException ;  
public void assignResourceToProject(int numHours)  
throws RemoteException, ResourceException ;  
public void unassignResourceFromProject()  
throws RemoteException, ResourceException ;  
public ResourceVO getResourceData()  
throws RemoteException, ResourceException ;  
public void setResourceData(ResourceVO resource)  
throws RemoteException, ResourceException ;  
public ResourceVO createNewResource(ResourceVO  
resource)  
throws ResourceException ;  
public void addBlockoutTime(Collection blockoutTime) throws RemoteException,BlockoutTimeException ;  
public void updateBlockoutTime(Collection blockoutTime) throws RemoteException,BlockoutTimeException ;  
public Collection getResourceCommitments()  
throws RemoteException, ResourceException;  
public ProjectVO getProjectData()  
throws RemoteException, ProjectException ;  
public void setProjectData(ProjectVO project)

throws RemoteException, ProjectException ; public ProjectVO createNewProject(ProjectVO project) throws RemoteException, ProjectException ; public ProjectCVO getProjectDetailsData() throws RemoteException, PSAException ; public Collection getProjectsList(Date start, Date end) throws RemoteException, PSAException ;  

throws RemoteException, ProjectException ;  
public ProjectVO createNewProject(ProjectVO project) throws RemoteException, ProjectException ;  
public ProjectCVO getProjectDetailsData() throws RemoteException, PSAException ;  
public Collection getProjectsList(Date start, Date end) throws RemoteException, PSAException ;  

中文翻译：  
throws RemoteException, ProjectException ;  
public ProjectVO createNewProject(ProjectVO project) throws RemoteException, ProjectException ;  
public ProjectCVO getProjectDetailsData() throws RemoteException, PSAException ;  
public Collection getProjectsList(Date start, Date end) throws RemoteException, PSAException ;

The Home interface for the Session Facade is shown in Example 8.17.  

Session Facade 的 Home 接口如示例 8.17 所示。

# Example 8.17 Implementing Session Facade - Home Interface  

package corepatterns.apps.psa.ejb;   
import javax.ejb.EJBHome;   
import java.rmi.RemoteException;   
import corepatterns.apps.psa.core.ResourceException;   
import javax.ejb.\*;   
public interface ProjectResourceManagerHome   
extends EJBHome { public ProjectResourceManager create() throws RemoteException,CreateException; public ProjectResourceManager create(String resourceId, String projectId, ...) throws RemoteException,CreateException;  

package corepatterns.apps.psa.ejb;  
import javax.ejb.EJBHome;  
import java.rmi.RemoteException;  
import corepatterns.apps.psa.core.ResourceException;  
import javax.ejb.\*;  
public interface ProjectResourceManagerHome  
extends EJBHome {  
    public ProjectResourceManager create() throws RemoteException,CreateException;  
    public ProjectResourceManager create(String resourceId, String projectId, ...) throws RemoteException,CreateException;

# Related Patterns  

# Facade [GoF]  

The Session Facade is based on the Facade Design pattern.  

会话门面（Session Facade）基于门面设计模式实现。

# Data Access Object  

One of the strategies for the business component in the Session Facade pattern is to use the DAO. This can be the case in simpler applications designed using session beans and DAOs instead of entity beans.  

会话门面模式中业务组件的一种策略是使用DAO。在使用会话Bean和DAO而非实体Bean设计的较简单应用中，这种情况很常见。

# Service Locator  

The Session Facade is a coarse-grained object that allows encapsulation of the workflow by managing business data and business service objects interactions. Business data objects can be entity beans or DAOs, and the business service objects can be session beans and other objects that provide service. The Session Facade can use the Service Locator pattern to reduce the code complexity and to exploit the benefits offered by the Service Locator.  

会话门面（Session Facade）是一种粗粒度对象，通过管理业务数据对象与业务服务对象的交互实现工作流封装。业务数据对象可以是实体Bean或DAO，业务服务对象可以是会话Bean及其他提供服务的对象。该模式可结合服务定位器（Service Locator）模式降低代码复杂度，并充分利用服务定位器的优势。

# Business Delegate  

The Session Facade is used by the Business Delegate when the client requests access to business services. The Business Delegate proxies or adapts the client request to a Session Facade that provides the requested service.  

当客户端请求访问业务服务时，业务委托（Business Delegate）会使用会话门面（Session Facade）。业务委托将客户端请求代理或适配至提供所需服务的会话门面。

# Broker [POSA1]  

The Session Facade performs the role of a broker to decouple the entity beans from their clients.  

会话门面（Session Facade）扮演代理角色，将实体Bean与其客户端解耦。

# Composite Entity  

# Context  

Entity beans are not intended to represent every persistent object in the object model. Entity beans are better suited for coarse-grained persistent business objects.  

实体Bean并不用于表示对象模型中的每个持久化对象，它更适用于表示粗粒度的持久化业务对象。

# Problem  

In a J2EE application, clients (applications, JSPs, servlets, JavaBeans) access entity beans via their remote interfaces. Thus, every client invocation potentially routes through network stubs and skeletons, even if the client and the enterprise bean are in the same JVM, OS, or machine. When entity beans are fine-grained objects,  

在J2EE应用中，客户端（应用程序、JSP、Servlet、JavaBean）通过远程接口访问实体Bean。因此，每次客户端调用都可能经过网络存根和骨架，即使客户端与企业Bean位于同一JVM、操作系统或物理机中。当实体Bean是细粒度对象时，

clients tend to invoke more individual entity bean methods, resulting in high network overhead.  

客户端倾向于调用更多独立的实体Bean方法，从而导致较高的网络开销。

Entity beans represent distributed persistent business objects. Whether developing or migrating an application to the J2EE platform, object granularity is very important when deciding what to implement as an entity bean. Entity beans should represent coarse-grained business objects, such as those that provide complex behavior beyond simply getting and setting field values. These coarse-grained objects typically have dependent objects. A dependent object is an object that has no real domain meaning when not associated with its coarse-grained parent.  

实体Bean代表分布式的持久化业务对象。无论是开发新应用还是将现有应用迁移至J2EE平台，在决定将哪些对象实现为实体Bean时，对象粒度都至关重要。实体Bean应当表示粗粒度的业务对象，即那些除了简单获取和设置字段值之外还能提供复杂行为的对象。这类粗粒度对象通常包含依赖对象——依赖对象是指当脱离其粗粒度父对象时便失去实际领域意义的对象。

A recurring problem is the direct mapping of the object model to an EJB model (specifically entity beans). This creates a relationship between the entity bean objects without consideration of coarse-grained versus fine-grained (or dependent) objects. Determining what to make coarse-grained versus fine-grained is typically difficult and can best be done via modeling relationships in Unified Modeling Language (UML) models.  

一个反复出现的问题是将对象模型直接映射到EJB模型（特别是实体Bean）。这会在实体Bean对象之间建立关联，却未考虑粗粒度与细粒度（或依赖）对象的区别。通常难以确定哪些应设计为粗粒度或细粒度对象，最佳实践是通过在统一建模语言（UML）模型中建立关系来进行建模。

There are a number of areas impacted by the fine-grained entity bean design approach:  

细粒度实体Bean设计方法会影响以下多个方面：

Entity Relationships—  Directly mapping an object model to an EJB model does not take into account the impact of relationships between the objects. The inter-object relationships are directly transformed into inter-entity bean relationships. As a result, an entity bean might contain or hold a remote reference to another entity bean. However, maintaining remote references to distributed objects involves different techniques and semantics than maintaining references to local objects. Besides increasing the complexity of the code, it reduces flexibility, because the entity bean must change if there are any changes in its relationships.  

实体关系——直接将对象模型映射到EJB模型时，并未考虑对象间关系的影响。对象间关系被直接转换为实体Bean间的关系。这导致一个实体Bean可能包含或持有对另一个实体Bean的远程引用。然而，维护对分布式对象的远程引用与维护对本地对象的引用在技术和语义上存在显著差异。除了增加代码复杂度外，这种做法还会降低灵活性，因为一旦实体关系发生变更，实体Bean就必须随之修改。

Also, there is no guarantee as to the validity of the entity bean references to other entity beans over time. Such references are established dynamically using the entity's home object and the primary key for that entity bean instance. This implies a high maintenance overhead of reference validity checking for each such entity-bean-to-entity-bean reference.  

此外，无法保证实体Bean对其他实体Bean的引用随时间推移仍然有效。这类引用是通过实体的Home对象及该实体Bean实例的主键动态建立的。这意味着每个实体Bean到实体Bean的引用都需要进行高维护开销的有效性检查。

Manageability—  Implementing fine-grained objects as entity beans results in a large number of entity beans in the system. An entity bean is defined using several classes. For each entity bean component, the developer must provide classes for the home interface, the remote interface, the bean implementation, and the primary key.  

可管理性——将细粒度对象实现为实体Bean会导致系统中存在大量实体Bean。每个实体Bean需通过多个类定义：开发者必须为每个实体Bean组件提供**Home接口**、**远程接口**、**Bean实现类**以及**主键类**。

In addition, the container may generate classes to support the entity bean implementation. When the bean is created, these classes are realized as real objects in the container. In short, the container creates a number of objects to support each entity bean instance. Large numbers of entity beans result in more classes and code to maintain for the development team. It also results in a large number of objects in the container. This can negatively impact the application performance.  

此外，容器可能生成用于支持实体Bean实现的类。当Bean被创建时，这些类会在容器中实例化为真实对象。简而言之，容器会为每个实体Bean实例创建多个支持对象。大量的实体Bean会导致开发团队需要维护更多的类和代码，同时也会在容器中产生大量对象，这可能对应用程序性能产生负面影响。

Network Performance—  Fine-grained entity beans potentially have more inter-entity bean relationships. Entity beans are distributed objects. When one entity bean invokes a method on another entity bean, the call is potentially treated as a remote call by the container, even if both entity beans are in the same container or JVM. If the number of entity-bean-to-entity-bean relationships increases, then this decreases system scalability due to heavy network overhead.  

网络性能——细粒度的实体Bean可能存在更多的实体Bean间关联关系。实体Bean属于分布式对象，当一个实体Bean调用另一个实体Bean的方法时，容器可能将该调用视为远程调用——即使这两个实体Bean位于同一个容器或JVM中。若实体Bean间的关联关系数量增加，由于沉重的网络开销，系统可扩展性将随之降低。

• Database Schema Dependency—  When the entity beans are fine-grained, each entity bean instance usually represents a single row in a database. This is not a proper application of the entity bean design, since entity beans are more suitable for coarse-grained components. Fine-grained entity bean implementation typically is a direct representation of the underlying database schema in the entity bean design. When clients use these fine-grained entity beans, they are essentially operating at the row level in the database, since each entity bean is effectively a single row. Because the entity bean directly models a single database row, the clients become dependent on the database schema. When the schema changes, the entity bean definitions must change as well. Further, since the clients are operating at the same granularity, they must observe and react to this change. This schema dependency causes a loss of flexibility and increases the maintenance overhead whenever schema changes are required. Object Granularity (Coarse-Grained versus Fine-Grained)—  Object granularity impacts data transfer between the enterprise bean and the client. In most applications, clients typically need a larger chunk of data than one or two rows from a table. In such a case, implementing each of these fine-grained objects as an entity bean means that the client would have to manage the relationships between all these fine-grained objects. Depending on the data requirements, the client might have to perform many lookups of a number of entity beans to obtain the required information.  

• **数据库模式依赖**——当实体Bean设计为细粒度时，每个实体Bean实例通常对应数据库中的单行记录。这种设计并不符合实体Bean的最佳实践，因为实体Bean更适用于粗粒度组件。细粒度实体Bean的实现往往直接映射底层数据库模式，导致客户端操作这些实体Bean时实际上是在数据库行级别进行操作。由于实体Bean直接模拟单行数据，客户端会与数据库模式形成强耦合。一旦模式发生变更，实体Bean定义必须同步修改，而客户端由于操作粒度相同，也不得不感知并适配这些变更。这种模式依赖会降低系统灵活性，并在模式变更时显著增加维护成本。  

• **对象粒度（粗粒度与细粒度）**——对象粒度直接影响企业Bean与客户端之间的数据传输效率。大多数应用场景中，客户端通常需要获取比单行或多行数据更大的数据块。若将每个细粒度对象都实现为实体Bean，客户端就必须自行管理这些细粒度对象间的关联关系。根据数据需求的不同，客户端可能需要进行多次实体Bean查询才能获取完整信息。

# Forces  

Entity beans are best implemented as coarse-grained objects due to the high overhead associated with each entity bean. Each entity bean is implemented using several objects, such as EJB home object, remote object, bean implementation, and primary key, and each is managed by the container services. Applications that directly map relational database schema to entity beans (where each row in a table is represented by an entity bean instance) tend to have a large number of fine-grained entity beans. It is desirable to keep the entity beans coarse-grained and reduce the number of entity beans in the application.  

由于每个实体Bean的高开销，**实体Bean**最适合实现为**粗粒度对象**。每个实体Bean通过多个对象实现，例如EJB home对象、远程对象、Bean实现类和主键对象，且每个对象均由容器服务管理。若应用直接将关系数据库模式映射到实体Bean（即表中每行数据对应一个实体Bean实例），往往会产生大量细粒度实体Bean。建议保持实体Bean的粗粒度特性，并减少应用中实体Bean的数量。  

（注：严格遵循技术术语一致性，保留"EJB home"、"remote"等专有名词不翻译，采用"粗粒度/细粒度"标准译法，并通过加粗强调关键概念）

Direct mapping of object model to EJB model yields fine-grained entity beans. Fine-grained entity beans usually map to the database schema. This entity-to-database row mapping causes problems related to performance, manageability, security, and transaction handling. Relationships between tables are implemented as relationships between entity beans, which means that entity beans hold references to other entity beans to implement the fine-grained relationships. It is very expensive to manage inter-entity bean relationships, because these relationships must be established dynamically, using the entity home objects and the enterprise beans' primary keys. Clients do not need to know the implementation of the database schema to use and support the entity beans. With fine-grained entity beans, the mapping is usually done so that each entity bean instance maps to a single row in the database. This fine-grained mapping creates a dependency between the client and the underlying database schema, since the clients deal with the fine-grained beans and they are essentially a direct representation of the underlying schema. This results in tight coupling between the database schema and entity beans. A change to the schema causes a corresponding change to the entity bean, and in addition requires a corresponding change to the clients.  

将对象模型直接映射到EJB模型会产生细粒度实体Bean。细粒度实体Bean通常与数据库模式一一对应。这种实体到数据库行的映射会引发性能、可管理性、安全性和事务处理方面的问题。表间关系通过实体Bean之间的关系实现，这意味着实体Bean需持有其他实体Bean的引用以维持细粒度关联。管理实体Bean间关系的代价极高，因为这些关系必须通过实体Home对象和企业Bean的主键动态建立。客户端无需了解数据库模式的实现细节即可使用和支持实体Bean。在细粒度实体Bean中，映射通常采用"一个实体Bean实例对应数据库单行"的方式。这种细粒度映射会在客户端与底层数据库模式之间形成强依赖，因为客户端操作的细粒度Bean本质上就是底层模式的直接体现。这导致数据库模式与实体Bean形成紧耦合——模式变更不仅需要同步修改实体Bean，还必须对客户端进行相应调整。

There is an increase in chattiness of applications due to intercommunication among fine-grained entity beans. Excessive inter-entity bean communication often leads to a performance bottleneck. Every method call to the entity bean is made via the network layer, even if the caller is in the same address space as the called bean (that is, both the client, or caller entity bean, and the called entity bean are in the same container). While some container vendors optimize for this scenario, the developer cannot rely on this optimization in all containers.  

由于细粒度实体Bean之间的相互通信，应用程序的交互频率显著增加。过度的实体Bean间通信往往会导致性能瓶颈。每次对实体Bean的方法调用都需要经过网络层，即使调用者与被调用的Bean位于同一地址空间（即客户端/调用方实体Bean与被调用的实体Bean处于同一容器中）。虽然部分容器厂商会针对此场景进行优化，但开发者不能依赖所有容器都具备这种优化能力。

Additional chattiness can be observed between the client and the entity beans because the client may have to communicate with many fine-grained entity beans to fulfill a requirement. It is desirable to reduce the communication between or among entity beans and to reduce the chattiness between the client and the entity bean layer.  

可以观察到客户端与实体Bean之间存在额外的频繁交互，因为客户端可能需要与多个细粒度实体Bean通信才能满足需求。理想情况下，应当减少实体Bean之间或内部的通信，并降低客户端与实体Bean层之间的交互频度。

# Solution  

Use Composite Entity to model, represent, and manage a set of interrelated persistent objects rather than representing them as individual fine-grained entity beans. A Composite Entity bean represents a graph of objects.  

采用**组合实体模式**对一组相互关联的持久化对象进行建模、表示和管理，而非将其表示为独立的细粒度实体Bean。组合实体Bean代表一个对象关系图。

In order to understand this solution, let us first define what is meant by persistent objects and discuss their relationships.  

要理解此解决方案，我们首先需明确**持久化对象**的定义并探讨其关联关系。

A persistent object is an object that is stored in some type of data store. Multiple clients usually share persistent objects. Persistent objects can be classified into two types: coarse-grained objects and dependent objects.  

持久化对象是指存储在某种数据存储中的对象。多个客户端通常共享持久化对象。持久化对象可分为两类：粗粒度对象和依赖对象。

A coarse-grained object is self-sufficient. It has its own life cycle and manages its relationships to other objects. Each coarse-grained object may reference or contain one or more other objects. The coarse-grained object usually manages the lifestyles of these objects. Hence, these objects are called dependent objects. A dependent object can be a simple self-contained object or may in turn contain other dependent objects.  

粗粒度对象是自给自足的。它拥有自己的生命周期，并管理与其他对象的关系。每个粗粒度对象可能引用或包含一个或多个其他对象。粗粒度对象通常管理这些对象的生命周期，因此这些对象被称为依赖对象。依赖对象可以是一个简单的自包含对象，也可能反过来包含其他依赖对象。

The life cycle of a dependent object is tightly coupled to the life cycle of the coarse-grained object. A client may only indirectly access a dependent object through the coarse-grained object. That is, dependent objects are not directly exposed to clients because their parent (coarse-grained) object manages them. Dependent objects cannot exist by themselves. Instead, they always need to have their coarse-grained (or parent) object to justify their existence.  

依赖对象的生命周期与粗粒度对象的生命周期紧密耦合。客户端只能通过粗粒度对象间接访问依赖对象。也就是说，依赖对象不会直接暴露给客户端，因为它们的父对象（粗粒度对象）负责管理它们。依赖对象无法独立存在，必须依赖其粗粒度对象（或父对象）才能维持存在意义。

Typically, you can view the relationship between a coarse-grained object and its dependent objects as a tree. The coarse-grained object is the root of the tree (the root node). Each dependent object can be a standalone dependent object (a leaf node) that is a child of the coarse-grained object. Or, the dependent object can have parent-child relationships with other dependent objects, in which case it is considered a branch node.  

通常，您可以将粗粒度对象与其依赖对象之间的关系视为一棵树。粗粒度对象是树的根（根节点）。每个依赖对象可以是一个独立的依赖对象（叶节点），作为粗粒度对象的子节点；或者该依赖对象可以与其他依赖对象存在父子关系，此时它被视为分支节点。

A Composite Entity bean can represent a coarse-grained object and all its related dependent objects. Aggregation combines interrelated persistent objects into a single entity bean, thus drastically reducing the number of entity beans required by the application. This leads to a highly coarse-grained entity bean that can better leverage the benefits of entity beans than can fine-grained entity beans.  

组合实体Bean（Composite Entity Bean）能够表示一个粗粒度对象及其所有相关的依赖对象。通过聚合将相互关联的持久化对象整合为单一实体Bean，可显著减少应用程序所需的实体Bean数量。这种方式生成的粗粒度实体Bean能比细粒度实体Bean更充分地发挥实体Bean的优势。

Without the Composite Entity approach, there is a tendency to view each coarse-grained and dependent object as a separate entity bean, leading to a large number of entity beans.  

若不采用组合实体模式，往往会将每个粗粒度依赖对象视为独立的实体Bean，从而导致实体Bean数量激增。

# Structure  

While there are many strategies in implementing the Composite Entity pattern, the first one we discuss is represented by the class diagram in Figure 8.17. Here the Composite Entity contains the coarse-grained object, and the coarse-grained object contains dependent objects.  

在实现组合实体模式的多种策略中，我们首先讨论的是图8.17类图所示的方案。该方案中，组合实体包含粗粒度对象，而粗粒度对象又包含依赖对象。

# Figure 8.17. Composite Entity class diagram  

![](images/3ad6ed55eeaa67d000bd4674c593bfc8e5d3dae2a2f411e94963d98ad7523cf1.jpg)  

The sequence diagram in Figure 8.18 shows the interactions for this pattern.  

图8.18中的序列图展示了该模式的交互过程。

# Figure 8.18. Composite Entity sequence diagram  

![](images/66121badb655353e6a0496f35c6d28dacfc3c4590a35f1e4f17f549f4f5b2ffe.jpg)  

# Participants and Responsibilities  

# CompositeEntity  

CompositeEntity is the coarse-grained entity bean. The CompositeEntity may be the coarse-grained object, or it may hold a reference to the coarse-grained object. The  

CompositeEntity 是粗粒度实体 Bean。CompositeEntity 可以是粗粒度对象，也可以持有对粗粒度对象的引用。

“Strategies” section explains the different implementation strategies for a Composite Entity.  

“策略”章节阐述了组合实体（Composite Entity）的不同实现策略。

# Coarse-Grained Object  

A coarse-grained object is an object that has its own life cycle and manages its own relationships to other objects. A coarse-grained object can be a Java object contained in the Composite Entity. Or, the Composite Entity itself can be the coarse-grained object that holds dependent objects. These strategies are explained in the “Strategies” section.  

粗粒度对象是具有独立生命周期并自主管理与其他对象关系的对象。粗粒度对象可以是包含在复合实体中的Java对象，亦或是复合实体本身作为持有依赖对象的粗粒度对象。这些策略在"策略"章节中有详细阐述。

# DependentObject1, DependentObject2, and DependentObject3  

A dependent object is an object that depends on the coarse-grained object and has its life cycle managed by the coarse-grained object. A dependent object can contain other dependent objects; thus there may be a tree of objects within the Composite Entity.  

依赖对象是指依赖于粗粒度对象并由粗粒度对象管理其生命周期的对象。依赖对象可以包含其他依赖对象，因此在组合实体内部可能形成对象树结构。

# Strategies  

This section explains different strategies for implementing a Composite Entity. The strategies consider possible alternatives and options for persistent objects (coarse-grained and dependent) and the use of value objects.  

本节阐述实现组合实体的不同策略。这些策略考量了持久化对象（粗粒度对象与依赖对象）的可能替代方案与选项，以及值对象的使用方式。

# Composite Entity Contains Coarse-Grained Object Strategy  

In this strategy, the Composite Entity holds or contains the coarse-grained object. The coarse-grained object continues to have relationships with its dependent objects. The structure section of this pattern describes this as the main strategy.  

在该策略中，组合实体持有或包含粗粒度对象。粗粒度对象与其依赖对象之间仍保持关联关系。该模式的结构部分将此描述为核心策略。

# Composite Entity Implements Coarse-Grained Object Strategy  

In this strategy, the Composite Entity itself is the coarse-grained object and it has the coarse-grained object's attributes and methods. The dependent objects are attributes of the Composite Entity. Since the Composite Entity is the coarse-grained  

在该策略中，**组合实体**本身即为粗粒度对象，它具备粗粒度对象的属性和方法。依赖对象作为组合实体的属性存在。由于组合实体属于粗粒度

object, the entity bean expresses and manages all relationships between the coarse-grained object and the dependent objects.  

该实体Bean负责表达并管理粗粒度对象与依赖对象之间的所有关系。

Figure 8.19 is the class diagram for this strategy.  

图8.19是该策略的类图。

Coarse-Grained Object class diagram  

粗粒度对象类图

![](images/4e5cb3ef3ac7e987cdcd60c5b7f99d386c5605a4ad33ffc674e5d303aa77ab98.jpg)  
Figure 8.19. Composite Entity Implements  

图8.19. 组合实体实现

The sequence diagram for this strategy is shown in Figure 8.20.  

该策略的序列图如图8.20所示。

Coarse-Grained Object sequence diagram  

粗粒度对象序列图

![](images/876b56da3ee00d116bff85932b7cd485a485215f624628829367de027998e180.jpg)  
Figure 8.20. Composite Entity Implements  

图 8.20. 组合实体实现

# Lazy Loading Strategy  

A Composite Entity can be composed of many levels of dependent objects in its tree of objects. Loading all the dependent objects when the Composite Entity's ejbLoad() method is called by the EJB Container may take considerable time and resources. One way to optimize this is by using a lazy loading strategy for loading the dependent objects. When the ejbLoad() method is called, at first only load those dependent objects that are most crucial to the Composite Entity clients. Subsequently, when the clients access a dependent object that has not yet been loaded from the database, the Composite Entity can perform a load on demand. Thus, if some dependent objects are not used, they are not loaded on initialization. However, when the clients subsequently need those dependent objects, they get loaded at that time. Once a dependent object is loaded, subsequent container calls to the ejbLoad() method must include those dependent objects for reload to synchronize the changes with the persistent store.  

组合实体（Composite Entity）的对象树中可以包含多层次的依赖对象。当EJB容器调用组合实体的`ejbLoad()`方法时，加载所有依赖对象可能会消耗大量时间和资源。一种优化方案是采用**延迟加载策略**来加载依赖对象：在`ejbLoad()`方法被调用时，优先加载对组合实体客户端最关键的那些依赖对象；随后当客户端访问尚未从数据库加载的依赖对象时，组合实体才执行按需加载。这样未被使用的依赖对象在初始化阶段不会被加载，而当客户端后续需要这些对象时才会实时加载。需要注意的是，一旦某个依赖对象被加载，后续容器调用`ejbLoad()`方法时必须包含这些对象以实现重新加载，从而确保与持久化存储的变更同步。

# Store Optimization (Dirty Marker) Strategy  

A common problem with bean-managed persistence occurs when persisting the complete object graph during an ejbStore() operation. Since the EJB Container has no way of knowing what data has changed in the entity bean and its dependent objects, it puts the burden on the developer to determine what and how to persist the data. Some EJB containers provide a feature to identify what objects in Composite Entity's graph need to be stored due to a prior update. This may be done by having the developers implement a special method in the dependent objects, such as isDirty(), that is called by the container to check if the object has been updated since the previous ejbStore() operation.  

Bean托管持久化的一个常见问题出现在执行`ejbStore()`操作期间持久化完整对象图时。由于EJB容器无法知晓实体Bean及其依赖对象中哪些数据发生了变更，开发者需要自行判断应持久化哪些数据以及如何持久化。部分EJB容器提供了识别复合实体对象图中哪些对象因先前的更新而需要存储的特性。这通常要求开发者在依赖对象中实现特殊方法（例如`isDirty()`），容器通过调用该方法来检查自上次`ejbStore()`操作后该对象是否被更新过。

A generic solution may be to use an interface, DirtyMarker, as shown in the class diagram in Figure 8.21. The idea is to have dependent objects implement the DirtyMarker interface to let the caller (typically the ejbStore() method) know if the state of the dependent object has changed. This way, the caller can choose to obtain the data for subsequent storage.  

一种通用解决方案是使用如图8.21类图所示的`DirtyMarker`接口。其核心思想是让依赖对象实现该接口，从而让调用者（通常是`ejbStore()`方法）能够感知依赖对象的状态变化。通过这种方式，调用方可以自主决定是否获取数据以进行后续存储。

![](images/e9886e2ee2dc36e03a8cfa423eda87c3dc8d2d3998890e9a989bf6df12f84219.jpg)  
Figure 8.21. Store Optimization Strategy class diagram   
Figure 8.22 contains a sequence diagram showing an example interaction for this strategy.  

图8.21 门店优化策略类图  
图8.22展示了该策略的交互时序图示例。

# Figure 8.22. Store Optimization Strategy sequence diagram  

![](images/d0fb96dff7ca5947f8ca07aa21c9349b5025fa571d08743f41c6986afd391330.jpg)  

The client performs an update to the Composite Entity, which results in a change to DependentObject3. DependentObject3 is accessed via its parent DependentObject2. The Composite Entity is the parent of DependentObject2. When this update is performed, the setDirty() method is invoked in the DependentObject3. Subsequently, when the container invokes the ejbStore() method on this Composite Entity instance, the ejbStore() method can check which dependent objects have gone dirty and selectively save those changes to the database. The dirty marks are reset once the store is successful.  

客户端对组合实体执行更新操作，导致`DependentObject3`发生变更。`DependentObject3`通过其父对象`DependentObject2`被访问，而组合实体则是`DependentObject2`的父对象。当执行此更新时，`DependentObject3`中的`setDirty()`方法会被调用。随后，当容器对该组合实体实例调用`ejbStore()`方法时，`ejbStore()`方法可检查哪些依赖对象标记为脏数据，并选择性地将这些变更保存到数据库。存储成功后，脏数据标记将被重置。

The DirtyMarker interface can also include methods that can recognize other the persistence status of the dependent object. For example, if a new dependent object is included into the Composite Entity, the ejbStore() method should be able to recognize what operation to use—in this case, the dependent object is not dirty, but is a new object. By extending the DirtyMarker interface to include a method called isNew(), the ejbStore() method can invoke an insert operation instead of an update operation. Similarly, by including a method called isDeleted(), the ejbStore() method can invoke delete operation as required.  

`DirtyMarker`接口还可包含能识别依赖对象持久化状态的方法。例如，当新依赖对象被纳入组合实体时，`ejbStore()`方法应能识别需执行的操作——此时该依赖对象并非脏数据，而是新对象。通过扩展`DirtyMarker`接口并添加`isNew()`方法，`ejbStore()`方法便可触发插入操作而非更新操作。同理，通过添加`isDeleted()`方法，`ejbStore()`方法即可按需执行删除操作。

In cases where ejbStore() is invoked with no intermediate updates to the Composite Entity, none of the dependent objects have been updated.  

当调用 `ejbStore()` 时若未对组合实体进行中间更新，则所有依赖对象均未被修改。

This strategy avoids the huge overhead of having to persist the entire dependent objects graph to the database whenever the ejbStore() method is invoked by the container.  

该策略避免了在容器每次调用`ejbStore()`方法时，必须将整个依赖对象图持久化到数据库的巨大开销。

# Note  

The EJB 2.0 specification addresses the Lazy Loading strategy and the Store Optimization strategy. The 2.0 specification is in final draft at the time of this writing. However, it is possible to use these strategies in pre-EJB 2.0 implementations. Please follow the EJB 2.0 developments to understand how these strategies will be finalized in the specification.  

EJB 2.0规范涵盖了**延迟加载策略**与**存储优化策略**。截至本文撰写时，该规范尚处于最终草案阶段。但开发者可在EJB 2.0之前的实现中应用这些策略。建议持续关注EJB 2.0的进展，以了解这些策略在规范中的最终形态。

# Composite Value Object Strategy  

With a Composite Entity, a client can obtain all required information with just one remote method call. Because the Composite Entity either implements or holds the coarse-grained object and the hierarchy (or tree) of dependent objects, it can create the required value object and return it to the client by applying the Value Object pattern (see “Value Object”). The sequence diagram for this strategy is shown in Figure 8.23.  

通过**组合实体**模式，客户端仅需一次远程方法调用即可获取所有必需信息。由于该组合实体**实现**或持有粗粒度对象及其依赖对象的层次结构（或树形关系），它能够创建所需的值对象，并运用**值对象模式**（参见“值对象”）将其返回给客户端。该策略的时序图如图8.23所示。

![](images/863fd5c2b4ae65c244aa56892128d7922b1a942b3817cc738ceead3c1579e79e.jpg)  
Figure 8.23. Composite Value Object Strategy sequence diagram  

图 8.23. 组合值对象策略时序图

The value object can be a simple object or a composite object that has subobjects (a graph), depending on the data requested by the client. The value object is serializable and it is passed by value to the client. The value object functions only as a data transfer object; it has no responsibility with respect to security, transaction, and business logic. The value object packages all information into one object, obtaining the information with one remote call rather than multiple remote calls. Once the client receives the value object, all further calls from the client to the value object are local to the client.  

值对象可以是一个简单对象，也可以是由子对象构成的复合对象（图结构），具体取决于客户端请求的数据。值对象是可序列化的，并通过值传递给客户端。值对象仅作为数据传输对象使用，不承担安全、事务和业务逻辑相关的职责。值对象将所有信息封装到一个对象中，通过一次远程调用而非多次调用来获取信息。当客户端接收到值对象后，所有后续对该值对象的调用均在客户端本地执行。

This discussion points to how the entity can package all its data into a composite value object and return it to the client. However, this strategy also allows the entity bean to return only the required data to the client. If the client needs data only from a subset of dependent objects, then the composite value object returned can contain data derived from only those required parts and not from all the dependent objects. This would be an application of the Multiple Value Objects Strategy from the Value Object pattern (see “Value Object”).  

该讨论指出实体如何将其所有数据封装为复合值对象并返回给客户端。然而，这种策略也允许实体Bean仅向客户端返回必需的数据。若客户端仅需从部分依赖对象中获取数据，则返回的复合值对象可仅包含这些必要部分衍生的数据，而非全部依赖对象的数据。这是对值对象模式中"多值对象策略"的应用（参见"值对象"章节）。

# Consequences  

# Eliminates Inter-Entity Relationships  

Using the Composite Entity pattern, the dependent objects are composed into a single entity bean, eliminating all inter-entity-bean relationships. This pattern provides a central place to manage both relationships and object hierarchy.  

通过采用组合实体模式，依赖对象被组合为单个实体Bean，从而消除了所有实体Bean间的关联关系。该模式为管理对象层级和关联关系提供了集中化的控制点。

# Improves Manageability by Reducing Entity Beans  

As discussed, implementing persistent objects as fine-grained entity beans results in a large number of classes that need to be developed and maintained. Using a Composite Entity reduces the number of EJB classes and code, and makes maintenance easier. It improves the manageability of the application by having fewer coarse-grained components instead of many more fine-grained components.  

如前所述，将持久化对象实现为细粒度实体Bean会导致需要开发和维护大量类。采用**组合实体模式**可减少EJB类和代码量，并降低维护难度。该模式通过使用较少的粗粒度组件替代大量细粒度组件，从而提升应用的可管理性。

# Improves Network Performance  

Aggregation of the dependent objects improves overall performance. Aggregation eliminates all fine-grained communications between dependent objects across the network. If each dependent object were designed as a fine-grained entity bean, a huge network overhead would result due to inter-entity bean communications.  

依赖对象的聚合提升了整体性能。聚合消除了网络中依赖对象之间所有的细粒度通信。如果将每个依赖对象设计为细粒度的实体Bean，由于实体Bean间的通信将导致巨大的网络开销。

# Reduces Database Schema Dependency  

When the Composite Entity pattern is used, it results in coarse-grained entity bean implementations. The database schema is hidden from the clients, since the mapping of the entity bean to the schema is internal to the coarse-grained entity bean. Changes to the database schema may require changes to the Composite Entity beans. However, the clients are not affected since the Composite Entity beans do not expose the schema to the external world.  

采用**组合实体模式**时，会产生粗粒度的实体Bean实现。由于实体Bean与数据库模式的映射关系封装在粗粒度实体Bean内部，客户端无法感知底层数据库模式。修改数据库模式可能需要调整组合实体Bean，但由于组合实体Bean不会对外暴露模式细节，客户端代码不会受到影响。

# Increases Object Granularity  

With a Composite Entity, the client typically looks up a single entity bean instead of a large number of fine-grained entity beans. The client requests the Composite Entity for data. The Composite Entity can create a composite value object that contains all the data from the entity bean and return the value object to the client in a single remote method call. This reduces the chattiness between the client and the business tier.  

使用组合实体模式时，客户端通常查找单个实体Bean而非大量细粒度实体Bean。客户端向组合实体请求数据，该组合实体可创建包含实体Bean所有数据的复合值对象，并通过单次远程方法调用将值对象返回给客户端。这有效减少了客户端与业务层之间的频繁交互。

# Facilitates Composite Value Object Creation  

By using this strategy, chattiness of the communication between the client and the entity bean is reduced, since the Composite Entity bean can return a composite value object by providing a mechanism to send serialized value objects from the Composite Entity bean. Although a value object returns all data in one remote call, the amount of data returned with this one call is much larger than the amount of data returned by separate remote calls to obtain individual entity bean properties. This trade-off works well when the goal is to avoid repeated remote calls and multiple lookups.  

采用该策略可显著降低客户端与实体Bean之间的通信频次，因为复合实体Bean能通过序列化值对象传输机制返回复合值对象。虽然值对象在单次远程调用中返回全部数据，但其数据量远大于通过多次独立远程调用获取单个实体Bean属性的总和。这种权衡方案在需要避免重复远程调用和多重查询的场景下尤为有效。

# Overhead of Multi-level Dependent Object Graphs  

If the dependent objects graph managed by the Composite Entity has many levels, then the overhead of loading and storing the dependent objects increases. This can be reduced by using the optimization strategies for load and store, but then there may be an overhead associated with checking the dirty objects to store and loading the required objects.  

若由组合实体管理的依赖对象图层级较深，则加载和存储依赖对象的开销会显著增加。虽然可通过加载/存储优化策略降低开销，但随之可能产生检查待存储脏对象及加载必需对象的相关性能损耗。

# Sample Code  

Consider a Professional Service Automation application (PSA) where a Resource business object is implemented using the Aggregate Entity pattern. The Resource represents the employee resource that is assigned to projects. Each Resource object can have different dependent objects as follows:  

考虑一个专业服务自动化（PSA）应用场景，其中**资源**业务对象采用**聚合实体模式**实现。该资源代表被分配到项目的员工资源。每个Resource对象可包含以下不同类型的依赖对象：

BlockOutTime—  This dependent object represents the time period the Resource is unavailable for reasons such as training, vacation, timeoffs, etc. Since each resource can have multiple blocked out times, the Resource-to-BlockOutTime relationship is a one-to-many relationship. SkillSet—  This dependent object represents the Skill that a Resource possesses. Since each resource can have multiple skills, the Resource-to-SkillSet relationship is a one-to-many relationship.  

**BlockOutTime**——该依赖对象表示资源因培训、休假、调休等原因不可用的时间段。由于每个资源可对应多个不可用时段，资源与BlockOutTime的关系为一对多关系。  

**SkillSet**——该依赖对象表示资源所具备的技能。由于每个资源可拥有多项技能，资源与SkillSet的关系为一对多关系。

# Implementing the Composite Entity Pattern  

The pattern for the Resource business object is implemented as a Composite Entity (ResourceEntity), as shown in Example 8.18. The one-to-many relationship with its dependent objects (BlockOutTime and SkillSet objects) are implemented using collections.  

资源业务对象的模式被实现为组合实体（ResourceEntity），如示例8.18所示。其与依赖对象（BlockOutTime和SkillSet对象）的一对多关系通过集合实现。

# Example 8.18 Entity Implements Coarse--Grained Object  

package corepatterns.apps.psa.ejb;  

package corepatterns.apps.psa.ejb;

import corepatterns.apps.psa.core.\*;   
import corepatterns.apps.psa.dao.\*;   
import java.sql.\*;   
import javax.sql.\*;   
import java.util.\*;   
import javax.ejb.\*;   
import javax.naming.\*;  

import corepatterns.apps.psa.core.\*;   
import corepatterns.apps.psa.dao.\*;   
import java.sql.\*;   
import javax.sql.\*;   
import java.util.\*;   
import javax.ejb.\*;   
import javax.naming.\*;

public class ResourceEntity implements EntityBean { public String employeeId; public String lastName; public String firstName; public String departmentId; public String practiceGroup; public String title; public String grade; public String email; public String phone; public String cell; public String pager; public String managerId;  

public class ResourceEntity implements EntityBean { public String employeeId; public String lastName; public String firstName; public String departmentId; public String practiceGroup; public String title; public String grade; public String email; public String phone; public String cell; public String pager; public String managerId;

// Collection of BlockOutTime Dependent objects public Collection blockoutTimes;  

// 存储BlockOutTime依赖对象的集合  
public Collection blockoutTimes;

// Collection of SkillSet Dependent objects public Collection skillSets;  

// 技能集依赖对象的集合  
public Collection skillSets;

private EntityContext context;   
// Entity Bean methods implementation   
public String ejbCreate(ResourceVO resource) throws CreateException { try { this.employeeId $=$ resource.employeeId; setResourceData(resource); getResourceDAO().create(resource); catch(Exception ex) { throw new EJBException("Reason:" + ...); return this.employeeId;   
public String ejbFindByPrimaryKey(String primaryKe throws FinderException { boolean result; try { ResourceDAO resourceDAO $=$ getResourceDAO(); result $=$ resourceDAO.selectByPrimaryKey(primaryKey); } catch(Exception ex) { throw new EJBException("Reason:" + ...); } if(result) { return primaryKey; } else { throw new ObjectNotFoundException(...);   
public void ejbRemove() { try { // Remove dependent objects if(this.skillSets ! $=$ null) { SkillSetDAO skillSetDAO $=$ getSkillSetDAO(); skillSetDAO.setResourceID(employeeId); skillSetDAO.deleteAll(); skillSets $=$ null; } if(this.blockoutTime ! $!=$ null) { BlockOutTimeDAO blockouttimeDAO $=$ getBlockOutTimeDAO();  

private EntityContext context;  
// Entity Bean 方法实现  
public String ejbCreate(ResourceVO resource) throws CreateException {  
    try {  
        this.employeeId = resource.employeeId;  
        setResourceData(resource);  
        getResourceDAO().create(resource);  
    } catch(Exception ex) {  
        throw new EJBException("Reason:" + ...);  
    }  
    return this.employeeId;  
}  

public String ejbFindByPrimaryKey(String primaryKey) throws FinderException {  
    boolean result;  
    try {  
        ResourceDAO resourceDAO = getResourceDAO();  
        result = resourceDAO.selectByPrimaryKey(primaryKey);  
    } catch(Exception ex) {  
        throw new EJBException("Reason:" + ...);  
    }  
    if(result) {  
        return primaryKey;  
    } else {  
        throw new ObjectNotFoundException(...);  
    }  
}  

public void ejbRemove() {  
    try {  
        // 移除依赖对象  
        if(this.skillSets != null) {  
            SkillSetDAO skillSetDAO = getSkillSetDAO();  
            skillSetDAO.setResourceID(employeeId);  
            skillSetDAO.deleteAll();  
            skillSets = null;  
        }  
        if(this.blockoutTime != null) {  
            BlockOutTimeDAO blockouttimeDAO = getBlockOutTimeDAO();

blockouttimeDAO.setResourceID(employeeId);  

blockouttimeDAO.setResourceID(employeeId);

blockouttimeDAO.deleteAll(); blockOutTimes $=$ null; } // Remove the resource from the persistent store ResourceDAO resourceDAO $=$ new ResourceDAO(employeeId); resourceDAO.delete(); } catch(ResourceException ex) { throw new EJBException("Reason:"+...); } catch(BlockOutTimeException ex) { throw new EJBException("Reason:" $^+$ ...); } catch(Exception exception) {   
}   
public void setEntityContext(EntityContext context) this.context $=$ context;   
}   
public void unsetEntityContext() { context $=$ null;   
public void ejbActivate() { employeeId $=$ (String)context.getPrimaryKey();   
public void ejbPassivate() { employeeId $=$ null;   
public void ejbLoad() { try { // load the resource info from ResourceDAO resourceDAO $=$ getResourceDAO(); setResourceData((ResourceVO) resourceDAO.load(employeeId)); // Load other dependent objects, if necessary } catch(Exception ex) { throw new EJBException("Reason:" + ...); }   
public void ejbStore() { try { // Store resource information getResourceDAO().update(getResourceData()); // Store dependent objects as needed } catch(SkillSetException ex) { throw new EJBException("Reason:" + ...); } catch(BlockOutTimeException ex) { throw new EJBException("Reason:" + ...); }   
public void ejbPostCreate(ResourceVO resource) {   
}   
// Method to Get Resource value object   
public ResourceVO getResourceVO() { // create a new Resource value object ResourceVO resourceVO $=$ new ResourceVO(employeeId); // copy all values resourceVO.lastName $=$ lastName; resourceVO.firstName $=$ firstName; resourceVO.departmentId $=$ departmentId; return resourceVO;   
}   
public void setResourceData(ResourceVO resourceVO) { // copy values from value object into entity bean employeeId $=$ resourceVO.employeeId; lastName $=$ resourceVO.lastName;   
}   
// Method to get dependent value objects   
public Collection getSkillSetsData() { // If skillSets is not loaded, load it first.  

blockouttimeDAO.deleteAll(); blockOutTimes = null; } // 从持久化存储中移除资源 ResourceDAO resourceDAO = new ResourceDAO(employeeId); resourceDAO.delete(); } catch(ResourceException ex) { throw new EJBException("原因:"+...); } catch(BlockOutTimeException ex) { throw new EJBException("原因:"+...); } catch(Exception exception) {   
}   
public void setEntityContext(EntityContext context) this.context = context;   
}   
public void unsetEntityContext() { context = null;   
public void ejbActivate() { employeeId = (String)context.getPrimaryKey();   
public void ejbPassivate() { employeeId = null;   
public void ejbLoad() { try { // 从ResourceDAO加载资源信息 resourceDAO = getResourceDAO(); setResourceData((ResourceVO) resourceDAO.load(employeeId)); // 按需加载其他依赖对象 } catch(Exception ex) { throw new EJBException("原因:" + ...); }   
public void ejbStore() { try { // 存储资源信息 getResourceDAO().update(getResourceData()); // 按需存储依赖对象 } catch(SkillSetException ex) { throw new EJBException("原因:" + ...); } catch(BlockOutTimeException ex) { throw new EJBException("原因:" + ...); }   
public void ejbPostCreate(ResourceVO resource) {   
}   
// 获取资源值对象的方法   
public ResourceVO getResourceVO() { // 创建新的资源值对象 ResourceVO resourceVO = new ResourceVO(employeeId); // 复制所有值 resourceVO.lastName = lastName; resourceVO.firstName = firstName; resourceVO.departmentId = departmentId; return resourceVO;   
}   
public void setResourceData(ResourceVO resourceVO) { // 将值从值对象复制到实体Bean中 employeeId = resourceVO.employeeId; lastName = resourceVO.lastName;   
}   
// 获取依赖值对象的方法   
public Collection getSkillSetsData() { // 如果skillSets未加载，则先加载它。

// See Lazy Load strategy implementation.  

// 参见延迟加载策略的实现。

return skillSets; // other get and set methods as needed  

return skillSets; // 其他根据需要提供的get和set方法

// Entity bean business methods   
public void addBlockOutTimes(Collection moreBOTs)   
throws BlockOutTimeException { // Note: moreBOTs is a collection of // BlockOutTimeVO objects try { Iterator moreIter $=$ moreBOTs.iterator(); while(moreIter.hasNext()) { BlockOutTimeVO botVO $=$ (BlockOutTimeVO) moreIter.next(); if (! (blockOutTimeExists(botVO))) { // add BlockOutTimeVO to collection botVO.setNew(); blockOutTime.add(botVO); } else { // BlockOutTimeVO already exists, cannot add throw new BlockOutTimeException(...); } catch(Exception exception) { throw new EJBException(...);   
public void addSkillSet(Collection moreSkills)   
throws SkillSetException { // similar to addBlockOutTime() implementation   
public void updateBlockOutTime(Collection updBOTs)   
throws BlockOutTimeException { try { Iterator botIter $=$ blockOutTimes.iterator(); Iterator updIter $=$ updBOTs.iterator(); while (updIter.hasNext()) { BlockOutTimeVO botVO $=$ (BlockOutTimeVO) updIter.next(); while (botIter.hasNext()) { BlockOutTimeVO existingBOT $=$ (BlockOutTimeVO) botIter.next(); // compare key values to locate BlockOutTime if (existingBOT.equals(botVO)) { // Found BlockOutTime in collection // replace old BlockOutTimeVO with new one botVO.setDirty(); //modified old dependent botVO.resetNew(); //not a new dependent existingBOT $=$ botVO; catch (Exception exc) { throw new EJBException(...);   
public void updateSkillSet(Collection updSkills)   
throws CommitmentException { // similar to updateBlockOutTime...  

// 实体Bean业务方法  
public void addBlockOutTimes(Collection moreBOTs)   
throws BlockOutTimeException { // 注意：moreBOTs是BlockOutTimeVO对象集合  
try {  
    Iterator moreIter = moreBOTs.iterator();  
    while(moreIter.hasNext()) {  
        BlockOutTimeVO botVO = (BlockOutTimeVO) moreIter.next();  
        if (! (blockOutTimeExists(botVO))) {  
            // 将BlockOutTimeVO添加到集合  
            botVO.setNew();  
            blockOutTime.add(botVO);  
        } else {  
            // BlockOutTimeVO已存在，无法添加  
            throw new BlockOutTimeException(...);  
        }  
    }  
} catch(Exception exception) {  
    throw new EJBException(...);  
}  

public void addSkillSet(Collection moreSkills)   
throws SkillSetException { // 实现逻辑与addBlockOutTime()类似  

public void updateBlockOutTime(Collection updBOTs)   
throws BlockOutTimeException {  
    try {  
        Iterator botIter = blockOutTimes.iterator();  
        Iterator updIter = updBOTs.iterator();  
        while (updIter.hasNext()) {  
            BlockOutTimeVO botVO = (BlockOutTimeVO) updIter.next();  
            while (botIter.hasNext()) {  
                BlockOutTimeVO existingBOT = (BlockOutTimeVO) botIter.next();  
                // 通过键值比较定位BlockOutTime  
                if (existingBOT.equals(botVO)) {  
                    // 在集合中找到匹配项  
                    // 用新BlockOutTimeVO替换旧值  
                    botVO.setDirty();  // 标记旧依赖项已修改  
                    botVO.resetNew();  // 标记非新依赖项  
                    existingBOT = botVO;  
                }  
            }  
        }  
    } catch (Exception exc) {  
        throw new EJBException(...);  
    }  
}  

public void updateSkillSet(Collection updSkills)   
throws CommitmentException { // 实现逻辑与updateBlockOutTime类似

# Implementing the Lazy Loading Strategy  

When the Composite Entity is first loaded in the ejbLoad() method by the container, let us assume that only the resource data is to be loaded. This includes the attributes listed in the ResourceEntity bean, excluding the dependent object collections. The dependent objects can then be loaded only if the client invokes a business method that needs these dependent objects to be loaded. Subsequently, the ejbLoad() needs to keep track of the dependent objects loaded in this manner and include them for reloading.  

当容器首次通过`ejbLoad()`方法加载组合实体时，我们假定仅需加载资源数据。这包括`ResourceEntity` Bean中列出的属性，但不包含依赖对象集合。仅当客户端调用需要加载这些依赖对象的业务方法时，才会加载依赖对象。此后，`ejbLoad()`需追踪以此方式加载的依赖对象，并在重新加载时包含它们。

The relevant methods from the ResourceEntity class are shown in Example 8.19.  

ResourceEntity 类的相关方法如示例 8.19 所示。

# Example 8.19 Implementing Lazy Loading Strategy  

public Collection getSkillSetsData() {   
throws SkillSetException { checkSkillSetLoad(); return skillSets;   
}   
private void checkSkillSetLoad()   
throws SkillSetException { try { // Lazy Load strategy...Load on demand if (skillSets $==$ null) skillSets $=$ getSkillSetDAO(resourceId).loadAll(); } catch(Exception exception) { // No skills, throw an exception throw new SkillSetException(...);   
public void ejbLoad() { try { // load the resource info from ResourceDAO resourceDAO $=$ new ResourceDAO(employeeId); setResourceData((ResourceVO)resourceDAO.load()); // If the lazy loaded objects are already // loaded, they need to be reloaded. // If there are not loaded, do not load them // here...lazy load will load them later. if (skillSets ! $=$ null) { reloadSkillSets(); } if (blockOutTimes ! $=$ null) { reloadBlockOutTimes(); } throw new EJBException("Reason:" $^+$ ...);  

public Collection getSkillSetsData() {   
throws SkillSetException { checkSkillSetLoad(); return skillSets;   
}   
private void checkSkillSetLoad()   
throws SkillSetException { try { // 延迟加载策略...按需加载 if (skillSets $==$ null) skillSets $=$ getSkillSetDAO(resourceId).loadAll(); } catch(Exception exception) { // 无技能数据时抛出异常 throw new SkillSetException(...);   
public void ejbLoad() { try { // 从ResourceDAO加载资源信息 resourceDAO $=$ new ResourceDAO(employeeId); setResourceData((ResourceVO)resourceDAO.load()); // 若延迟加载对象已加载则需重新加载 // 若未加载则不在此处加载...延迟加载机制后续会处理 if (skillSets ! $=$ null) { reloadSkillSets(); } if (blockOutTimes ! $=$ null) { reloadBlockOutTimes(); } throw new EJBException("Reason:" $^+$ ...);

# Implementing the Store Optimization (Dirty Marker) Strategy  

To use the Store Optimization strategy, the dependent objects need to have implemented the DirtyMarker interface, as shown in Example 8.20. The ejbStore() method to optimize using this strategy is listed in Example 8.21.  

要使用存储优化策略，依赖对象需实现`DirtyMarker`接口（如示例8.20所示）。采用该策略优化的`ejbStore()`方法实现详见示例8.21。

# Example 8.20 SkillSet Dependent Object Implements DirtyMarker Interface  

ublic class SkillSetVO implements DirtyMarker,   
java.io.Serializable {   
private String skillName;   
private String expertiseLevel;   
private String info;   
// dirty flag   
private boolean dirty $=$ false;   
// new flag   
private boolean isnew $=$ true;   
// deleted flag   
private boolean deleted $=$ false;   
public SkillSetVO(...) // initialization // is new VO setNew(); // get, set and other methods for SkillSet   
// all set methods and modifier methods // must call setDirty()   
public setSkillName(String newSkillName) skillName $=$ newSkillName; setDirty();   
// DirtyMarker methods   
// used for modified value objects only   
public void setDirty() { dirty $=$ true;   
}   
public void resetDirty() { dirty $=$ false;   
}   
public boolean isDirty() { return dirty;   
// used for new value objects only   
public void setNew() { isnew $=$ true;   
}   
public void resetNew() { isnew $=$ false;   
}   
public boolean isNew() { return isnew;   
// used for deleted objects only   
public void setDeleted() { deleted $=$ true;   
}   
public boolean isDeleted() { return deleted;   
}   
public void resetDeleted() { deleted $=$ false;  

public class SkillSetVO implements DirtyMarker,   
java.io.Serializable {   
private String skillName;   
private String expertiseLevel;   
private String info;   
// 脏数据标记   
private boolean dirty $=$ false;   
// 新增标记   
private boolean isnew $=$ true;   
// 删除标记   
private boolean deleted $=$ false;   
public SkillSetVO(...) // 初始化 // 新建VO时调用setNew(); // SkillSet的get、set及其他方法   
// 所有set方法和修改方法 // 必须调用setDirty()   
public setSkillName(String newSkillName) skillName $=$ newSkillName; setDirty();   
// DirtyMarker接口方法   
// 仅用于修改后的值对象   
public void setDirty() { dirty $=$ true;   
}   
public void resetDirty() { dirty $=$ false;   
}   
public boolean isDirty() { return dirty;   
// 仅用于新增值对象   
public void setNew() { isnew $=$ true;   
}   
public void resetNew() { isnew $=$ false;   
}   
public boolean isNew() { return isnew;   
// 仅用于已删除对象   
public void setDeleted() { deleted $=$ true;   
}   
public boolean isDeleted() { return deleted;   
}   
public void resetDeleted() { deleted $=$ false;

# Example 8.21 Implementing Store Optimization  

blic void ejbStore() {   
ry {   
// Load the mandatory data   
getResourceDAO().update(getResourceData());   
// Store optimization for dependent objects   
// check dirty and store   
// Check and store commitments   
if (skillSets ! $=$ null) { // Get the DAO to use to store SkillSetDAO skillSetDAO $=$ getSkillSetDAO(); Iterator skillIter $=$ skillSet.iterator(); while(skillIter.hasNext()) { SkillSetVO skill $=$ (SkillSetVO) skillIter.next(); if (skill.isNew()) { // This is a new dependent, insert it skillSetDAO.insert(skill); skill.resetNew(); skill.resetDirty(); } else if (skill.isDeleted()) { // delete Skill skillSetDAO.delete(skill); // Remove from dependents list skillSets.remove(skill); } else if (skill.isDirty()) { // Store Skill, it has been modified skillSetDAO.update(skill); // Saved, reset dirty. skill.resetDirty(); skill.resetNew();   
// Similarly, implement store optimization  

public void ejbStore() {   
try {   
// 加载必填数据  
getResourceDAO().update(getResourceData());   
// 为依赖对象实现存储优化  
// 检查脏数据并存储  
// 检查并存储承诺数据  
if (skillSets != null) { // 获取用于存储的DAO  
SkillSetDAO skillSetDAO = getSkillSetDAO();   
Iterator skillIter = skillSet.iterator();   
while(skillIter.hasNext()) {   
SkillSetVO skill = (SkillSetVO) skillIter.next();   
if (skill.isNew()) { // 新增依赖项，执行插入  
skillSetDAO.insert(skill);   
skill.resetNew();   
skill.resetDirty();   
} else if (skill.isDeleted()) { // 删除技能项  
skillSetDAO.delete(skill);   
// 从依赖列表中移除  
skillSets.remove(skill);   
} else if (skill.isDirty()) { // 存储已修改的技能项  
skillSetDAO.update(skill);   
// 保存后重置脏标记  
skill.resetDirty();   
skill.resetNew();   
// 类似地实现存储优化

// BlockOutTime, catch(SkillSetException ex) { throw new EJBException("Reason:"+...); } catch(BlockOutTimeException ex) { throw new EJBException("Reason:"+...); catch(CommitmentException ex) { throw new EJBException("Reason:"+...);  

// BlockOutTime, catch(SkillSetException ex) { throw new EJBException("原因:"+...); } catch(BlockOutTimeException ex) { throw new EJBException("原因:"+...); catch(CommitmentException ex) { throw new EJBException("原因:"+...);

# Implementing the Composite Value Object Strategy  

Now consider the requirement where the client needs to obtain all the data from the ResourceEntity, and not just one part. This can be done using the Composite Value Object Strategy, as shown in Example 8.22.  

现在考虑这样一个需求：客户端需要获取`ResourceEntity`的全部数据，而非仅其中一部分。这可以通过**组合值对象策略**实现，如示例8.22所示。

# Example 8.22 Implementing the Composite Value Object  

public class ResourceCompositeVO { private ResourceVO resourceData; private Collection skillSets; private Collection blockOutTimes; // value object constructors // get and set methods  

public class ResourceCompositeVO {  
    private ResourceVO resourceData;  
    private Collection skillSets;  
    private Collection blockOutTimes;  
    // 值对象构造函数  
    // get与set方法  
}

The ResourceEntity provides a getResourceDetailsData() method to return the ResourceCompositeVO composite value object, as shown in Example 8.23.  

ResourceEntity 提供了 `getResourceDetailsData()` 方法用于返回 ResourceCompositeVO 组合值对象，如示例 8.23 所示。

# Example 8.23 Creating the Composite Value Object  

public ResourceCompositeVO getResourceDetailsData() { ResourceCompositeVO compositeVO $=$  

public ResourceCompositeVO getResourceDetailsData() { ResourceCompositeVO compositeVO =

new ResourceCompositeVO (getResourceData(), getSkillsData(), getBlockOutTimesData()); return compositeVO;  

new ResourceCompositeVO(getResourceData(), getSkillsData(), getBlockOutTimesData());  
return compositeVO;

# Related Patterns  

# Value Object  

The Composite Entity pattern uses the Value Object pattern for creating the value object and returning it to the client. The Value Object pattern is used to serialize the coarse-grained and dependent objects tree, or part of the tree, as required.  

组合实体模式通过值对象模式创建值对象并将其返回给客户端。值对象模式用于按需将粗粒度的依赖对象树（或其部分结构）序列化。

# Session Facade  

If dependent objects tend to be entity beans rather than the arbitrary Java objects, try to use the Session Facade pattern to manage the inter-entity-bean relationships.  

若依赖对象多为实体Bean而非任意Java对象，应尝试采用**会话门面模式**来管理实体Bean间的交互关系。

# Value Object Assembler  

When it comes to obtaining a composite value object from the Composite Entity (see the “Facilitates Composite Value Object Creation” under the “Consequences” section), this pattern is similar to the Value Object Assembler pattern. However, in this case, the data sources for all the value objects in the composite are parts of the Composite Entity itself, whereas for the Value Object Assembler, the data sources can be different entity beans, session beans, DAOs, Java objects, and so on.  

在从组合实体（Composite Entity）获取组合值对象时（参见“后果”章节中的“便于组合值对象创建”部分），该模式与值对象组装器（Value Object Assembler）模式类似。然而，在这种情况下，组合中所有值对象的数据源均来自组合实体本身；而对于值对象组装器而言，数据源可以是不同的实体Bean、会话Bean、DAO、Java对象等。

# Entity Bean as a Dependent Object: Issues and Recommendations  

Typically, we design dependent objects as Java objects that have a direct relationship with the parent coarse-grained object. However, there may be situations when a dependent object may appear as an entity bean itself. This can happen  

通常，我们会将依赖对象设计为与父级粗粒度对象存在直接关联的Java对象。然而在某些情况下，依赖对象可能以实体Bean的形式出现。这种情况可能发生在

1. If the dependent object appears to be depending on two different parent objects (as is the case with association classes).  

1. 如果依赖对象似乎依赖于两个不同的父对象（如关联类的情况）。

2. If the dependent object already exists as an entity bean in the same application or is imported from a different application.  

2. 若依赖对象已作为同一应用中的实体Bean存在，或从其他应用导入。

In these cases, the lifestyle of the dependent object may not appear to be directly related to and managed by a single parent coarse-grained object. So, what do you do when a dependent object is an entity bean? When you see a dependent object that is not totally dependent on its parent object? Or when you cannot identify its sole parent object?  

在这些情况下，依赖对象的生命周期可能并不直接关联或由单个父级粗粒度对象管理。那么当依赖对象是一个实体Bean时该如何处理？当你遇到不完全依赖于其父对象的依赖对象时？或者当你无法确定其唯一父对象时？

Let's consider each case in a little more detail.  

让我们更详细地逐一分析每种情况。

# Case 1: The Dependent Object Depends on Two Parent Objects  

Let us explore this with the following example. A Commitment represents an association between a Resource and a Project.  

让我们通过以下示例来探讨这一点。Commitment表示资源(Resource)与项目(Project)之间的关联关系。

Figure 8.24 shows an example class diagram with relationships between Project, Resource and Commitment.  

图8.24展示了一个包含Project、Resource和Commitment之间关系的类图示例。

![](images/8dd06a19ef32f97b8f02ecc02259da443ad0048b3530a5881b8bf64679816ef5.jpg)  
Figure 8.24. Example: Dependent object with two parent objects  

图 8.24  示例：具有两个父对象的依赖对象

Commitment is a dependent object. Both Projects and Resources are coarse-grained objects. Each Project has a one-to-many relationship with Commitment objects. Each Resource also has a one-to-many relationship with Commitment objects. So, is Commitment a dependent object of Project or of Resource? The answer lies in analyzing the interactions for the use cases that involve these three objects. If you make the Commitment a dependent of the Project, then when the Resource accesses its list Commitment objects, it has to do so through the Project object. On the other hand, if the Commitment is a dependent of a Resource, when the Project accesses its list of Commitment objects, it has to do so via the Resource. Both these choices will introduce entity-bean-to-entity-bean relationships in the design.  

Commitment 是一个依赖对象。Project 和 Resource 都属于粗粒度对象。每个 Project 与 Commitment 对象存在一对多关系，每个 Resource 同样与 Commitment 对象存在一对多关系。那么 Commitment 究竟是 Project 的依赖对象还是 Resource 的依赖对象？答案需通过分析涉及这三个对象的用例交互来确定。若将 Commitment 作为 Project 的依赖对象，则当 Resource 访问其 Commitment 对象列表时，必须通过 Project 对象间接操作；反之若将 Commitment 作为 Resource 的依赖对象，则 Project 访问其 Commitment 对象列表时需经由 Resource 完成。这两种选择都会在设计中引入 entity-bean 到 entity-bean 的关联关系。

But, what if the Commitment is made an entity bean instead of a dependent object? Then the relationships between the Project and its list of Commitment objects, and between a Resource and its list of Commitment objects, will be entity-to-entity bean relationships. This just worsens the problem in that now there are two entity-bean-to-entity-bean relationships.  

但如果将Commitment改为实体Bean而非依赖对象呢？那么Project与其Commitment对象列表之间、以及Resource与其Commitment对象列表之间的关系，就会变成实体Bean之间的关联。这反而加剧了问题，因为现在存在两对实体Bean间的关联关系。

Entity-bean-to-entity-bean relationships are not recommended due to the overhead associated with managing and sustaining such a relationship.  

不建议建立实体Bean间的直接关联关系，因为管理和维护此类关系会带来额外开销。

# Case 2: The Dependent Object Already Exists as an Entity Bean  

In this case, it may seem that one way to model this relationship is to store the primary key of the dependent object in the coarse-grained object. When the coarse-grained object needs to access the dependent object, it results in an entity-bean-to-entity-bean invocation. The class diagram for this example is shown in Figure 8.25.  

在这种情况下，一种建模方式似乎是将依赖对象的主键存储在粗粒度对象中。当粗粒度对象需要访问依赖对象时，会触发实体Bean到实体Bean的调用。该示例的类图如图8.25所示。

# Figure 8.25. Dependent Object is an Entity Bean class diagram  

![](images/22eb017fcade795df496595cb9683458d535b2e164ffddfd353b3df84f2a8d81.jpg)  

The sequence diagram for this scenario is shown in Figure 8.26. The Composite Entity uses the dependent object references to look up the required dependent entity beans. The dependent object in this case is a proxy to the dependent entity bean, as shown.  

该场景的序列图如图8.26所示。组合实体通过依赖对象引用查找所需的依赖实体Bean。本例中的依赖对象是依赖实体Bean的代理，如图所示。

![](images/af07c218d40a918bae068bd587313077a99d8547d3c2260ba731e09fc6f719fc.jpg)  
Figure 8.26. Dependent Object is an Entity Bean sequence diagram  

图 8.26. 依赖对象作为实体Bean的序列图

While this may address the requirement of using a dependent entity bean from a parent entity bean, it is not an elegant solution. Instead, to avoid the complexity of designing and managing inter-entity relationships, consider using a session bean to help manage the relationships among entity beans. In our experience, we have found that the Session Facade pattern helps us to avoid this problem and provides a better way of managing entity-bean-to-entity-bean relationships. So, we recommend avoiding entity-bean-to-entity-bean relationships as a best practice and to factor out such relationships into a session bean, using the Session Facade pattern (see “Session Facade”).  

虽然这种做法可以满足从父实体Bean中使用依赖实体Bean的需求，但并非优雅的解决方案。为避免设计和维护实体间关系的复杂性，建议采用会话Bean来管理实体Bean间的关系。根据我们的实践经验，**会话门面模式**能有效规避此类问题，并为管理实体Bean间关系提供了更优方案。因此我们建议遵循最佳实践——避免直接的实体Bean间关联，转而通过会话门面模式（参见"Session Facade"章节）将这些关系抽离到会话Bean中实现。

# Value Object Assembler  

# Context  

In a J2EE application, the server-side business components are implemented using session beans, entity beans, DAOs, and so forth. Application clients frequently need to access data that is composed from multiple objects.  

在J2EE应用中，服务器端业务组件通过会话Bean、实体Bean、DAO等实现。应用客户端经常需要访问由多个对象组合而成的数据。

# Problem  

Application clients typically require the data for the model or parts of the model to present to the user or to use for an intermediate processing step before providing some service. The application model is an abstraction of the business data and business logic implemented on the server side as business components. A model may be expressed as a collection of objects put together in a structured manner (tree or graph). In a J2EE application, the model is a distributed collection of objects such as session beans, entity beans, or DAOs and other objects. For a client to obtain the data for the model, such as to display to the user or to perform some processing, it must access individually each distributed object that defines the model. This approach has several drawbacks:  

应用客户端通常需要获取模型或部分模型的数据，以便向用户展示或在提供某些服务前用于中间处理步骤。应用模型是对业务数据及服务器端业务组件所实现的业务逻辑的抽象。模型可以表示为以结构化方式（树形或图状）组合的对象集合。在J2EE应用中，模型是分布式对象集合，例如会话Bean、实体Bean、DAO及其他对象。客户端若要获取模型数据（如用于用户展示或执行某些处理），必须逐个访问定义该模型的每个分布式对象。这种方式存在若干缺陷：

Because the client must access each distributed component individually, there is a tight coupling between the client and the distributed components of the model over the network The client accesses the distributed components via the network layer, and this can lead to performance degradation if the model is complex with numerous distributed components. Network and client performance degradation occur when a number of distributed business components implement the application model and the client directly interacts with these components to obtain model data from that component. Each such access results in a remote method call that introduces network overhead and increases the chattiness between the client and the business tier. The client must reconstruct the model after obtaining the model's parts from the distributed components. The client therefore needs to have the  

由于客户端必须单独访问每个分布式组件，客户端与模型中的分布式组件通过网络形成了紧耦合。客户端通过网络层访问分布式组件，若模型结构复杂且包含大量分布式组件，则可能导致性能下降。当多个分布式业务组件实现应用模型时，客户端直接与这些组件交互以获取模型数据，此时网络和客户端性能均会降低。每次此类访问都会产生远程方法调用，从而引入网络开销并增加客户端与业务层之间的通信频次。客户端在从分布式组件获取模型片段后，还需重新构建完整模型。因此客户端需要具备...

necessary business logic to construct the model. If the model construction is complex and numerous objects are involved in its definition, then there may be an additional performance overhead on the client due to the construction process. In addition, the client must contain the business logic to manage the relationships between the components, which results in a more complex, larger client. When the client constructs the application model, the   
construction happens on the client side. Complex model construction can result in a significant performance overhead on the client side for clients with limited resources.   
Because the client is tightly coupled to the model, changes to the model require changes to the client. Furthermore, if there are different types of clients, it is more difficult to manage the changes across all client types. When there is tight coupling between the client and model implementation, which occurs when the client has direct knowledge of the model and manages the business component relationships, then changes to the model necessitate changes to the client. There is the further problem of code duplication for model access, which occurs when an application has many types of clients. This duplication makes client (code) management difficult when the model changes.  

构建模型所需的业务逻辑。若模型构建过程复杂且涉及大量对象定义，则客户端可能因构建过程产生额外性能开销。此外，客户端必须包含管理组件间关系的业务逻辑，这会导致客户端变得更复杂、更庞大。当客户端构建应用模型时，所有构建操作均在客户端执行。对于资源受限的客户端而言，复杂的模型构建可能造成显著的性能负担。

由于客户端与模型紧密耦合，模型变更必然引发客户端修改。若存在多种客户端类型，跨所有客户端类型的变更管理将更加困难。当客户端直接知晓模型细节并管理业务组件关系时，客户端与模型实现之间会产生紧耦合，此时模型变更将强制要求客户端同步调整。另一个问题是模型访问的代码重复——当应用存在多种客户端类型时会出现这种情况。这种重复使得模型变更时客户端（代码）管理变得异常困难。

# Forces  

Separation of business logic is required between the client and the   
server-side components.   
Because the model consists of distributed components, access to each component is associated with a network overhead. It is desirable to minimize the number of remote method calls over the network.   
The client typically needs only to obtain the model to present it to the user. If the client must interact with multiple components to construct the model on the fly, the chattiness between the client and the application increases. Such chattiness may reduce the network performance.   
Even if the client wants to perform an update, it usually updates only certain parts of the model and not the entire model.   
Clients do not need to be aware of the intricacies and dependencies in the model implementation. It is desirable to have loose coupling between the clients and the business components that implement the application model. Clients do not otherwise need to have the additional business logic required to construct the model from various business components.  

客户端与服务器端组件之间需要实现业务逻辑的分离。  
由于模型由分布式组件构成，访问每个组件都会产生网络开销，因此应尽量减少网络上的远程方法调用次数。  

客户端通常仅需获取模型以呈现给用户。若客户端必须动态与多个组件交互来构建模型，则会增加客户端与应用之间的频繁通信，这种通信密集度可能降低网络性能。  
即使客户端需要执行更新操作，通常也仅更新模型的特定部分而非整个模型。  

客户端无需了解模型实现中的复杂细节和依赖关系。理想情况下，客户端与实现应用模型的业务组件之间应保持松耦合。客户端不应额外承担从各业务组件构建模型所需的业务逻辑。

# Solution  

Use a Value Object Assembler to build the required model or submodel. The Value Object Assembler uses value objects to retrieve data from various  

使用值对象组装器构建所需的模型或子模型。该值对象组装器通过值对象从多个数据源获取数据。

# business objects and other objects that define the model or part of the model.  

The Value Object Assember constructs a composite value object that represents data from different business components. The value object caries the data for the model to the client in a single method call. Since the model data can be complex, it is recommended that this value object be immutable. That is, the client obtains such value objects with the sole purpose of using them for presentation and processing in a read-only manner. Clients are not allowed to make changes to the value objects.  

值对象装配器构建了一个复合值对象，用于表示来自不同业务组件的数据。该值对象通过单次方法调用将模型数据传递给客户端。鉴于模型数据可能较为复杂，建议将此值对象设计为不可变对象。也就是说，客户端获取这类值对象的唯一目的是以只读方式将其用于展示和处理，不允许对值对象进行任何修改。

When the client needs the model data, and if the model is represented by a single coarse-grained component (such as a Composite Entity), then the process of obtaining the model data is simple. The client simply requests the coarse-grained component for its composite value object. However, most real-world applications have a model composed of a combination of many coarse-grained and fine-grained components. In this case, the client must interact with numerous such business components to obtain all the data necessary to represent the model. The immediate drawbacks of this approach can be seen in that the clients become tightly coupled to the model implementation (model elements) and that the clients tend to make numerous remote method invocations to obtain the data from each individual component.  

当客户端需要模型数据时，若该模型由单个粗粒度组件（如组合实体）表示，则获取模型数据的过程较为简单。客户端只需向该粗粒度组件请求其组合值对象即可。然而，大多数实际应用中的模型由多个粗粒度与细粒度组件共同构成。这种情况下，客户端必须与大量此类业务组件交互，才能获取完整表征模型所需的全部数据。这种方式的直接弊端显而易见：客户端会与模型实现（模型元素）形成紧耦合，且客户端往往需要通过大量远程方法调用来从各个独立组件中获取数据。

In some cases, a single coarse-grained component provides the model or parts of the model as a single value object (simple or composite). However, when multiple components represent the model, a single value object (simple or composite) may not represent the entire model. To represent the model, it is necessary to obtain value objects from various components and assemble them into a new composite value object. The server, not the client, should perform such “on-the-fly” construction of the model.  

在某些情况下，单个粗粒度组件会以单一值对象（简单或复合形式）提供模型或模型的部分内容。然而，当多个组件共同表征模型时，单一值对象（简单或复合形式）可能无法完整呈现整个模型。此时需要通过从不同组件获取值对象，并将其组装成新的复合值对象来表征模型。此类模型的"动态构建"应当由服务端而非客户端完成。

# Structure  

Figure 8.27 shows the class diagram representing the relationships for the Value Object Assembler pattern.  

图8.27展示了表示**值对象装配器模式**关系的类图。

# Figure 8.27. Value Object Assembler class diagram  

![](images/5a5919dd38c2b3378ff40e746bf7a0b4034814cf90a0fa49c1a21766a427f5a9.jpg)  

# Participants and Responsibilities  

The sequence diagram in Figure 8.28 shows the interaction between the various participants in the Value Object Assembler pattern.  

图8.28中的序列图展示了值对象装配器模式中各参与者间的交互过程。

![](images/fbef019c171caf1856a8244f00212c314d3682e6705aea7967304432535c45c2.jpg)  
Figure 8.28. Value Object Assembler sequence diagram  

图8.28 值对象装配器时序图

# ValueObjectAssembler  

The ValueObjectAssembler is the main class of this pattern. The ValueObjectAssembler constructs a new value object based on the requirements of the application when the client requests a composite value object. The ValueObjectAssembler then locates the required BusinessObject instances to retrieve data to build the composite value object. BusinessObjects are business-tier components such as entity beans and session beans, DAOs, and so forth.  

ValueObjectAssembler 是该模式的核心类。当客户端请求组合值对象时，ValueObjectAssembler 会根据应用程序的需求构造新的值对象。随后，ValueObjectAssembler 会定位所需的 BusinessObject 实例以获取数据，从而构建组合值对象。BusinessObjects 是业务层组件，例如实体 Bean、会话 Bean、DAO 等。

# Client  

If the ValueObjectAssembler is implemented as an arbitrary Java object, then the client is typically a Session Facade that provides the controller layer to the business tier. If the ValueObjectAssembler is implemented as a session bean, then the client can be a Session Facade or a Business Delegate.  

若将ValueObjectAssembler实现为普通Java对象，客户端通常是由**会话门面**（Session Facade）充当，该门面为业务层提供控制器功能。若采用会话Bean实现ValueObjectAssembler，则客户端可以是会话门面或**业务委托**（Business Delegate）。

# BusinessObject  

The BusinessObject participates in the construction of the new value object by providing the required data to the ValueObjectAssembler. Therefore, the BusinessObject is a role that can be fulfilled by a session bean, an entity bean, a DAO, or a regular Java object.  

`BusinessObject`通过向`ValueObjectAssembler`提供所需数据参与新值对象的构建。因此，`BusinessObject`这一角色可由会话Bean、实体Bean、DAO或常规Java对象实现。

# ValueObject  

The ValueObject is a composite value object that is constructed by the ValueObjectAssembler and returned to the client. This represents the complex data from various components that define the application model.  

ValueObject 是一个复合值对象，由 ValueObjectAssembler 构建并返回给客户端。它封装了来自定义应用模型的各个组件的复杂数据。

# BusinessObject  

BusinessObject is a role that can be fulfilled by a session bean, entity bean, or DAO. When the assembler needs to obtain data directly from the persistent storage to build the value object, it can use a DAO. This is shown as the DataAccessObject object in the diagrams.  

业务对象（BusinessObject）这一角色可由会话Bean、实体Bean或DAO实现。当组装器需要直接从持久化存储获取数据以构建值对象时，可采用DAO模式，在图中以DataAccessObject对象表示。

# Strategies  

This section explains different strategies for implementing a Value Object Assembler pattern.  

本节阐述实现值对象装配器模式的不同策略。

# Java Object Strategy  

The ValueObjectAssembler can be an arbitrary Java object and need not be an enterprise bean. In such implementations, a session bean usually fronts the ValueObjectAssembler. This session bean is typically a Session Facade that performs its other duties related to providing business services. The ValueObjectAssembler runs in the business tier, regardless of the implementation strategies. The motivation for this is to prevent the remote invocations from the ValueObjectAssembler to the source objects from crossing the tier.  

ValueObjectAssembler可以是任意Java对象，无需作为企业级Bean存在。在此类实现中，通常由会话Bean作为ValueObjectAssembler的门面。该会话Bean一般是**Session Facade**模式，负责执行与业务服务相关的其他职责。无论采用何种实现策略，ValueObjectAssembler始终运行在业务层。这种设计的核心动机是避免ValueObjectAssembler与源对象之间的远程调用跨越层级边界。

# Session Bean Strategy  

This strategy implements the ValueObjectAssembler as a session bean (as shown in the class diagram). If a session bean implementation is preferred to provide the ValueObjectAssembler as a business service, it is typically implemented as a stateless session bean. The business components that make up the application model are constantly involved in transactions with various clients. As a result, when a ValueObjectAssembler constructs a new composite value object from various business components, it produces a snapshot of the model at the time of construction. The model could change immediately thereafter if another client changes one or more business components, effectively changing the business application model.  

该策略将ValueObjectAssembler实现为会话Bean（如类图所示）。若需将会话Bean实现作为业务服务提供ValueObjectAssembler，通常将其实现为无状态会话Bean。构成应用模型的业务组件会持续参与各类客户端的事务处理。因此，当ValueObjectAssembler从多个业务组件构建新的组合值对象时，生成的是构建时刻的模型快照。若其他客户端随后修改了任一业务组件，将导致业务应用模型实际变更，此时该快照可能立即失效。

Therefore, implementing ValueObjectAssembler as a stateful session bean provides no benefits over implementing it as a stateless session bean, as preserving the state of the composite model data value when the underlying model is changing is futile. If the underlying model changes, it causes the value object held by the assembler to become stale. The ValueObjectAssembler, when next asked for the value object, either returns a stale state or reconstructs the value object to obtain the most recent snapshot. Therefore, it is recommended that the assembler be a stateless session bean to leverage the benefits of stateless over stateful session beans.  

因此，将ValueObjectAssembler实现为有状态会话Bean相比无状态会话Bean并无优势，因为在底层模型变化时保留组合模型数据值的状态是徒劳的。若底层模型发生变更，会导致组装器持有的值对象状态失效。当ValueObjectAssembler再次被请求值对象时，要么返回过时状态，要么重新构建值对象以获取最新快照。故而建议将该组装器实现为无状态会话Bean，以充分发挥无状态会话Bean相较于有状态会话Bean的优势。

However, if the underlying model rarely changes, then the assembler may be a stateful session bean and retain the newly constructed value object. In this case, the ValueObjectAssembler must include mechanisms to recognize changes to the underlying model and to reconstruct the model for the next client request.  

然而，若底层模型极少变更，则组装器可作为有状态会话Bean保留新构建的值对象。此时，**ValueObjectAssembler**必须包含识别底层模型变更的机制，并为后续客户端请求重建模型。

# Business Object Strategy  

The BusinessObject role in this pattern can be supported by different types of objects, as explained below.  

该模式中的`BusinessObject`角色可由不同类型的对象支持，具体说明如下。

The BusinessObject can be a session bean. The Value Object Assembler may use a Service Locator (see “Service Locator”) to locate the required session bean. The Value Object Assembler requests this session bean to provide the data to construct the composite value object.   
The BusinessObject can be an entity bean. The Value Object Assembler may use a Service Locator to locate the required entity bean. The Value Object Assembler requests this entity bean to provide the data to construct the composite value object.   
The BusinessObject can be a DAO. The Value Object Assembler requests this DAO to provide the data to construct the composite value object.   
The BusinessObject can be an arbitrary Java object. The Value Object Assembler requests this Java object to provide the data to construct the composite value object.   
The BusinessObject can be another Value Object Assembler. The first Value Object Assembler requests the second Value Object Assembler to provide the data to construct the composite value object.  

`BusinessObject`可以是一个会话Bean。值对象组装器可以使用服务定位器（参见“服务定位器”）来定位所需的会话Bean，并请求该会话Bean提供数据以构建复合值对象。  

`BusinessObject`可以是一个实体Bean。值对象组装器可以使用服务定位器来定位所需的实体Bean，并请求该实体Bean提供数据以构建复合值对象。  

`BusinessObject`可以是一个DAO。值对象组装器请求该DAO提供数据以构建复合值对象。  

`BusinessObject`可以是一个任意Java对象。值对象组装器请求该Java对象提供数据以构建复合值对象。  

`BusinessObject`可以是另一个值对象组装器。第一个值对象组装器请求第二个值对象组装器提供数据以构建复合值对象。

# Consequences  

# Separates Business Logic  

When the client includes logic to manage the interactions with distributed components, it becomes difficult to clearly separate business logic from the client tier. The Value Object Assembler contains the business logic to maintain the object relationships and to construct the composite value  

当客户端包含管理分布式组件交互的逻辑时，业务逻辑与客户端层将难以清晰分离。值对象组装器（Value Object Assembler）封装了维护对象关系及构建复合值对象的业务逻辑。

object representing the model. The client needs no knowledge of how to construct the model or the different components that provide data to assemble the model.  

表示模型的对象。客户端无需了解如何构造模型，也无需知晓为组装模型提供数据的各个组件。

# Reduces Coupling Between Clients and the Application Model  

The Value Object Assembler hides the complexity of the construction of model data from the clients and establishes a loose coupling between clients and the model. With loose coupling, if the model changes, then the Value Object Assembler requires a corresponding change. However, the client is not dependent on the model construction and interrelationships between model business components, so model changes do not directly affect the client. In general, loose coupling is preferred to tight coupling.  

值对象组装器向客户端隐藏了模型数据的构建复杂性，并在客户端与模型之间建立了松耦合关系。采用松耦合设计时，若模型发生变更，值对象组装器需相应调整。但由于客户端不依赖于模型构建过程及模型业务组件间的关联关系，模型变更不会直接影响客户端。通常而言，松耦合设计优于紧耦合设计。

# Improves Network Performance  

The Value Object Assembler drastically reduces the network overhead of remote method calls and chattiness. The client can request the data for the application model from the Value Object Assembler in a single remote method call. The assembler constructs and returns the composite value object for the model. However, the composite value object may contain a large amount of data. Thus, while use of the Value Object Assembler reduces the number of network calls, there is an increase in the amount of data transported in a single call. This trade-off should be considered in applying this pattern.  

**值对象组装器**显著降低了远程方法调用的网络开销与频繁交互问题。客户端可通过单次远程方法调用从值对象组装器获取应用模型所需数据，该组装器会构建并返回模型的复合值对象。但需注意，复合值对象可能包含大量数据。因此，虽然使用值对象组装器减少了网络调用次数，但单次传输的数据量会相应增加。在应用此模式时需权衡这一利弊。

# Improves Client Performance  

The server-side Value Object Assembler constructs the model as a composite value object without using any client resources. The client spends no time assembling the model.  

服务端值对象组装器将模型构建为复合值对象，且不占用任何客户端资源。客户端无需耗费时间组装模型。

# Improves Transaction Performance  

Typically, updates are isolated to a very small part of the model and can be performed by fine-grained transactions. These transactions focus on isolated parts of the model instead of locking up the coarse-grained object (model). After the client obtains the model and displays or processes it locally, the user (or the client) may need to update or otherwise modify the model. The client can interact directly with a Session Facade to accomplish this at a suitable granularity level. The Value Object Assembler is not involved in the transaction to update or modify the model. There is better performance control because transactional work with the model happens at the appropriate level of granularity.  

通常，更新操作仅涉及模型的极小部分，可通过细粒度事务完成。这些事务专注于模型的独立片段，而非锁定整个粗粒度对象（模型）。当客户端获取模型并在本地展示或处理后，用户（或客户端）可能需要更新或修改模型。客户端可直接与会话门面交互，以合适的粒度级别完成此操作。值对象组装器不参与模型的更新或修改事务。由于模型的事务处理发生在恰当的粒度层级，因此能实现更优的性能控制。

# May Introduce Stale Value Objects  

The Value Object Assembler constructs value objects on demand. These value objects are snapshots of the current state of the model, represented by various business components. Once the client obtains a value object from the assembler, that value object is entirely local to the client. Since the value objects are not network-aware, other changes made to the business components used to construct the value object are not reflected in the value objects. Therefore, after the value object is obtained, it can quickly become stale if there are transactions on the business components.  

值对象组装器按需构建值对象。这些值对象是由不同业务组件构成的模型当前状态的快照。当客户端从组装器获取值对象后，该值对象完全属于客户端本地。由于值对象不具备网络感知能力，用于构建值对象的业务组件发生的其他变更不会反映在值对象中。因此，若业务组件发生事务操作，获取后的值对象可能迅速失效。

# Sample Code  

# Implementing the Value Object Assembler  

Consider a Project Management application where a number of business-tier components define the complex model. Suppose a client wants to obtain the model data composed of data from various business objects, such as:  

假设有一个项目管理应用，其中多个业务层组件定义了复杂的模型。若客户端需要获取由各类业务对象（例如：

• Project Information from the Project component • Project Manager information from the ProjectManager component • List of Project Tasks from the Project component • Resource Information from the Resource component  

• 来自 **Project** 组件的项目信息  
• 来自 **ProjectManager** 组件的项目经理信息  
• 来自 **Project** 组件的项目任务列表  
• 来自 **Resource** 组件的资源信息

A composite value object to contain this data can be defined as shown in Example 8.24. A Value Object Assembler pattern can be implemented to assemble this composite value object. The Value Object Assembler sample code is listed in Example 8.28.  

如示例8.24所示，可定义一个复合值对象来封装该数据。通过实现**值对象组装器模式**（Value Object Assembler）可组装该复合值对象，其示例代码见示例8.28。

# Example 8.24 Composite Value Object Class  

public class ProjectDetailsData { public ProjectVO projectData; public ProjectManagerVO projectManagerData; public Collection listOfTasks;  

public class ProjectDetailsData { public ProjectVO projectData; public ProjectManagerVO projectManagerData; public Collection listOfTasks;

The list of tasks in the ProjectDetailsData is a collection of TaskResourceVO objects. The TaskResourceVO is a combination of TaskVO and ResourceVO. These classes are shown in Example 8.25, Example 8.26, and Example 8.27.  

`ProjectDetailsData`中的任务列表是`TaskResourceVO`对象的集合。`TaskResourceVO`由`TaskVO`和`ResourceVO`组合而成，相关类如示例8.25、示例8.26和示例8.27所示。

# Example 8.25 TaskResourceVO Class  

public class TaskResourceVO { public String projectId; public String taskId; public String name; public String description; public Date startDate; public Date endDate; public ResourceVO assignedResource;  

public class TaskResourceVO { public String projectId; public String taskId; public String name; public String description; public Date startDate; public Date endDate; public ResourceVO assignedResource;

public TaskResourceVO(String projectId, String taskId, String name, String description, Date startDate, Date endDate, ResourceVO assignedResource) { this.projectId $=$ projectId; this.taskId $=$ taskId; this.assignedResource $=$ assignedResource;  

public TaskResourceVO(String projectId, String taskId, String name, String description, Date startDate, Date endDate, ResourceVO assignedResource) { this.projectId = projectId; this.taskId = taskId; this.assignedResource = assignedResource;

# Example 8.26 TaskVO Class  

public class TaskVO { public String projectId; public String taskId; public String name; public String description; public Date startDate; public Date endDate; public assignedResourceId;  

public class TaskVO { public String projectId; public String taskId; public String name; public String description; public Date startDate; public Date endDate; public assignedResourceId;

public TaskVO(String projectId, String taskId, String name, String description, Date startDate, Date endDate, String assignedResourceId) { this.projectId $=$ projectId; this.taskId $=$ taskId; this.assignedResource $=$ assignedResource;  

public TaskVO(String projectId, String taskId, String name, String description, Date startDate, Date endDate, String assignedResourceId) { this.projectId = projectId; this.taskId = taskId; this.assignedResource = assignedResource;

# Example 8.27 ResourceVO Class  

public class ResourceVO { public String resourceId; public String resourceName; public String resourceEmail; public ResourceVO (String resourceId, String resourceName, String resourceEmail, ...) { this.resourceId $=$ resourceId; this.resourceName $=$ resourceName; this.resourceEmail $=$ resourceEmail;  

public class ResourceVO { public String resourceId; public String resourceName; public String resourceEmail; public ResourceVO (String resourceId, String resourceName, String resourceEmail, ...) { this.resourceId $=$ resourceId; this.resourceName $=$ resourceName; this.resourceEmail $=$ resourceEmail;  

（根据规则3，代码块保持原样不翻译）

The ProjectDetailsAssembler class that assembles the ProjectDetailsData object is listed in Example 8.28.  

组装 `ProjectDetailsData` 对象的 `ProjectDetailsAssembler` 类如示例 8.28 所示。

# Example 8.28 Implementing the Value Object Assembler  

public class ProjectDetailsAssembler implements javax.ejb.SessionBean { public ProjectDetailsData getData(String projectId){ // Construct the composite value object ProjectDetailsData pData $=$ new ProjectDetailsData(); //get the project details; ProjectHome projectHome $=$ ServiceLocator.getInstance().getHome( "Project", ProjectEntityHome.class); ProjectEntity project $=$  

public class ProjectDetailsAssembler implements javax.ejb.SessionBean { public ProjectDetailsData getData(String projectId){ // 构造组合值对象 ProjectDetailsData pData $=$ new ProjectDetailsData(); //获取项目详情 ProjectHome projectHome $=$ ServiceLocator.getInstance().getHome( "Project", ProjectEntityHome.class); ProjectEntity project $=$

projectHome.findByPrimaryKey(projectId);   
ProjectVO projVO $=$ project.getData();   
// Add Project Info to ProjectDetailsData   
pData.projectData $=$ projVO;   
//get the project manager details;   
ProjectManagerHome projectManagerHome $=$ ServiceLocator.getInstance().getHome( "ProjectManager", ProjectEntityHome.class);   
ProjectManagerEntity projectManager $=$ projectManagerHome.findByPrimaryKey( projVO.managerId);   
ProjectManagerVO projMgrVO $=$ projectManager.getData();   
// Add ProjectManager info to ProjectDetailsData   
pData.projectManagerData $=$ projMgrVO;   
// Get list of TaskVOs from the Project   
Collection projTaskList $=$ project.getTasksList();   
// construct a list of TaskResourceVOs   
ArrayList listOfTasks $=$ new ArrayList();   
Iterator taskIter $=$ projTaskList.iterator();   
while (taskIter.hasNext()) { TaskVO task $=$ (TaskVO) taskIter.next(); //get the Resource details; ResourceHome resourceHome $=$ ServiceLocator.getInstance().getHome( "Resource", ResourceEntityHome.class); ResourceEntity resource $=$ resourceHome.findByPrimaryKey( task.assignedResourceId); ResourceVO resVO $=$ resource.getResourceData(); // construct a new TaskResourceVO using Task // and Resource data TaskResourceVO trVO $=$ new TaskResourceVO(  

projectHome.findByPrimaryKey(projectId);  
ProjectVO projVO = project.getData();  
// 将项目信息添加至ProjectDetailsData  
pData.projectData = projVO;  
// 获取项目经理详情  
ProjectManagerHome projectManagerHome = ServiceLocator.getInstance().getHome( "ProjectManager", ProjectEntityHome.class);  
ProjectManagerEntity projectManager = projectManagerHome.findByPrimaryKey( projVO.managerId);  
ProjectManagerVO projMgrVO = projectManager.getData();  
// 将项目经理信息添加至ProjectDetailsData  
pData.projectManagerData = projMgrVO;  
// 从项目中获取TaskVO列表  
Collection projTaskList = project.getTasksList();  
// 构建TaskResourceVO列表  
ArrayList listOfTasks = new ArrayList();  
Iterator taskIter = projTaskList.iterator();  
while (taskIter.hasNext()) { TaskVO task = (TaskVO) taskIter.next(); //获取资源详情 ResourceHome resourceHome = ServiceLocator.getInstance().getHome( "Resource", ResourceEntityHome.class); ResourceEntity resource = resourceHome.findByPrimaryKey( task.assignedResourceId); ResourceVO resVO = resource.getResourceData(); // 使用任务和资源数据构建新的TaskResourceVO TaskResourceVO trVO = new TaskResourceVO(

task.projectId, task.taskId, task.name, task.description, task.startDate, task.endDate, resVO); // add TaskResourceVO to the list listOfTasks.add(trVO); // add list of tasks to ProjectDetailsData pData.listOfTasks $=$ listOfTasks; add any other data to the value object // return the composite value object return pData;  

task.projectId, task.taskId, task.name, task.description, task.startDate, task.endDate, resVO); // 将TaskResourceVO添加到列表  
listOfTasks.add(trVO); // 将任务列表添加到ProjectDetailsData  
pData.listOfTasks = listOfTasks;  
// 向值对象添加其他数据  
// 返回组合值对象  
return pData;

# Related Patterns  

# Value Object  

The Value Object Assembler uses the Value Object pattern in order to create and transport value objects to the client. The value objects created carry the data representing the application model from the business tier to the clients requesting the data.  

值对象组装器采用**值对象模式**来创建并向客户端传输值对象。这些被创建的值对象承载着代表应用模型的数据，从业务层传递至请求数据的客户端。

# Composite Entity  

The Composite Entity pattern promotes a coarse-grained entity bean design, where entities can produce composite value objects similar to the one produced by the Value Object Assembler. However, the Value Object Assembler is more applicable when the composite value object constructed is derived from a number of components (session beans, entity beans, DAOs, and so forth), whereas the Composite Entity pattern constructs the value object from its own data (that is, a single entity bean).  

组合实体模式提倡一种粗粒度的实体Bean设计，其中实体能够生成类似于值对象装配器所生成的组合值对象。然而，当构建的组合值对象源自多个组件（会话Bean、实体Bean、DAO等）时，值对象装配器更为适用；而组合实体模式则是从自身数据（即单个实体Bean）构建值对象。

# Session Facade  

The Value Object Assembler is typically implemented as a stateless session bean. As such, it could be viewed as a limited special application of the  

值对象组装器通常实现为无状态会话Bean。因此，可将其视为一种有限的特例应用。

Session Facade pattern. More importantly, Value Object Assembler constructs composite value objects that are immutable. Therefore, the client receiving this composite value object can only use the data for its presentation and processing purposes. The client cannot update the value object. If the client needs to update the business objects that derive the composite value object, it may have to access the Session Facade (session bean) that provides that business service.  

会话外观模式。更重要的是，值对象组装器会构造不可变的复合值对象。因此，客户端接收到的这个复合值对象仅能用于展示和处理目的，而无法更新该值对象。若客户端需要更新派生该复合值对象的业务对象，则必须访问提供该业务服务的会话外观（Session Bean）。

# Data Access Object  

A possible strategy for the Value Object Assembler involves obtaining data for the composite value object from the persistent store without enterprise bean involvement. The Data Access Object pattern can be applied, thus leveraging its benefits to provide persistent storage access to the Value Object Assembler.  

值对象组装器的一种可行策略是**在不涉及企业级Bean的情况下**从持久化存储中获取组合值对象的数据。可采用**数据访问对象模式**，从而利用其优势为值对象组装器提供持久化存储访问能力。

# Service Locator  

The Value Object Assembler needs to locate and use various business objects. The Service Locator pattern can be used in conjunction with the Value Object Assembler pattern whenever a business object or a service needs to be located.  

值对象组装器需要定位并使用各种业务对象。每当需要定位业务对象或服务时，可将服务定位器模式与值对象组装器模式结合使用。

# Value List Handler  

# Context  

The client requires a list of items from the service for presentation. The number of items in the list is unknown and can be quite large in many instances.  

客户端需要从服务端获取项目列表用于展示。该列表的项目数量未知，且在多数情况下可能非常庞大。

# Problem  

Most J2EE applications have a search and query requirement to search and list certain data. In some cases, such a search and query operation could yield results that can be quite large. It is impractical to return the full result set when the client's requirements are to traverse the results, rather than process the complete set. Typically, a client uses the results of a query for read-only purposes, such as displaying the result list. Often, the client views only the first few matching records, and then may discard the remaining records and attempt a new query. The search activity often does not involve an immediate transaction on the matching objects. The practice of getting a list of values represented in entity beans by calling an ejbFind() method, which returns a collection of remote objects, and then calling each entity bean to get the value, is very network expensive and is considered a bad practice.  

大多数J2EE应用都具备搜索查询需求，用于检索并列出特定数据。在某些情况下，此类搜索查询操作可能返回极为庞大的结果集。当客户端需求仅是遍历结果而非处理完整数据集时，返回全部结果显然不切实际。通常，客户端仅将查询结果用于只读目的（例如展示结果列表），往往仅查看前几条匹配记录后便可能丢弃剩余记录并尝试新查询。这类搜索行为通常不会立即对匹配对象执行事务操作。  

通过调用`ejbFind()`方法获取实体Bean的值对象列表（该方法返回远程对象集合），再逐一调用每个实体Bean获取值的做法，会产生极高的网络开销，被视为不良实践。

There are consequences associated with using EJB finder methods that result in large results sets. Every container implementation has a certain amount of finder method overhead for creating a collection of EJBObject references. Finder method behavior performance varies, depending on a vendor's container implementation. According to the EJB specification, a container may invoke ejbActivate() methods on entities found by a finder method. At a minimum, a finder method returns the primary keys of the matching entities, which the container returns to the client as a collection of EJBObject references. This behavior applies for all container implementations. Some container implementations may introduce additional finder method overhead by associating the entity bean instances to these EJBObject instances to give the client access to those entity beans. However, this is a poor use of resources if the client is not interested in accessing the bean or invoking its methods. This overhead can significantly impede application performance if the application includes queries that produce many matching results.  

使用EJB查找方法获取大型结果集会带来相应后果。所有容器实现都会因创建EJBObject引用集合而产生一定的查找方法开销。查找方法的性能表现因供应商的容器实现而异。根据EJB规范，容器可能对查找方法找到的实体调用`ejbActivate()`方法。至少，查找方法会返回匹配实体的主键，容器将这些主键作为EJBObject引用集合返回给客户端。这一行为适用于所有容器实现。某些容器实现可能通过将实体Bean实例与这些EJBObject实例关联来引入额外的查找方法开销，以便客户端能访问这些实体Bean。但如果客户端并不打算访问Bean或调用其方法，这种资源利用方式效率低下。当应用程序包含产生大量匹配结果的查询时，此类开销会显著影响应用性能。

# Forces  

The application client needs an efficient query facility to avoid having to call the entity bean's ejbFind() method and invoking each remote object returned. A server-tier caching mechanism is needed to serve clients that cannot receive and process the entire results set. A query that is repeatedly executed on reasonably static data can be optimized to provide faster results. This depends on the application and on the implementation of this pattern. EJB finder methods are not suitable for browsing entire tables in the database or for searching large result sets from a table. Finder methods may have considerable overhead when used to find large numbers of result objects. The container may create a large number of infrastructure objects to facilitate the finders. EJB finder methods are not suitable for caching results. The client may not be able to handle the entire result set in a single call. If so, the client may need server-side caching and navigation functions to traverse the result set. EJB finder methods have predetermined query constructs and offer minimum flexibility. The EJB specification 2.0 allows a query language, EJB QL, for container-managed entity beans. EJB QL makes it easier to write portable finders and offers greater flexibility for querying. Client wants to scroll forward and backward within a result set.  

应用客户端需要一个高效的查询机制，以避免频繁调用实体Bean的`ejbFind()`方法并逐一处理返回的远程对象。对于无法一次性接收和处理完整结果集的客户端，需要引入服务层缓存机制。针对相对静态数据重复执行的查询可进行优化以提升响应速度，具体效果取决于应用程序及该模式的**实现**。  

EJB查找方法不适合用于浏览数据库整表或检索表中的大型结果集。当用于查找大量结果对象时，查找方法可能产生显著开销，容器可能需要创建大量基础设施对象来支持查找操作。EJB查找方法也不适合缓存结果——客户端可能无法通过单次调用处理完整结果集，此时需要服务端缓存和导航功能来实现结果集遍历。  

EJB查找方法采用预定义的查询结构，灵活性极为有限。EJB 2.0规范引入了针对容器管理实体Bean的查询语言EJB QL，该语言能简化可移植查找器的编写，并提供更强的查询灵活性。客户端要求能够在结果集中实现前后滚动浏览。

# Solution  

# Use a Value List Handler to control the search, cache the results, and provide the results to the client in a result set whose size and traversal meets the client's requirements.  

This pattern creates a ValueListHandler to control query execution functionality and results caching. The ValueListHandler directly accesses a DAO that can execute the required query. The ValueListHandler stores the results obtained from the DAO as a collection of value objects. The client requests the ValueListHandler to provide the query results as needed. The ValueListHandler implements an Iterator pattern [GoF] to provide the solution.  

该模式创建一个ValueListHandler来控制查询执行功能及结果缓存。ValueListHandler直接访问能够执行所需查询的DAO。ValueListHandler将从DAO获取的结果存储为值对象集合。客户端根据需要请求ValueListHandler提供查询结果。ValueListHandler通过实现迭代器模式[GoF]来提供解决方案。

# Structure  

The class diagram in Figure 8.29 illustrates the Value List Handler pattern.  

图8.29中的类图展示了值列表处理器（Value List Handler）模式。

# Figure 8.29. Value List Handler Class Diagram  

![](images/a807222cf8aba0168176d53ac8fd1f03ff3b7858b6500fbe25b4b65859178d0c.jpg)  

# Participants and Collaborations  

The sequence diagram in Figure 8.30 shows the interactions for the Value List Handler.  

图8.30中的序列图展示了值列表处理器（Value List Handler）的交互过程。

![](images/b8c45f9fe3e4baf96035650bfd0b64b8ba8b7b7732b8f48d96c2aa8168d5c729.jpg)  
Figure 8.30. Value List Handler Sequence Diagram  

图 8.30. 值列表处理器时序图

# ValueListIterator  

This interface may provide iteration facility with the following example methods:  

该接口可通过以下示例方法提供迭代功能：

getSize() obtains the size of the result set. • getCurrentElement()obtains the current value object from the list. getPreviousElements(int howMany) obtains a collection of value objects that are in the list prior to the current element. getNextElements(int howMany) obtains a collection of value objects that are in the list after the current element. resetIndex() resets the index to the start of the list.  

`getSize()` 获取结果集的大小。  
• `getCurrentElement()` 从列表中获取当前值对象。  
`getPreviousElements(int howMany)` 获取列表中位于当前元素之前的若干值对象的集合。  
`getNextElements(int howMany)` 获取列表中位于当前元素之后的若干值对象的集合。  
`resetIndex()` 将索引重置到列表起始位置。

Depending on the need, other convenience methods can be included to be part of the ValueListIterator interface.  

根据需求，可在ValueListIterator接口中加入其他便捷方法。

# ValueListHandler  

This is a list handler object that implements the ValueListIterator interface. The ValueListHandler executes the required query when requested by the client. The ValueListHandler obtains the query results, which it manages in a privately held collection represented by the ValueList object. The ValueListHandler creates and manipulates the ValueList collection. When the client requests the results, the ValueListHandler obtains the value objects from the cached ValueList, creates a new collection of value objects, serializes the collection, and sends it back to the client. The ValueListHandler also tracks the current index and size of the list.  

这是一个实现了`ValueListIterator`接口的列表处理器对象。`ValueListHandler`在客户端请求时执行所需的查询操作，获取查询结果并将其托管在由`ValueList`对象表示的私有集合中。该处理器负责创建和操作`ValueList`集合，当客户端请求结果时，会从缓存的`ValueList`中获取值对象、创建新的值对象集合、序列化该集合并将其返回给客户端。`ValueListHandler`还会追踪列表的当前索引和大小。

# DataAccessObject  

The ValueListHandler can make use of a DataAccessObject to keep separate the implementation of the database access. The DataAccessObject provides a simple API to access the database (or any other persistent store), execute the query, and retrieve the results.  

ValueListHandler 可通过 DataAccessObject 实现数据库访问逻辑的分离。DataAccessObject 提供简洁的 API 用于访问数据库（或任何持久化存储）、执行查询并获取结果集。

# ValueList  

The ValueList is a collection (a list) that holds the results of the query. The results are stored as value objects. If the query fails to return any matching results, then this list is empty. The ValueListHandler session bean caches ValueList to avoid repeated, unnecessary execution of the query.  

ValueList 是一个用于存储查询结果的集合（列表）。这些结果以值对象的形式保存。若查询未返回任何匹配结果，则该列表为空。ValueListHandler 会话 Bean 会对 ValueList 进行缓存，以避免重复执行不必要的查询。

# ValueObject  

The ValueObject represents an object view of the individual record from the query's results. It is an immutable serializable object that provides a placeholder for the data attributes of each record.  

`ValueObject`表示查询结果中单条记录的对象视图。它是一个不可变的可序列化对象，为每条记录的数据属性提供占位容器。

# Strategies  

# Java Object Strategy  

The ValueListHandler can be implemented as an arbitrary Java object. In this case, the ValueListHandler can be used by any client that needs the listing functionality. For applications that do not use enterprise beans, this strategy is useful. For example, simpler applications may be built using servlets, JSPs, Business Delegates, and DAOs. In this scenario, the Business Delegates can use a ValueListHandler implemented as a Java object to obtain list of values.  

ValueListHandler 可被实现为任意 Java 对象。在此情况下，任何需要列表功能的客户端均可使用该 ValueListHandler。对于不使用企业级 Bean 的应用程序，此策略尤为实用。例如，较简单的应用程序可通过 Servlet、JSP、业务委托和 DAO 构建。在此场景中，业务委托可通过实现为 Java 对象的 ValueListHandler 来获取值列表。

# Stateful Session Bean Strategy  

When an application uses enterprise beans in the business tier, it may be preferable to implement a session bean that uses the ValueListHandler. In this case, the session bean simply fronts an instance of a ValueListHandler. Thus, the session bean may be implemented as a stateful session bean to hold on to the list handler as its state, and thus may simply act as a facade (see “Session Facade”) or as a pro  

当应用程序在业务层使用企业级Bean时，采用**会话Bean**配合**ValueListHandler**的实现方式可能更为适宜。此时，会话Bean仅作为ValueListHandler实例的前端封装。因此，该会话Bean可被实现为**有状态会话Bean**，将列表处理器作为其状态持有，从而仅需充当门面（参见“会话门面”模式）或代理角色。

# Consequences  

# Provides Alternative to EJB Finders for Large Queries  

Typically, an EJB finder method is a resource-intensive and an expensive way of obtaining a list of items, since it involves a number of EJBObject references. The Value List Handler implements a session bean that uses a DAO to perform the query and to create a collection of value objects that match the query criteria. Because value objects have relatively low overhead compared to EJBObject references and their associated infrastructure, this pattern provides benefits when application clients require queries resulting in large result sets.  

通常，EJB查找方法是一种资源密集型且代价高昂的获取项目列表的方式，因为它涉及大量EJBObject引用。值列表处理器通过实现一个会话Bean来使用DAO执行查询，并创建符合查询条件的值对象集合。由于相比EJBObject引用及其关联基础设施，值对象的开销相对较低，因此当应用客户端需要返回大型结果集的查询时，该模式能显著提升性能。

# Caches Query Results on Server Side  

The result set obtained from a query execution needs to be cached when a client must display the results in small subsets rather than in one large list. However, not all browser-based clients can perform such caching. When they cannot, the server must provide this functionality. The Value List Handler pattern provides a caching facility in the Value List Handler session bean to hold the result set obtained from a query execution. The result set is a collection of value objects that can be serialized if required.  

当客户端需要以小批量子集而非单一大型列表形式展示查询结果时，必须对查询执行获得的结果集进行缓存。然而，并非所有基于浏览器的客户端都具备此类缓存能力。若客户端无法实现缓存，则需由服务器提供该功能。值列表处理器（Value List Handler）模式通过在会话Bean中实现缓存机制来存储查询执行获得的结果集。该结果集由一组可序列化的值对象（Value Object）构成。

When the client requests a collection, or a subset of a collection, the handler bean returns the requested results as a serialized collection of value objects. The client receives the collection and now has a local copy of the requested information, which the client can display or process. When the client needs an additional subset of the results, it requests the handler to return another serialized collection containing the required results. The client can process the query results in smaller, manageable chunks. The handler bean also provides the client with navigation facilities (previous and next) so that the results may be traversed forward and backward as necessary.  

当客户端请求一个集合或集合的子集时，处理程序Bean会以值对象的序列化集合形式返回请求结果。客户端接收该集合后即获得所请求信息的本地副本，可用于展示或处理。当客户端需要获取结果的额外子集时，会请求处理程序返回另一个包含所需结果的序列化集合。通过这种方式，客户端能以更小、更易管理的块状形式处理查询结果。该处理程序Bean还为客户提供导航功能（上一页/下一页），使得结果集可按需向前或向后遍历。

# Provides Better Querying Flexibility  

Adding a new query may require creating a new finder method or modifying an existing method, especially when using bean-managed entity beans. (With bean-managed entity beans, the developer implements the finder methods in the bean implementation.) With a container-managed entity bean, the deployer specifies the entity bean finder methods in the bean's deployment descriptor. Changes to a query for a container-managed bean require changes to the finder method specification in the deployment descriptor. Therefore, finder methods are ill-suited to handle query requirements that change dynamically. You can implement a Value List Handler to be more flexible than EJB finder methods by providing ad hoc query facilities, constructing runtime query arguments using template methods, and so forth. In other words, a Value List Handler developer can implement intelligent searching and caching algorithms without being limited by the finder methods.  

新增查询可能需要创建新的查找器方法或修改现有方法，尤其是在使用Bean管理的实体Bean时。（对于Bean管理的实体Bean，开发者需在Bean实现中编写查找器方法。）而对于容器管理的实体Bean，部署者需在Bean的部署描述符中指定实体Bean查找器方法。若需修改容器管理Bean的查询，则必须调整部署描述符中的查找器方法定义。因此，查找器方法难以适应动态变化的查询需求。通过实现值列表处理器（Value List Handler），可提供比EJB查找器方法更灵活的解决方案——例如支持即席查询、利用模板方法构建运行时查询参数等。换言之，值列表处理器的开发者能够实现智能搜索和缓存算法，而无需受限于查找器方法的约束。

# Improves Network Performance  

Network performance may improve because only requested data, rather than all data, is shipped (serialized) to the client on an as-needed basis. If the client displays the first few results and then abandons the query, the network bandwidth is not wasted, since the data is cached on the server side and never sent to the client. However, if the client processes the entire result set, it makes multiple remote calls to the server for the result set. When the client knows in advance that it needs the entire result set, the handler bean can provide a method that sends the client the entire result set in one method call, and the pattern's caching feature is not used.  

网络性能可能得到提升，因为仅按需将请求的数据（而非全部数据）序列化传输至客户端。若客户端仅展示前几条结果便中止查询，由于数据缓存在服务端且从未发送至客户端，网络带宽不会被浪费。然而，若客户端需处理完整结果集，则需多次远程调用服务端获取数据。当客户端预先明确需要完整结果集时，handler bean可提供通过单次方法调用返回全部结果集的方法，此时该模式的缓存特性将不被启用。

# Allows Deferring Entity Bean Transactions  

Caching results on the server side and minimizing finder overhead may improve transaction management. When the client is ready to further process an entity bean, it accesses the bean within a transaction context defined by the use case. For example, a query to display a list of books uses a Value List Handler to obtain the list. When the user wants to view a book in detail, it involves the book's entity bean in a transaction.  

在服务器端缓存结果并最小化查找器开销可优化事务管理。当客户端准备进一步处理实体Bean时，它会根据用例定义的事务上下文访问该Bean。例如，显示书籍列表的查询会通过值列表处理器获取列表；当用户需要查看书籍详情时，则会在事务中调用该书籍的实体Bean。

# Sample Code  

# Implementing the Value List Handler as a Java Object  

Consider an example where a list of Project business objects are to be retrieved and displayed. The Value List Handler pattern can be applied in this case. The sample code for this implementation is listed in Example 8.29 as ProjectListHandler, which is responsible to provide the list of Projects. This class extends the ValueListHandler base class, which provides the generic iteration functionality for all Value List Handler implementations in this application. The ValueListHandler sample code is listed in Example 8.30. The ValueListHandler implements the generic iterator interface ValueListIterator, which is shown in Example 8.32. The relevant code sample from the data access object ProjectDAO, used by ValueListHandler to execute the query and obtain matching results, is shown in Example 8.31.  

考虑一个需要检索并显示项目业务对象列表的示例。这种情况下可以应用值列表处理器模式。示例8.29列出了该实现的示例代码ProjectListHandler，其职责是提供项目列表。该类继承自ValueListHandler基类，该基类为应用中所有值列表处理器实现提供了通用的迭代功能。值列表处理器的示例代码如示例8.30所示。ValueListHandler实现了通用迭代器接口ValueListIterator（如示例8.32所示）。示例8.31展示了数据访问对象ProjectDAO的相关代码片段，ValueListHandler通过该DAO执行查询并获取匹配结果。

# Example 8.29 Implementing Value List Handler Pattern  

package corepatterns.apps.psa.handlers;  

package corepatterns.apps.psa.handlers;  

（注：根据规则3，代码块和路径名保持原样不翻译）

import java.util.\*;   
import corepatterns.apps.psa.dao.\*;   
import corepatterns.apps.psa.util.\*;   
import corepatterns.apps.psa.core.\*;  

import java.util.\*;   
import corepatterns.apps.psa.dao.\*;   
import corepatterns.apps.psa.util.\*;   
import corepatterns.apps.psa.core.\*;

public class ProjectListHandler extends ValueListHandler {  

public class ProjectListHandler extends ValueListHandler {

private ProjectDAO dao $=$ null; // use ProjectVO as a template to determine // search criteria private ProjectVO projectCriteria $=$ null;  

private ProjectDAO dao = null; // 使用ProjectVO作为模板确定  
// 搜索条件  
private ProjectVO projectCriteria = null;

// Client creates a ProjectVO instance, sets the // values to use for search criteria and passes // the ProjectVO instance as projectCriteria // to the constructor and to setCriteria() method  

// 客户端创建ProjectVO实例，设置用于搜索条件的值，并将该ProjectVO实例作为projectCriteria传递给构造函数和setCriteria()方法

public ProjectListHandler(ProjectVO projectCriteria)   
throws ProjectException, ListHandlerException { try { this.projectCriteria $=$ projectCriteria; this.dao $=$ PSADAOFactory.getProjectDAO(); executeSearch(); } catch (Exception $\ominus$ ) { // Handle exception, throw ListHandlerException   
public void setCriteria(ProjectVO projectCriteria) { this.projectCriteria $=$ projectCriteria;   
// executes search. Client can invoke this   
// provided that the search criteria has been   
// properly set. Used to perform search to refresh   
// the list with the latest data.   
public void executeSearch()   
throws ListHandlerException { try { if (projectCriteria $==$ null) { throw new ListHandlerException( "Project Criteria required..."); } List resultsList $=$ dao.executeSelect(projectCriteria); setList(resultsList); } catch (Exception e) { // Handle exception, throw ListHandlerException  

public ProjectListHandler(ProjectVO projectCriteria)   
throws ProjectException, ListHandlerException { try { this.projectCriteria = projectCriteria; this.dao = PSADAOFactory.getProjectDAO(); executeSearch(); } catch (Exception e) { // 处理异常，抛出ListHandlerException   
public void setCriteria(ProjectVO projectCriteria) { this.projectCriteria = projectCriteria;   
// 执行搜索。客户端可在确保搜索条件已正确设置后调用此方法  
// 用于执行搜索以刷新列表数据  
public void executeSearch()   
throws ListHandlerException { try { if (projectCriteria == null) { throw new ListHandlerException( "需要项目搜索条件..."); } List resultsList = dao.executeSelect(projectCriteria); setList(resultsList); } catch (Exception e) { // 处理异常，抛出ListHandlerException

The Value List Handler is a generic iterator class that provides the iteration functionality.  

值列表处理器（Value List Handler）是一个提供迭代功能的通用迭代器类。

Example 8.30 Implementing Generic ValueListHandler class  

示例 8.30 实现通用 ValueListHandler 类

package corepatterns.apps.psa.util;  

package corepatterns.apps.psa.util;

import java.util.\*;   
public class ValueListHandler   
implements ValueListIterator { protected List list; protected ListIterator listIterator; public ValueListHandler() { }   
protected void setList(List list)   
throws IteratorException { this.list $=$ list; if(list ! $=$ null) listIterator $=$ list.listIterator(); else throw new IteratorException("List empty");   
public Collection getList(){ return list;   
public int getSize() throws IteratorException{ int size $\begin{array}{r l r}{\mathrm{~\boldmath~\omega~}}&{{}=}&{0}\end{array}$ ; if (list ! $=$ null) size $=$ list.size(); else throw new IteratorException(...); //No Data return size;   
}   
public Object getCurrentElement()   
throws IteratorException { Object obj $=$ null; // Will not advance iterator if (list ! $=$ null) { int currIndex $=$ listIterator.nextIndex(); obj $=$ list.get(currIndex);   
else throw new IteratorException(...);   
return obj;   
public List getPreviousElements(int count)   
throws IteratorException { int $\begin{array}{r l r}{\perp}&{{}=}&{0}\end{array}$ ; Object object $=$ null; LinkedList list $=$ new LinkedList(); if (listIterator ! $=$ null) { while (listIterator.hasPrevious() && (i <   
count)){ object $=$ listIterator.previous(); list.add(object); $\dot{\ I}++$ ; } }// end if else throw new IteratorException(...); // No data return list;   
}   
public List getNextElements(int count)   
throws IteratorException { int $\begin{array}{r l r}{\perp}&{{}=}&{0}\end{array}$ ; Object object $=$ null; LinkedList list $=$ new LinkedList(); if(listIterator ! $=$ null){ while(  listIterator.hasNext() && (i < count) ){ object $=$ listIterator.next(); list.add(object); $\dot{\ I}++$ ; } } // end if else throw new IteratorException(...); // No data return list;   
}   
public void resetIndex() throws IteratorException{ if(listIterator ! $=$ null){ listIterator $=$ list.ListIterator();  

import java.util.\*;   
public class ValueListHandler   
implements ValueListIterator { protected List list; protected ListIterator listIterator; public ValueListHandler() { }   
protected void setList(List list)   
throws IteratorException { this.list $=$ list; if(list ! $=$ null) listIterator $=$ list.listIterator(); else throw new IteratorException("List empty");   
public Collection getList(){ return list;   
public int getSize() throws IteratorException{ int size $\begin{array}{r l r}{\mathrm{~\boldmath~\omega~}}&{{}=}&{0}\end{array}$ ; if (list ! $=$ null) size $=$ list.size(); else throw new IteratorException(...); //No Data return size;   
}   
public Object getCurrentElement()   
throws IteratorException { Object obj $=$ null; // Will not advance iterator if (list ! $=$ null) { int currIndex $=$ listIterator.nextIndex(); obj $=$ list.get(currIndex);   
else throw new IteratorException(...);   
return obj;   
public List getPreviousElements(int count)   
throws IteratorException { int $\begin{array}{r l r}{\perp}&{{}=}&{0}\end{array}$ ; Object object $=$ null; LinkedList list $=$ new LinkedList(); if (listIterator ! $=$ null) { while (listIterator.hasPrevious() && (i <   
count)){ object $=$ listIterator.previous(); list.add(object); $\dot{\ I}++$ ; } }// end if else throw new IteratorException(...); // No data return list;   
}   
public List getNextElements(int count)   
throws IteratorException { int $\begin{array}{r l r}{\perp}&{{}=}&{0}\end{array}$ ; Object object $=$ null; LinkedList list $=$ new LinkedList(); if(listIterator ! $=$ null){ while(  listIterator.hasNext() && (i < count) ){ object $=$ listIterator.next(); list.add(object); $\dot{\ I}++$ ; } } // end if else throw new IteratorException(...); // No data return list;   
}   
public void resetIndex() throws IteratorException{ if(listIterator ! $=$ null){ listIterator $=$ list.ListIterator();

else throw new IteratorException(...); // No data  

否则抛出 IteratorException(...); // 无数据

Example 8.31 ProjectDAO class   
ackage corepatterns.apps.psa.dao;   
ublic class ProjectDAO {   
final private String tableName $=$ "PROJECT"; // select statement uses fields final private String fields $=$ "project_id, name," "project_manager_id, start_date, end_date, " $^+$ " started, completed, accepted, acceptedDate," " customer_id, description, status"; // the methods relevant to the ValueListHandler // are shown here.   
// See Data Access Object pattern for other details.   
private List executeSelect(ProjectVO projCriteria) throws SQLException { Statement stmt $=$ null; List list $=$ null; Connection con $=$ getConnection(); StringBuffer selectStatement $=$ new StringBuffer(); selectStatement.append("SELECT " $^+$ fields $^+$ " FROM " $^+$ tableName $^+$ "where $\beth=\beth^{\mathfrak{n}}$ ); // append additional conditions to where clause // depending on the values specified in // projCriteria if (projCriteria.projectId ! $=$ null) { selectStatement.append (" AND PROJECT_ID $=$ '" + projCriteria.projectId $^+$ "'"); } // check and add other fields to where clause   
try { stmt $=$ con.prepareStatement(selectStatement); stmt.setString(1, resourceID); ResultSet rs $=$ stmt.executeQuery(); list $=$ prepareResult(rs); stmt.close();   
finally { con.close();   
return list;   
private List prepareResult(ResultSet rs)   
throws SQLException { ArrayList list $=$ new ArrayList(); while(rs.next()) { int $\begin{array}{r l r}{\perp}&{{}=}&{1}\end{array}$ ; ProjectVO proj $=$ new ProjectVO(rs.getString $(\mathrm{~i~}{+}+)$ ); proj.projectName $=$ rs.getString( $\left({\begin{array}{r}{\mathrm{j}++}\end{array}}\right)$ ; proj.managerId $=$ rs.getString( $(\mathrm{\small~i~}++)$ ; proj.startDate $=$ rs.getDate( $\dot{\operatorname{1}}++\operatorname{)}$ ; proj.endDate $=$ rs.getDate( $(\mathrm{~i~}++)$ ; proj.started $=$ rs.getBoolean $(\mathrm{~i~}{+}+)$ ; proj.completed $=$ rs.getBoolean( $\mathrm{i}++)$ ; proj.accepted $=$ rs.getBoolean( $(\mathrm{\small~i~}++)$ ; proj.acceptedDate $=$ rs.getDate( $\mathrm{i}++)$ ; proj.customerId $=$ rs.getString( $\mathrm{i}++)$ ; proj.projectDescription $=$ rs.getString $(\mathrm{\small{~i~}}++)$ ; proj.projectStatus $=$ rs.getString( $\left({\begin{array}{r l}{\mathrm{i}++}\end{array}}\right)$ ; list.add(proj); return list;   
}  

示例 8.31 ProjectDAO类  
```java
package corepatterns.apps.psa.dao;

public class ProjectDAO {
    final private String tableName = "PROJECT";
    // select语句使用的字段
    final private String fields = "project_id, name," 
        + "project_manager_id, start_date, end_date, " 
        + " started, completed, accepted, acceptedDate,"
        + " customer_id, description, status";
    
    // 此处展示与ValueListHandler相关的方法
    // 其他细节请参阅数据访问对象模式
    
    private List executeSelect(ProjectVO projCriteria) throws SQLException {
        Statement stmt = null;
        List list = null;
        Connection con = getConnection();
        StringBuffer selectStatement = new StringBuffer();
        selectStatement.append("SELECT " + fields + " FROM " + tableName + "where 1=1 ");
        
        // 根据projCriteria中指定的值
        // 向where子句追加附加条件
        if (projCriteria.projectId != null) {
            selectStatement.append(" AND PROJECT_ID = '" + projCriteria.projectId + "'");
        }
        // 检查并添加其他字段到where子句
        
        try {
            stmt = con.prepareStatement(selectStatement);
            stmt.setString(1, resourceID);
            ResultSet rs = stmt.executeQuery();
            list = prepareResult(rs);
            stmt.close();
        } finally {
            con.close();
        }
        return list;
    }
    
    private List prepareResult(ResultSet rs) throws SQLException {
        ArrayList list = new ArrayList();
        while(rs.next()) {
            int i = 1;
            ProjectVO proj = new ProjectVO(rs.getString(i++));
            proj.projectName = rs.getString(i++);
            proj.managerId = rs.getString(i++);
            proj.startDate = rs.getDate(i++);
            proj.endDate = rs.getDate(i++);
            proj.started = rs.getBoolean(i++);
            proj.completed = rs.getBoolean(i++);
            proj.accepted = rs.getBoolean(i++);
            proj.acceptedDate = rs.getDate(i++);
            proj.customerId = rs.getString(i++);
            proj.projectDescription = rs.getString(i++);
            proj.projectStatus = rs.getString(i++);
            list.add(proj);
        }
        return list;
    }
}
```

# Example 8.32 ValueListIterator class  

package corepatterns.apps.psa.util;   
import java.util.List;  

package corepatterns.apps.psa.util;  
import java.util.List;

public interface ValueListIterator { public int getSize() throws IteratorException; public Object getCurrentElement() throws IteratorException; public List getPreviousElements(int count) throws IteratorException; public List getNextElements(int count) throws IteratorException; public void resetIndex() throws IteratorException; // other common methods as required  

public interface ValueListIterator { public int getSize() throws IteratorException; public Object getCurrentElement() throws IteratorException; public List getPreviousElements(int count) throws IteratorException; public List getNextElements(int count) throws IteratorException; public void resetIndex() throws IteratorException; // 其他必要公共方法

# Related Patterns  

# Iterator [GoF]  

This Value List Handler pattern is based on Iterator pattern, described in the GoF book, Design Patterns: Elements of Reusable Object-Oriented Software.  

该值列表处理器模式基于迭代器模式，其设计思想源自GoF著作《设计模式：可复用面向对象软件的基础》中的描述。

# Session Facade  

Since the Value List Handler is a session bean, it may appear as a specialized Session Facade. However, in isolation, it is a specialized session bean rather than a specialized Session Facade. A Session Facade has other motivations and characteristics (explained in the Session Facade pattern), and it is much coarser grained.  

由于Value List Handler是一种会话Bean，它可能表现为一种特化的会话门面。但单独来看，它是一个特化的会话Bean而非特化的会话门面。会话门面具有其他动机和特性（在会话门面模式中已作说明），且其粒度要粗得多。

# Service Locator  

# Context  

Service lookup and creation involves complex interfaces and network operations.  

服务查找与创建涉及复杂的接口和网络操作。

# Problem  

J2EE clients interact with service components, such as EJB and JMS components, which provide business services and persistence capabilities. To interact with these components, clients must either locate the service component (referred to as a lookup operation) or create a new component. For instance, an EJB client must locate the enterprise bean's home object, which the client then uses either to find an object or to create or remove one or more enterprise beans. Similarly, a JMS client must first locate the JMS Connection Factory to obtain a JMS Connection or a JMS Session.  

J2EE客户端与服务组件（如EJB和JMS组件）进行交互，这些组件提供业务服务和持久化能力。要与这些组件交互，客户端必须定位服务组件（称为查找操作）或创建新组件。例如，EJB客户端必须定位企业Bean的Home对象，随后客户端使用该对象来查找现有对象，或创建/删除一个或多个企业Bean。类似地，JMS客户端需先定位JMS连接工厂，以获取JMS连接或JMS会话。

All J2EE application clients use the JNDI common facility to look up and create EJB and JMS components. The JNDI API enables clients to obtain an initial context object that holds the component name to object bindings. The client begins by obtaining the initial context for a bean's home object. The initial context remains valid while the client session is valid. The client provides the JNDI registered name for the required object to obtain a reference to an administered object. In the context of an EJB application, a typical administered object is an enterprise bean's home object. For JMS applications, the administered object can be a JMS Connection Factory (for a Topic or a Queue) or a JMS Destination (a Topic or a Queue).  

所有J2EE应用客户端都使用JNDI公共设施来查找和创建EJB及JMS组件。JNDI API使客户端能够获取包含组件名到对象绑定的初始上下文对象。客户端首先获取Bean主对象的初始上下文，该初始上下文在客户端会话有效期间保持有效。客户端通过提供JNDI注册名称来获取对受管对象的引用。在EJB应用场景中，典型的受管对象是企业Bean的主对象；对于JMS应用，受管对象可以是JMS连接工厂（对应主题或队列）或JMS目标（主题或队列）。

So, locating a JNDI-administered service object is common to all clients that need to access that service object. That being the case, it is easy to see that many types of clients repeatedly use the JNDI service, and the JNDI code appears multiple times across these clients. This results in an unnecessary duplication of code in the clients that need to look up services.  

因此，定位由JNDI管理的服务对象是所有需要访问该服务对象的客户端的共同需求。在这种情况下，显而易见的是多种类型的客户端会重复使用JNDI服务，导致JNDI代码在这些客户端中多次出现。这造成了需要查找服务的客户端中存在不必要的代码重复。

Also, creating a JNDI initial context object and performing a lookup on an EJB home object utilizes significant resources. If multiple clients repeatedly require the same bean home object, such duplicate effort can negatively impact application performance.  

此外，创建JNDI初始上下文对象并执行EJB home对象查找会消耗大量资源。如果多个客户端反复需要相同的bean home对象，这种重复操作会对应用程序性能产生负面影响。

Let us examine the lookup and creation process for various J2EE components.  

让我们来研究各类J2EE组件的查找与创建过程。

1. The lookup and creation of enterprise beans relies upon the following:  

企业级Bean的查找与创建依赖于以下要素：

o A correct setup of the JNDI environment so that it connects to the naming and directory service used by the application. Setup entails providing the location of the naming service and the necessary authentication credentials to access that service.   
o The JNDI service can then provide the client with an initial context that acts as a placeholder for the component name-to-object bindings. The client requests this initial context to look up the EJBHome object for the required enterprise bean by providing the JNDI name for that EJBHome object.   
o Find the EJBHome object using the initial context's lookup mechanism.   
o After obtaining the EJBHome object, create, remove, or find the enterprise bean, using the EJBHome object's create, move, and find (for entity beans only).  

- 正确配置JNDI环境，使其连接到应用程序所使用的命名和目录服务。配置内容包括提供命名服务的位置及访问该服务所需的认证凭证。  
- JNDI服务随后会为客户端提供一个初始上下文（Initial Context），该上下文充当组件名称与对象绑定的占位符。客户端通过提供EJBHome对象的JNDI名称，请求此初始上下文以查找所需企业级Bean的EJBHome对象。  
- 利用初始上下文的查找机制定位EJBHome对象。  
- 获取EJBHome对象后，通过其create、remove和find方法（仅适用于实体Bean）来创建、删除或查找企业级Bean。

2. The lookup and creation of JMS components (Topic, Queue, QueueConnection, QueueSession, TopicConnection, TopicSession, and so forth) involves the following steps. Note that in these steps, Topic refers to the publish/subscribe messaging model and Queue refers to the point-to-point messaging model.  

2. JMS组件（Topic、Queue、QueueConnection、QueueSession、TopicConnection、TopicSession等）的查找与创建需遵循以下步骤。需注意，在这些步骤中，Topic代表发布/订阅消息模型，而Queue代表点对点消息模型。

o Set up the JNDI environment to the naming service used by the application. Setup entails providing the location of the naming service and the necessary authentication credentials to access that service.   
o Obtain the initial context for the JMS service provider from the JNDI naming service.   
o Use the initial context to obtain a Topic or a Queue by supplying the JNDI name for the topic or the queue. Topic and Queue are JMSDestination objects.   
o Use the initial context to obtain a TopicConnectionFactory or a QueueConnectionFactory by supplying the JNDI name for the topic or queue connection factory.   
o Use the TopicConnectionFactory to obtain a TopicConnection or QueueConnectionFactory to obtain a QueueConnection.   
o Use the TopicConnection to obtain a TopicSession or a QueueConnection to obtain a QueueSession.   
o Use the TopicSession to obtain a TopicSubscriber or a TopicPublisher for the required Topic. Use the QueueSession to obtain a QueueReceiver or a QueueSender for the required Queue.  

o 配置应用程序所使用的命名服务的JNDI环境。设置内容包括提供命名服务的位置及访问该服务所需的认证凭据。  
o 从JNDI命名服务中获取JMS服务提供者的初始上下文。  
o 通过提供主题或队列的JNDI名称，使用初始上下文获取Topic或Queue。Topic和Queue均为JMSDestination对象。  
o 通过提供主题或队列连接工厂的JNDI名称，使用初始上下文获取TopicConnectionFactory或QueueConnectionFactory。  
o 通过TopicConnectionFactory获取TopicConnection，或通过QueueConnectionFactory获取QueueConnection。  
o 通过TopicConnection获取TopicSession，或通过QueueConnection获取QueueSession。  
o 通过TopicSession为指定Topic获取TopicSubscriber或TopicPublisher；通过QueueSession为指定Queue获取QueueReceiver或QueueSender。

The process to look up and create components involves a vendor-supplied context factory implementation. This introduces vendor dependency in the application clients that need to use the JNDI lookup facility to locate the enterprise beans and JMS components, such as topics, queues, and connection factory objects.  

查找和创建组件的过程涉及供应商提供的上下文工厂实现。这会在需要使用JNDI查找功能定位企业级Bean和JMS组件（如主题、队列和连接工厂对象）的应用程序客户端中引入供应商依赖。

# Forces  

EJB clients need to use the JNDI API to look up EJBHome objects by using the enterprise bean's registered JNDI name.   
JMS clients need to use JNDI API to look up JMS components by using the JNDI names registered for JMS components, such as connection factories, queues, and topics.   
The context factory to use for the initial JNDI context creation is provided by the service provider vendor and is therefore vendor- dependent. The context factory is also dependent on the type of object being looked up. The context for JMS is different from the context for EJB, with different providers. Lookup and creation of service components could be complex and may be used repeatedly in multiple clients in the application.   
Initial context creation and service object lookups, if frequently required, can be resource-intensive and may impact application performance. This is especially true if the clients and the services are located in different tiers. EJB clients may need to reestablish connection to a previously accessed enterprise bean instance, having only its Handle object.  

EJB客户端需通过JNDI API，使用企业Bean注册的JNDI名称来查找EJBHome对象。  
JMS客户端需通过JNDI API，使用为JMS组件（如连接工厂、队列和主题）注册的JNDI名称来查找JMS组件。  

初始JNDI上下文创建所需的上下文工厂由服务提供商提供，因此具有厂商依赖性。该工厂的实现还取决于被查找对象的类型。JMS的上下文与EJB的上下文不同，且由不同供应商提供。服务组件的查找和创建可能较为复杂，并可能在应用的多个客户端中重复使用。  

若频繁需要初始上下文创建和服务对象查找，可能会消耗大量资源并影响应用性能。当客户端与服务位于不同层级时尤为明显。EJB客户端可能仅持有Handle对象时，仍需重新建立与先前访问的企业Bean实例的连接。

# Solution  

Use a Service Locator object to abstract all JNDI usage and to hide the complexities of initial context creation, EJB home object lookup, and EJB object re-creation. Multiple clients can reuse the Service Locator object to reduce code complexity, provide a single point of control, and improve performance by providing a caching facility.  

使用服务定位器对象来抽象所有JNDI操作，并隐藏初始上下文创建、EJB Home对象查找以及EJB对象重建的复杂性。多个客户端可复用该服务定位器对象，从而降低代码复杂度、提供单一控制点，并通过缓存机制提升性能。

This pattern reduces the client complexity that results from the client's dependency on and need to perform lookup and creation processes, which are resource-intensive. To eliminate these problems, this pattern provides a mechanism to abstract all dependencies and network details into the Service Locator.  

该模式降低了客户端因依赖查找和创建过程（这些过程资源消耗较大）而产生的复杂性。为解决这些问题，该模式提供了一种机制，将所有依赖项和网络细节抽象至服务定位器中。

# Structure  

Figure 8.31 shows the class diagram representing the relationships for the Service Locator pattern.  

图8.31展示了表示服务定位器模式关系的类图。

![](images/8b83572d7731af22adbe82ffd0c65a8650f79872d1c727ccc2aabe56451d82e8.jpg)  
Figure 8.31. Service Locator class diagram  

图 8.31 服务定位器类图

# Participants and Responsibilities  

Figure 8.32 contains the sequence diagram that shows the interaction between the various participants of the Service Locator pattern.  

图8.32展示了服务定位器模式中各参与者间交互的时序图。

![](images/04455111d5a883159c4349f218e12503e418706b7c496b3c95b092394f8b58f2.jpg)  
Figure 8.32. Service Locator Sequence diagram  

图 8.32. 服务定位器时序图

# Client  

This is the client of the Service Locator. The client is an object that typically requires access to business objects such as a Business Delegate (see “Business Delegate” )  

这是服务定位器的客户端。客户端通常是一个需要访问业务对象（例如业务委托，参见“业务委托”）的对象。

# Service Locator  

The Service Locator abstracts the API lookup (naming) services, vendor dependencies, lookup complexities, and business object creation, and provides a simple interface to clients. This reduces the client's complexity. In addition, the same client or other clients can reuse the Service Locator.  

服务定位器（Service Locator）封装了API查找（命名）服务、厂商依赖项、查找复杂性以及业务对象创建过程，并为客户端提供简洁的接口。这有效降低了客户端的复杂度。此外，同一客户端或其他客户端均可复用该服务定位器。

# InitialContext  

The InitialContext object is the start point in the lookup and creation process. Service providers provide the context object, which varies depending on the type of business object provided by the Service Locator's lookup and creation service. A Service Locator that provides services for multiple types of business objects (such as enterprise beans, JMS components, and so forth) utilizes multiple types of context objects, each obtained from a different provider (e.g., context provider for an EJB application server may be different from the context provider for JMS service).  

`InitialContext`对象是查找与创建流程的起点。服务提供方会提供上下文对象，其类型取决于服务定位器（Service Locator）的查找与创建服务所返回的业务对象类型。若服务定位器需为多种业务对象（如企业级Bean、JMS组件等）提供服务，则会使用多种类型的上下文对象，每种对象均来自不同的提供方（例如EJB应用服务器的上下文提供方可能与JMS服务的上下文提供方不同）。

# ServiceFactory  

The ServiceFactory object represents an object that provides life cycle management for the BusinessService objects. The ServiceFactory object for enterprise beans is an EJBHome object. The ServiceFactory for JMS components can be a JMS ConnectionFactory object, such as a TopicConnectionFactory (for publish/subscribe messaging model) or a QueueConnectionFactory (for point-to-point messaging model).  

`ServiceFactory`对象是为`BusinessService`对象提供生命周期管理的对象。企业级Bean的`ServiceFactory`对象表现为`EJBHome`对象。对于JMS组件而言，其`ServiceFactory`可以是`JMS ConnectionFactory`对象，例如`TopicConnectionFactory`（用于发布/订阅消息模型）或`QueueConnectionFactory`（用于点对点消息模型）。

# BusinessService  

The BusinessService is a role that is fulfilled by the service the client is seeking to access. The BusinessService object is created or looked up or removed by the ServiceFactory. The BusinessService object in the context of an EJB application is an enterprise bean. The BusinessService object in the context of a JMS application can be a TopicConnection or a QueueConnection. The TopicConnection and QueueConnection can then be used to produce a JMSSession object, such as TopicSession or a QueueSession respectively.  

`BusinessService` 是客户端试图访问的服务所承担的角色。该对象由 `ServiceFactory` 创建、查找或移除。在 EJB 应用中，`BusinessService` 对象表现为一个企业级 Bean；而在 JMS 应用中，它可以是 `TopicConnection` 或 `QueueConnection`。这些连接对象随后可用于生成 `JMSSession` 对象，例如分别对应的 `TopicSession` 或 `QueueSession`。

# Strategies  

# EJB Service Locator Strategy  

The Service Locator for enterprise bean components uses EJBHome object, shown as BusinessHome in the role of the ServiceFactory. Once the EJBHome object is obtained, it can be cached in the ServiceLocator for future use to avoid another JNDI lookup when the client needs the home object again. Depending on the implementation, the home object can be returned to the client, which can then use it to look up, create, and remove enterprise beans. Otherwise, the ServiceLocator can retain (cache) the home object and gain the additional responsibility of proxying all client calls to the home object. The class diagram for the EJB Service Locator strategy is shown in Figure 8.33  

企业级Bean组件的服务定位器使用EJBHome对象（在ServiceFactory角色中显示为BusinessHome）。一旦获取EJBHome对象，可将其缓存在ServiceLocator中以备后续使用，从而避免客户端再次需要Home对象时执行额外的JNDI查找。根据具体实现方式，Home对象可直接返回给客户端，由客户端自行执行企业级Bean的查找、创建和移除操作；或者由ServiceLocator保留（缓存）该Home对象，并额外承担代理所有客户端对Home对象调用的职责。图8.33展示了EJB服务定位器策略的类图。

![](images/e58e587dd9a810a1e071748adaec29457e8f021185d070a59cafed9114497401.jpg)  
Figure 8.33. EJB Service Locator Strategy class diagram  

图8.33 EJB服务定位器策略类图

The interaction between the participants in a Service Locator for an enterprise bean is shown in Figure 8.34.  

图8.34展示了企业级Bean的服务定位器中各参与者间的交互关系。

# Figure 8.34. EJB Service Locator Strategy sequence diagram  

![](images/021e58cdf887782175f6f00c5eb97c215247a46fe5b420cd067202cadf098ab4.jpg)  

# JMS Queue Service Locator Strategy  

This strategy is applicable to point-to-point messaging requirements. The Service Locator for JMS components uses QueueConnectionFactory objects in the role of the ServiceFactory. The QueueConnectionFactory is looked up using its JNDI name. The QueueConnectionFactory can be cached by the ServiceLocator for future use. This avoids repeated JNDI calls to look it up when the client needs it again. The ServiceLocator may otherwise hand over the QueueConnectionFactory to the client. The Client can then use it to create a QueueConnection. A QueueConnection is necessary in order to obtain a QueueSession or to create a Message, a QueueSender (to send messages to the queue), or a QueueReceiver (to receive messages from a queue). The class diagram for the JMS Queue Service Locator strategy is shown in Figure 8.35. In this diagram, the Queue is a JMS Destination object registered as a JNDI-administered object representing the queue. The Queue object can be directly obtained from the context by looking it up using its JNDI name.  

该策略适用于点对点消息传递需求。JMS组件的服务定位器将`QueueConnectionFactory`对象作为`ServiceFactory`角色使用。通过JNDI名称查找`QueueConnectionFactory`，服务定位器可缓存该对象以供后续使用，从而避免客户端再次需要时重复进行JNDI查询。服务定位器也可直接将`QueueConnectionFactory`交付客户端，客户端随后可用其创建`QueueConnection`。获取`QueueSession`、创建消息、`QueueSender`（向队列发送消息）或`QueueReceiver`（从队列接收消息）均需依赖`QueueConnection`。图8.35展示了JMS队列服务定位器策略的类图，其中`Queue`是注册为JNDI受管对象的JMS目标对象，代表消息队列。通过JNDI名称查询上下文可直接获取该`Queue`对象。

# Figure 8.35. JMS Queue Service Locator strategy class diagram  

![](images/19a852277a7b51ccdc3bef338b0fc6e5a8566ec23c77960ad265cbfaf9d09823.jpg)  

The interaction between the participants in a Service Locator for point-to-point messaging using JMS Queues is shown in Figure 8.36.  

图8.36展示了使用JMS队列进行点对点消息传递时，服务定位器中各参与者间的交互关系。

# Figure 8.36. JMS Queue Service Locator Strategy sequence diagram  

![](images/3d74db20fdb58e1466d6efd12fe441ec65cf6484aa20e6cfaf99498b5507698b.jpg)  

# JMS Topic Service Locator Strategy  

This strategy is applicable to publish/subscribe messaging requirements. The Service Locator for JMS components uses TopicConnectionFactory objects in the role of the ServiceFactory. The TopicConnectionFactory is looked up using its JNDI name. The TopicConnectionFactory can be cached by the ServiceLocator for future use. This avoids repeated JNDI calls to look it up when the client needs it again. The ServiceLocator may otherwise hand over the TopicConnectionFactory to the client. The Client can then use it to create a TopicConnection. A TopicConnection is necessary in order to obtain a TopicSession or to create a Message, a TopicPublisher (to publish messages to a topic), or a TopicSubscriber (to subscribe to a topic). The class diagram for the JMS Topic Service Locator strategy is shown in Figure 8.37. In this diagram, the Topic is a JMS Destination object registered as a JNDI-administered object representing the topic. The Topic object can be directly obtained from the context by looking it up using its JNDI name  

该策略适用于发布/订阅消息需求。JMS组件的服务定位器将TopicConnectionFactory对象作为ServiceFactory角色使用。通过JNDI名称查找TopicConnectionFactory，服务定位器可缓存该对象以供后续使用，从而避免客户端再次需要时重复进行JNDI调用。服务定位器也可直接将TopicConnectionFactory交给客户端，客户端随后可用其创建TopicConnection。获取TopicSession、创建Message、TopicPublisher（用于向主题发布消息）或TopicSubscriber（用于订阅主题）时均需TopicConnection。图8.37展示了JMS主题服务定位器策略的类图，其中Topic作为JMS Destination对象注册为JNDI管理对象表示主题，可通过JNDI名称直接从上下文中查找获取该Topic对象。

# Figure 8.37. JMS Topic Service Locator strategy  

![](images/1175b058a4e4ad6d8dfbec3449a42159075c0050bb2dfabb7ac511bafaacf876.jpg)  
Figure 8.38. JMS Topic Service Locator Strategy sequence diagram  

图 8.38 JMS主题服务定位器策略序列图

The interaction between the participants in a Service Locator for publish/subscribe messaging using JMS Topics is shown in Figure 8.38.  

图8.38展示了使用JMS主题实现发布/订阅消息时，服务定位器中各参与者间的交互关系。

![](images/f49c31f0cb1518635b7085cc18d7d5a3315e93d7494510f74b904d128831473a.jpg)  

# Combined EJB and JMS Service Locator Strategy  

These strategies for EJB and JMS can be used to provide separate Service Locator implementations, since the clients for EJB and JMS may more likely be mutually exclusive. However, if there is a need to combine these strategies, it is possible to do so to provide the Service Locator for all objects—enterprise beans and JMS components.  

针对EJB和JMS的这些策略可用于提供独立的服务定位器实现，因为EJB和JMS的客户端很可能是互斥的。但如果需要组合这些策略，也可以为所有对象（包括企业级Bean和JMS组件）提供统一的服务定位器。

# Type Checked Service Locator Strategy  

The diagrams in Figures 8.37 and 8.38 provide lookup facilities by passing in the service lookup name. For an enterprise bean lookup, the Service Locator needs a class as a parameter to the PortableRemoteObject.narrow() method. The Service Locator can provide a getHome() method, which accepts as arguments the JNDI service name and the EJBHome class object for the enterprise bean. Using this method of passing in JNDI service names and EJBHome class objects can lead to client errors. Another approach is to statically define the services in the ServiceLocator, and instead of passing in string names, the client passes in a constant. Example 8.34 illustrates such a strategy  

图8.37和8.38中的示意图通过传入服务查找名称提供查询功能。对于企业级Bean的查询，服务定位器需要为`PortableRemoteObject.narrow()`方法传入一个类作为参数。服务定位器可提供`getHome()`方法，该方法接收企业级Bean的JNDI服务名称和`EJBHome`类对象作为参数。这种传入JNDI服务名称和`EJBHome`类对象的方式可能导致客户端错误。另一种方法是在`ServiceLocator`中静态定义服务，客户端传入常量而非字符串名称。示例8.34展示了这种策略。

This strategy has trade-offs. It reduces the flexibility of lookup, which is in the Services Property Locator strategy, but add the type checking of passing in a constant to the ServiceLocator.getHome() method.  

该策略存在权衡取舍。它降低了服务属性定位器策略中的查找灵活性，但通过向`ServiceLocator.getHome()`方法传入常量增加了类型检查机制。

# Service Locator Properties Strategy  

This strategy helps to address the trade-offs of the type checking strategy. This strategy suggests the use of property files and/or deployment descriptors to specify the JNDI names and the EJBHome class name. For presentation-tier clients, such properties can be specified in the presentation-tier deployment descriptors or property files. When the presentation tier accesses the business tier, it typically uses the Business Delegate pattern.  

该策略有助于解决类型检查策略的权衡问题。该策略建议使用属性文件和/或部署描述符来指定JNDI名称及EJBHome类名。对于表示层客户端，此类属性可在表示层部署描述符或属性文件中指定。当表示层访问业务层时，通常采用**业务委托模式**（Business Delegate pattern）。

The Business Delegate interacts with the Service Locator to locate business components. If the presentation tier loads the properties on initialization and can provide a service to hand out the JNDI names and the EJB class names for the required enterprise bean, then the Business Delegate could request this service to obtain them. Once the Business Delegate has the JNDI name and the EJBHome Class name, it can request the Service Locator for the EJBHome by passing these properties as arguments.  

业务委托（Business Delegate）通过与服务定位器（Service Locator）交互来定位业务组件。若表示层在初始化时加载属性配置，并能提供分发所需企业级Bean的JNDI名称与EJB类名的服务，则业务委托可请求该服务以获取这些信息。当业务委托获得JNDI名称和EJBHome类名后，即可通过将这些属性作为参数传递给服务定位器来请求获取EJBHome对象。

The Service Locator can in turn use Class.forName(EJBHome ClassName) to obtain the EJBHome Class object and go about its business of looking up the EJBHome and using the Portable RemoteObject.narrow() method to cast the object, as shown by the getHome() method in the ServiceLocator sample code in Example 8.33. The only thing that changes is where the JNDI name and the Class objects are coming from. Thus, this strategy avoids hardcoded JNDI names in the code and provides for flexibility of deployment. However, due to the lack of type checking, there is scope for avoiding errors and mismatches in specifying the JNDI names in different deployment descriptors.  

服务定位器随后可通过`Class.forName(EJBHome ClassName)`获取EJBHome类对象，继续执行查找EJBHome并通过`PortableRemoteObject.narrow()`方法转换对象的核心逻辑，如示例8.33中ServiceLocator示例代码的`getHome()`方法所示。唯一变化的是JNDI名称和类对象的来源位置。该策略既避免了代码中硬编码JNDI名称，又提供了部署的灵活性。但由于缺乏类型检查，在不同部署描述符中指定JNDI名称时仍存在错误规避和名称不匹配的风险。

# Consequences  

# Abstracts Complexity  

The Service Locator pattern encapsulates the complexity of this lookup and creation process (described in the problem) and keeps it hidden from the client. The client does not need to deal with the lookup of component factory objects (EJBHome, QueueConnectionFactory, and TopicConnectionFactory, among others) because the ServiceLocator is delegated that responsibility.  

服务定位器模式封装了查找与创建过程的复杂性（如问题描述所述），并向客户端隐藏这些细节。客户端无需处理组件工厂对象（如EJBHome、QueueConnectionFactory和TopicConnectionFactory等）的查找工作，因为该职责已委托给ServiceLocator。

# Provides Uniform Service Access to Clients  

The Service Locator pattern abstracts all the complexities, as explained previously. In doing so, it provides a very useful and precise interface that all clients can use. The pattern interface ensures that all types of clients in the application uniformly access business objects, in terms of lookup and creation. This uniformity reduces development and maintenance overhead.  

服务定位器模式封装了前文所述的所有复杂性，为所有客户端提供了一个极其实用且精确的接口。该模式接口确保应用程序中各类客户端能以统一的方式（包括查找与创建）访问业务对象。这种一致性有效降低了开发与维护成本。

# Facilitates Adding New Business Components  

Because clients of enterprise beans are not aware of the EJBHome objects, it's possible to add new EJBHome objects for enterprise beans developed and deployed at a later time without impacting the clients. JMS clients are not directly aware of the JMS connection factories, so new connection factories can be added without impacting the clients.  

由于企业级Bean的客户端并不感知EJBHome对象，因此可以随时为后续开发和部署的企业级Bean新增EJBHome对象，而不会影响客户端。JMS客户端同样不直接感知JMS连接工厂，故新增连接工厂时也不会对客户端造成影响。

# Improves Network Performance  

The clients are not involved in JNDI lookup and factory/home object creation. Because the Service Locator performs this work, it can aggregate the network calls required to look up and create business objects.  

客户端无需参与JNDI查找及工厂/Home对象创建过程。由于服务定位器承担了这项工作，它能够将查找和创建业务对象所需的网络调用进行聚合。

# Improves Client Performance by Caching  

The Service Locator can cache the initial context objects and references to the factory objects (EJBHome, JMS connection factories) to eliminate  

服务定位器可缓存初始上下文对象及工厂对象引用（如EJBHome、JMS连接工厂），从而消除

unnecessary JNDI activity that occurs when obtaining the initial context and the other objects. This improves the application performance.  

在获取初始上下文及其他对象时减少不必要的JNDI操作，从而提升应用程序性能。

# Sample Code  

# Implementing Service Locator Pattern  

A sample implementation of the Service Locator pattern is shown in Example 8.33. An example for implementing the Type Checked Service Locator strategy is listed in Example 8.34  

示例8.33展示了服务定位器模式的实现样例，示例8.34则列出了类型检查服务定位器策略的实现范例。

# Example 8.33 Implementing Service Locator  

package corepatterns.apps.psa.util;   
import java.util.\*;   
import javax.naming.\*;   
import java.rmi.RemoteException;   
import javax.ejb.\*;   
import javax.rmi.PortableRemoteObject;   
import java.io.\*;   
public class ServiceLocator { private static ServiceLocator me; InitialContext context $=$ null; private ServiceLocator() throws ServiceLocatorException { try { context $=$ new InitialContext(); catch(NamingException ne) { throw new ServiceLocatorException(...); // Returns the instance of ServiceLocator class   
public static ServiceLocator getInstance() throws ServiceLocatorException { if $(\mathrm{me}==\mathrm{nul}]$ ) { me $=$ new ServiceLocator(); } return me; }   
// Converts the serialized string into EJBHandle   
// then to EJBObject.   
public EJBObject getService(String id)   
throws ServiceLocatorException { if (id $==$ null) { throw new ServiceLocatorException(...); } try { byte[] bytes $=$ new String(id).getBytes(); InputStream io $=$ new ByteArrayInputStream(bytes); ObjectInputStream os $=$ new ObjectInputStream(io); javax.ejb.Handle handle $=$ (javax.ejb.Handle)os.readObject(); return handle.getEJBObject(); } catch(Exception ex) { throw new ServiceLocatorException(...);   
}   
// Returns the String that represents the given   
// EJBObject's handle in serialized format.   
protected String getId(EJBObject session)   
throws ServiceLocatorException { try { javax.ejb.Handle handle $=$ session.getHandle(); ByteArrayOutputStream fo $=$ new ByteArrayOutputStream(); ObjectOutputStream so $=$ new ObjectOutputStream(fo); so.writeObject(handle); so.flush(); so.close(); return new String(fo.toByteArray()); } catch(RemoteException ex) { throw new ServiceLocatorException(...); } catch(IOException ex) { throw new ServiceLocatorException(...); } return null;   
}   
// Returns the EJBHome object for requested servic   
// name. Throws ServiceLocatorException If Any Error   
// occurs in lookup   
public EJBHome getHome(String name, Class clazz)   
throws ServiceLocatorException { try { Object objref $=$ context.lookup(name); EJBHome home $=$ (EJBHome) PortableRemoteObject.narrow(objref, clazz); return home; catch(NamingException ex) { throw new ServiceLocatorException(...);  

package corepatterns.apps.psa.util;  
import java.util.\*;  
import javax.naming.\*;  
import java.rmi.RemoteException;  
import javax.ejb.\*;  
import javax.rmi.PortableRemoteObject;  
import java.io.\*;  

public class ServiceLocator {  
    private static ServiceLocator me;  
    InitialContext context $=$ null;  

    private ServiceLocator() throws ServiceLocatorException {  
        try {  
            context $=$ new InitialContext();  
        } catch(NamingException ne) {  
            throw new ServiceLocatorException(...);  
        }  
    }  

    // 返回ServiceLocator类的实例  
    public static ServiceLocator getInstance() throws ServiceLocatorException {  
        if $(\mathrm{me}==\mathrm{nul}]$ ) {  
            me $=$ new ServiceLocator();  
        }  
        return me;  
    }  

    // 将序列化字符串转换为EJBHandle，再转为EJBObject  
    public EJBObject getService(String id) throws ServiceLocatorException {  
        if (id $==$ null) {  
            throw new ServiceLocatorException(...);  
        }  
        try {  
            byte[] bytes $=$ new String(id).getBytes();  
            InputStream io $=$ new ByteArrayInputStream(bytes);  
            ObjectInputStream os $=$ new ObjectInputStream(io);  
            javax.ejb.Handle handle $=$ (javax.ejb.Handle)os.readObject();  
            return handle.getEJBObject();  
        } catch(Exception ex) {  
            throw new ServiceLocatorException(...);  
        }  
    }  

    // 返回表示给定EJBObject句柄的序列化格式字符串  
    protected String getId(EJBObject session) throws ServiceLocatorException {  
        try {  
            javax.ejb.Handle handle $=$ session.getHandle();  
            ByteArrayOutputStream fo $=$ new ByteArrayOutputStream();  
            ObjectOutputStream so $=$ new ObjectOutputStream(fo);  
            so.writeObject(handle);  
            so.flush();  
            so.close();  
            return new String(fo.toByteArray());  
        } catch(RemoteException ex) {  
            throw new ServiceLocatorException(...);  
        } catch(IOException ex) {  
            throw new ServiceLocatorException(...);  
        }  
        return null;  
    }  

    // 返回指定服务名的EJBHome对象。若查找过程中发生错误则抛出ServiceLocatorException  
    public EJBHome getHome(String name, Class clazz) throws ServiceLocatorException {  
        try {  
            Object objref $=$ context.lookup(name);  
            EJBHome home $=$ (EJBHome) PortableRemoteObject.narrow(objref, clazz);  
            return home;  
        } catch(NamingException ex) {  
            throw new ServiceLocatorException(...);  
        }  
    }  
}

# Implementing Type Checked Service Locator Strategy  

# Example 8.34 Implementing Type Checked Service Locator Strategy  

package corepatterns.apps.psa.util;   
// imports   
public class ServiceLocator { // singleton's private instance private static ServiceLocator me; static { me $=$ new ServiceLocator(); private ServiceLocator() {} // returns the Service Locator instance static public ServiceLocator getInstance() { return me;   
// Services Constants Inner Class - service objects   
public class Services { final public static int PROJECT $\begin{array}{r l r}{\mathrm{~\boldmath~\omega~}}&{{}=}&{0}\end{array}$ ; final public static int RESOURCE $\L=\L\perp$ ;   
}   
// Project EJB related constants   
final static Class  PROJECT_CLASS $=$   
ProjectHome.class;   
final static String PROJECT_NAME $=$ "Project";   
// Resource EJB related constants   
final static Class  RESOURCE_CLASS $=$ ResourceHome.class;   
final static String RESOURCE_NAME $=$ "Resource";   
// Returns the Class for the required service   
static private Class getServiceClass(int service){ switch( service ) { case Services.PROJECT: return PROJECT_CLASS; case Services.RESOURCE: return RESOURCE_CLASS; } return null;   
}   
// returns the JNDI name for the required service   
static private String getServiceName(int service){ switch( service ) { case Services.PROJECT: return PROJECT_NAME; case Services.RESOURCE: return RESOURCE_NAME; } return null;   
}   
$/\star$ gets the EJBHome for the given service using the   
$\star\star$ JNDI name and the Class for the EJBHome   
$^\star/$   
public EJBHome getHome( int s ) throws ServiceLocatorException { EJBHome home $=$ null; - 367 -   
try { Context initial $=$ new InitialContext(); // Look up using the service name from // defined constant Object objref $=$ initial.lookup(getServiceName(s)); Narrow using the EJBHome Class from // defined constant Object obj $=$ PortableRemoteObject.narrow( objref, getServiceClass(s)); home $=$ (EJBHome)obj;   
}   
catch( NamingException ex ) throw new ServiceLocatorException(...);   
catch( Exception ex ) { throw new ServiceLocatorException(...);   
return home;  

package corepatterns.apps.psa.util;  
// 导入声明  
public class ServiceLocator {  
    // 单例模式的私有实例  
    private static ServiceLocator me;  
    static {  
        me = new ServiceLocator();  
    }  
    private ServiceLocator() {}  
    // 返回Service Locator实例  
    static public ServiceLocator getInstance() {  
        return me;  
    }  

    // 服务常量内部类 - 服务对象  
    public class Services {  
        final public static int PROJECT = 0;  
        final public static int RESOURCE = 1;  
    }  

    // Project EJB相关常量  
    final static Class PROJECT_CLASS = ProjectHome.class;  
    final static String PROJECT_NAME = "Project";  

    // Resource EJB相关常量  
    final static Class RESOURCE_CLASS = ResourceHome.class;  
    final static String RESOURCE_NAME = "Resource";  

    // 根据服务类型返回对应的Class  
    static private Class getServiceClass(int service) {  
        switch(service) {  
            case Services.PROJECT:  
                return PROJECT_CLASS;  
            case Services.RESOURCE:  
                return RESOURCE_CLASS;  
        }  
        return null;  
    }  

    // 根据服务类型返回对应的JNDI名称  
    static private String getServiceName(int service) {  
        switch(service) {  
            case Services.PROJECT:  
                return PROJECT_NAME;  
            case Services.RESOURCE:  
                return RESOURCE_NAME;  
        }  
        return null;  
    }  

    /*  
     * 通过JNDI名称和EJBHome Class获取指定服务的EJBHome  
     */  
    public EJBHome getHome(int s) throws ServiceLocatorException {  
        EJBHome home = null;  
        try {  
            Context initial = new InitialContext();  
            // 使用预定义的服务名称进行查找  
            Object objref = initial.lookup(getServiceName(s));  
            // 使用预定义的EJBHome Class进行窄化  
            Object obj = PortableRemoteObject.narrow(objref, getServiceClass(s));  
            home = (EJBHome)obj;  
        }  
        catch(NamingException ex) {  
            throw new ServiceLocatorException(...);  
        }  
        catch(Exception ex) {  
            throw new ServiceLocatorException(...);  
        }  
        return home;  
    }

The client code to use the Service Locator for this strategy may look like the code in Example 8.35.  

使用此策略的Service Locator的客户端代码可能如示例8.35所示。

# Example 8.35 Client Code for Using the Service Locator  

public class ServiceLocatorTester { public static void main( String[] args ) { ServiceLocator serviceLocator $=$ ServiceLocator.getInstance(); try { ProjectHome projectHome $=$ (ProjectHome) serviceLocator.getHome( ServiceLocator.Services.PROJECT ); catch( ServiceException ex ) { // client handles exception System.out.println( ex.getMessage( ));  

public class ServiceLocatorTester { public static void main( String[] args ) { ServiceLocator serviceLocator $=$ ServiceLocator.getInstance(); try { ProjectHome projectHome $=$ (ProjectHome) serviceLocator.getHome( ServiceLocator.Services.PROJECT ); catch( ServiceException ex ) { // 客户端处理异常 System.out.println( ex.getMessage( ));

This strategy is about applying type checking to client lookup. It encapsulates the static service values inside the ServiceLocator and creates an inner class Services, which declares the service constants (PROJECT and RESOURCE). The Tester client gets an instance to the ServiceLocator singleton and calls getHome(), passing in the PROJECT. ServiceLocator in turn gets the JNDI entry name and the Home class and returns the EJBHome.  

该策略旨在对客户端查找实施类型检查。它将静态服务值封装在ServiceLocator内部，并创建一个声明服务常量（PROJECT和RESOURCE）的内部类Services。Tester客户端获取ServiceLocator单例的实例，调用getHome()方法并传入PROJECT参数。ServiceLocator随后获取JNDI条目名称和Home类，最终返回EJBHome。

# Related Patterns  

# Business Delegate  

The Business Delegate pattern uses Service Locator to gain access to the business service objects such as EJB objects, JMS topics, and JMS queues. This separates the complexity of service location from the Business Delegate, leading to loose coupling and increased manageability.  

业务委托模式通过服务定位器访问业务服务对象（如EJB对象、JMS主题和JMS队列），从而将服务定位的复杂性从业务委托中分离，实现松耦合并提升可管理性。

# Session Facade  

The Session Facade pattern uses Service Locator to gain access to the enterprise beans that are involved in a workflow. The Session Facade could directly use the Service Locator or delegate the work to a Business Delegate (See “Business Delegate” .).  

会话门面模式通过服务定位器获取参与工作流的企业级Bean。该模式可直接调用服务定位器，或将任务委派给业务委托（参见“业务委托”章节）。

# Value Object Assembler  

The Value Object Assembler pattern uses Service Locator to gain access to the various enterprise beans it needs to access to build its composite value object. The Value Object Assembler could directly use the Service Locator or delegate the work to a Business Delegate (See “Business Delegate”.)  

**值对象组装器模式**通过**服务定位器**获取所需的企业级Bean，以构建其组合值对象。该组装器可直接调用服务定位器，或将工作委托给**业务委托**（参见“业务委托”章节）。

# Chapter 9. INTEGRATION TIER PATTERNS  

# Topics in This Chapter  

Data Access Object Service Activator  

数据访问对象服务激活器

# Data Access Object  

# Context  

Access to data varies depending on the source of the data. Access to persistent storage, such as to a database, varies greatly depending on the type of storage (relational databases, object-oriented databases, flat files, and so forth) and the vendor implementation.  

数据访问方式因数据源而异。对于持久化存储（如数据库）的访问，其实现方式会因存储类型（关系型数据库、面向对象数据库、平面文件等）和供应商**实现**的不同而存在显著差异。

# Problem  

Many real-world J2EE applications need to use persistent data at some point. For many applications, persistent storage is implemented with different mechanisms, and there are marked differences in the APIs used to access these different persistent storage mechanisms. Other applications may need to access data that resides on separate systems. For example, the data may reside in mainframe systems, Lightweight Directory Access Protocol (LDAP) repositories, and so forth. Another example is where data is provided by services through external systems such as business-to-business (B2B) integration systems, credit card bureau service, and so forth.  

许多实际的J2EE应用在某个阶段都需要使用持久化数据。对于多数应用而言，持久化存储通过不同机制实现，且访问这些不同持久化存储机制的API存在显著差异。其他应用可能需要访问驻留在独立系统中的数据，例如数据可能存在于大型机系统、轻量级目录访问协议（LDAP）存储库等场景。另一种典型情况是通过外部系统（如企业间B2B集成系统、信用卡征信服务等）提供的服务来获取数据。

Typically, applications use shared distributed components such as entity beans to represent persistent data. An application is considered to employ bean-managed persistence (BMP) for its entity beans when these entity beans explicitly access the persistent storage—the entity bean includes code to directly access the persistent storage. An application with simpler requirements may forego using entity beans and instead use session beans or servlets to directly access the persistent storage to retrieve and modify the data. Or, the application could use entity beans with container-managed persistence, and thus let the container handle the transaction and persistent details.  

通常，应用程序会使用诸如实体Bean之类的共享分布式组件来表示持久化数据。当这些实体Bean显式访问持久化存储时（即实体Bean包含直接访问持久化存储的代码），该应用程序被视为对其实体Bean采用了**Bean管理持久化（BMP）**。对于需求较简单的应用，可以放弃使用实体Bean，转而通过会话Bean或Servlet直接访问持久化存储来检索和修改数据。此外，应用程序也可选用**容器管理持久化**的实体Bean，从而将事务和持久化细节交由容器处理。

Applications can use the JDBC API to access data residing in a relational database management system (RDBMS). The JDBC API enables standard access and manipulation of data in persistent storage, such as a relational database. JDBC enables J2EE applications to use SQL statements, which are the standard means for accessing RDBMS tables. However, even within an RDBMS environment, the actual syntax and format of the SQL statements may vary depending on the particular database product.  

应用程序可通过JDBC API访问关系型数据库管理系统(RDBMS)中的数据。JDBC API提供了对持久化存储（如关系型数据库）中数据进行标准化访问与操作的能力。该技术使J2EE应用程序能够使用SQL语句——这是访问RDBMS表的标准方式。但需注意的是，即使在RDBMS环境中，SQL语句的具体语法和格式仍可能因不同数据库产品而存在差异。

There is even greater variation with different types of persistent storage. Access mechanisms, supported APIs, and features vary between different types of persistent stores such as RDBMS, object-oriented databases, flat files, and so forth. Applications that need to access data from a legacy or disparate system (such as a mainframe, or B2B service) are often required to use APIs that may be proprietary. Such disparate data sources offer challenges to the application and can potentially create a direct dependency between application code and data access code. When business components—entity beans, session beans, and even presentation components like servlets and helper objects for Java Server Pages (JSPs)—need to access a data source, they can use the appropriate API to achieve connectivity and manipulate the data source. But including the connectivity and data access code within these components introduces a tight coupling between the components and the data source implementation. Such code dependencies in components make it difficult and tedious to migrate the application from one type of data source to another. When the data source changes, the components need to be changed to handle the new type of data source.  

不同类型的持久化存储存在更大差异。关系型数据库、面向对象数据库、平面文件等不同持久化存储的访问机制、支持的API和功能各不相同。需要从遗留系统或异构系统（如大型机或B2B服务）访问数据的应用程序，通常必须使用可能专有的API。这类异构数据源给应用程序带来挑战，并可能在应用代码与数据访问代码之间形成直接依赖关系。  

当业务组件（实体Bean、会话Bean，甚至Servlet和JSP辅助对象等表示层组件）需要访问数据源时，它们可通过相应API实现连接并操作数据源。但将连接和数据访问代码内嵌在这些组件中，会导致组件与数据源实现之间形成紧耦合。这种组件中的代码依赖关系使得应用程序在不同类型数据源之间迁移变得困难且繁琐。当数据源变更时，必须修改组件以适应新类型的数据源。

# Forces  

Components such as bean-managed entity beans, session beans, servlets, and other objects like helpers for JSPs need to retrieve and store information from persistent stores and other data sources like legacy systems, B2B, LDAP, and so forth. Persistent storage APIs vary depending on the product vendor. Other data sources may have APIs that are nonstandard and/or proprietary. These APIs and their capabilities also vary depending on the type of storage—RDBMS, object-oriented database management system (OODBMS), XML documents, flat files, and so forth. There is a lack of uniform APIs to address the requirements to access such disparate systems. Components typically use proprietary APIs to access external and/or legacy systems to retrieve and store data. • Portability of the components is directly affected when specific access mechanisms and APIs are included in the components. Components need to be transparent to the actual persistent store or data source implementation to provide easy migration to different vendor products, different storage types, and different data source types.  

诸如Bean管理的实体Bean、会话Bean、Servlet以及JSP辅助类等组件，需要从持久化存储及遗留系统、B2B、LDAP等数据源中存取信息。持久化存储API因供应商产品而异，其他数据源可能使用非标准或专有API。这些API及其功能还会因存储类型不同而变化——包括关系型数据库管理系统(RDBMS)、面向对象数据库管理系统(OODBMS)、XML文档、平面文件等。目前缺乏统一的API来满足访问这些异构系统的需求，组件通常需通过专有API访问外部/遗留系统以实现数据存取。  

• 当组件中嵌入了特定的访问机制和API时，将直接影响组件的可移植性。组件需要对实际的持久化存储或数据源实现保持透明，以便轻松迁移到不同厂商产品、不同存储类型及不同数据源类型。

# Solution  

# Use a Data Access Object (DAO) to abstract and encapsulate all access to the data source. The DAO manages the connection with the data source to obtain and store data.  

The DAO implements the access mechanism required to work with the data source. The data source could be a persistent store like an RDBMS, an external service like a B2B exchange, a repository like an LDAP database, or a business service accessed via CORBA Internet Inter-ORB Protocol (IIOP) or low-level sockets. The business component that relies on the DAO uses the simpler interface exposed by the DAO for its clients. The DAO completely hides the data source implementation details from its clients. Because the interface exposed by the DAO to clients does not change when the underlying data source implementation changes, this pattern allows the DAO to adapt to different storage schemes without affecting its clients or business components. Essentially, the DAO acts as an adapter between the component and the data source.  

DAO实现了与数据源交互所需的访问机制。数据源可以是持久化存储（如关系型数据库）、外部服务（如B2B交易平台）、存储库（如LDAP目录数据库），或是通过CORBA互联网ORB间协议(IIOP)或底层套接字访问的业务服务。依赖DAO的业务组件通过其暴露的简化接口与客户端交互。DAO将数据源的实现细节完全对客户端隐藏。由于DAO向客户端暴露的接口在底层数据源实现变更时保持不变，该模式使得DAO能够适配不同的存储方案，而不会影响客户端或业务组件。本质上，DAO充当了组件与数据源之间的适配器。

# Structure  

Figure 9.1 shows the class diagram representing the relationships for the DAO pattern.  

图9.1展示了表示DAO模式关系的类图。

![](images/b7e409beefd558a147fe712908cfb74619dbd6f6cf51336a69628c1b7f42aa3e.jpg)  
Figure 9.1. Data Access Object  

图9.1 数据访问对象

# Participants and Responsibilities  

Figure 9.2 contains the sequence diagram that shows the interaction between the various participants in this pattern.  

图9.2展示了该模式中各参与者间交互的时序图。

![](images/00d020b62da0f91e100258a306652a9498708fd202b151510911b3a8657f733d.jpg)  
Figure 9.2. Data Access Object sequence diagram  

图9.2 数据访问对象时序图

# BusinessObject  

The BusinessObject represents the data client. It is the object that requires access to the data source to obtain and store data. A BusinessObject may be implemented as a session bean, entity bean, or some other Java object, in addition to a servlet or helper bean that accesses the data source.  

`BusinessObject`代表数据客户端，是需要访问数据源以获取和存储数据的对象。除了通过Servlet或辅助Bean访问数据源外，`BusinessObject`可实现为会话Bean、实体Bean或其他Java对象。

# DataAccessObject  

The DataAccessObject is the primary object of this pattern. The DataAccessObject abstracts the underlying data access implementation for the BusinessObject to enable transparent access to the data source. The BusinessObject also delegates data load and store operations to the DataAccessObject.  

`DataAccessObject` 是该模式的核心对象。`DataAccessObject` 对底层数据访问实现进行抽象，使 `BusinessObject` 能够透明地访问数据源。`BusinessObject` 还会将数据加载和存储操作委托给 `DataAccessObject`。

# DataSource  

This represents a data source implementation. A data source could be a database such as an RDBMS, OODBMS, XML repository, flat file system, and so forth. A data source can also be another system (legacy/mainframe), service (B2B service or credit card bureau), or some kind of repository (LDAP).  

这表示一种数据源实现。数据源可以是诸如RDBMS、OODBMS、XML存储库或平面文件系统等数据库，也可以是其他系统（遗留/大型机）、服务（B2B服务或信用卡机构）或某种存储库（LDAP）。

# ValueObject  

This represents a value object used as a data carrier. The DataAccessObject may use a value object to return data to the client. The DataAccessObject may also receive the data from the client in a value object to update the data in the data source.  

这是一个用作数据载体的值对象。DataAccessObject 可能使用值对象将数据返回给客户端，也可能通过值对象接收客户端发来的数据以更新数据源中的内容。

# Strategies  

# Automatic DAO Code Generation Strategy  

Since each BusinessObject corresponds to a specific DAO, it is possible to establish relationships between the BusinessObject, DAO, and underlying implementations (such as the tables in an RDBMS). Once the relationships are established, it is possible to write a simple application-specific code-generation utility that generates the code for all DAOs required by the application. The metadata to generate the DAO can come from a developer-defined descriptor file. Alternatively, the code generator can automatically introspect the database and provide the necessary DAOs to access the database. If the requirements for DAOs are sufficiently complex, consider using third-party tools that provide object-to-relational mapping for RDBMS databases. These tools typically include GUI tools to map the business objects to the persistent storage objects and thereby define the intermediary DAOs. The tools automatically generate the code once the mapping is complete, and may provide other value-added features such as results caching, query caching, integration with application servers, integration with other third-party products (e.g., distributed caching), and so forth.  

由于每个`BusinessObject`都对应特定的`DAO`，因此可以在`BusinessObject`、`DAO`与底层实现（如关系型数据库中的表）之间建立关联关系。一旦关联建立，便可编写简单的应用专属代码生成工具，为应用程序所需的所有`DAO`生成代码。用于生成`DAO`的元数据可来源于开发者定义的描述文件，亦或通过代码生成器自动内省数据库并生成访问数据库所需的`DAO`。若`DAO`需求较为复杂，可考虑使用提供关系型数据库**对象关系映射**的第三方工具。这类工具通常包含图形界面工具，用于将业务对象映射至持久化存储对象，从而定义中间层`DAO`。映射完成后，工具会自动生成代码，并可能提供结果缓存、查询缓存、与应用服务器集成、与其他第三方产品（如分布式缓存）集成等增值功能。

# Factory for Data Access Objects Strategy  

The DAO pattern can be made highly flexible by adopting the Abstract Factory [GoF] and the Factory Method [GoF] patterns (see “Related Patterns” in this chapter).  

通过采用抽象工厂模式[GoF]和工厂方法模式[GoF]（参见本章“相关模式”），DAO模式可实现高度灵活性。

When the underlying storage is not subject to change from one implementation to another, this strategy can be implemented using the Factory Method pattern to  

当底层存储在不同实现之间无需变更时，可采用工厂方法模式实现该策略

produce a number of DAOs needed by the application. The class diagram for this case is shown in Figure 9.3.  

生成应用程序所需的若干DAO。该场景的类图如图9.3所示。

![](images/c87bead53f44fb0e20d06043add877979f0718f84e17c039861387415654c630.jpg)  
Figure 9.3. Factory for Data Access Object strategy using Factory Method  

图9.3 使用工厂方法模式实现数据访问对象策略的工厂

When the underlying storage is subject to change from one implementation to another, this strategy may be implemented using the Abstract Factory pattern. The Abstract Factory can in turn build on and use the Factory Method implementation, as suggested in Design Patterns: Elements of Reusable Object-Oriented Software [GoF]. In this case, this strategy provides an abstract DAO factory object (Abstract Factory) that can construct various types of concrete DAO factories, each factory supporting a different type of persistent storage implementation. Once you obtain the concrete DAO factory for a specific implementation, you use it to produce DAOs supported and implemented in that implementation.  

当底层存储可能在不同实现之间切换时，可采用**抽象工厂模式**实现此策略。如《设计模式：可复用面向对象软件的基础》[GoF]所述，抽象工厂可基于**工厂方法**实现并调用其实现。此时，该策略会提供一个抽象的DAO工厂对象（抽象工厂），该对象能构造多种具体DAO工厂，每个工厂支持不同类型的持久化存储实现。获取特定实现对应的具体DAO工厂后，即可通过该工厂生成该实现所支持及实现的DAO。

The class diagram for this strategy is shown in Figure 9.4. This class diagram shows a base DAO factory, which is an abstract class that is inherited and implemented by different concrete DAO factories to support storage implementation-specific access.  

该策略的类图如图9.4所示。该图展示了一个基础DAO工厂，这是一个抽象类，由不同具体DAO工厂继承并实现，以支持特定存储实现的访问。

The client can obtain a concrete DAO factory implementation such as RdbDAOFactory and use it to obtain concrete DAOs that work with that specific storage implementation. For example, the data client can obtain an RdbDAOFactory and use it to get specific DAOs such as RdbCustomerDAO, RdbAccountDAO, and so forth. The DAOs can extend and implement a generic base class (shown as DAO1 and DAO2) that specifically describe the DAO requirements for the business object it supports. Each concrete DAO is responsible for connecting to the data source and obtaining and manipulating data for the business object it supports.  

客户端可以获取具体的DAO工厂实现（如`RdbDAOFactory`），并通过该工厂获取与特定存储实现协同工作的具体DAO。例如，数据客户端可获取`RdbDAOFactory`，并利用其得到诸如`RdbCustomerDAO`、`RdbAccountDAO`等特定DAO。这些DAO可以扩展并实现一个通用基类（图示为`DAO1`和`DAO2`），该基类明确定义了其所支持业务对象的DAO需求。每个具体DAO负责连接数据源，并对其支持的业务对象进行数据获取与操作。

![](images/a06e96b132c45fd5fcc9087202f09c5667e4ed12cd5583ff7b49b25ba111a3a5.jpg)  
Figure 9.4. Factory for Data Access Object strategy using Abstract Factory  

图9.4 使用抽象工厂模式实现数据访问对象策略的工厂

The sample implementation for the DAO pattern and its strategies is shown in the “Sample Code” section of this chapter.  

DAO模式及其策略的示例实现展示在本章“示例代码”部分。

The sequence diagram describing the interactions for this strategy is shown in Figure 9.5.  

描述该策略交互过程的**时序图**如图9.5所示。

![](images/52e79a51c79ca65831be6b94d69fbeff2ddc98e76ff5480002946eb950710c73.jpg)  
Figure 9.5. Factory for Data Access Objects using Abstract Factory sequence diagram  

图9.5 使用抽象工厂模式的数据访问对象工厂时序图

# Consequences  

# Enables Transparency  

Business objects can use the data source without knowing the specific details of the data source's implementation. Access is transparent because the implementation details are hidden inside the DAO.  

业务对象可以在不了解数据源具体实现细节的情况下使用数据源。由于实现细节被封装在DAO内部，这种访问是透明的。

# Enables Easier Migration  

A layer of DAOs makes it easier for an application to migrate to a different database implementation. The business objects have no knowledge of the underlying data implementation. Thus, the migration involves changes only to the DAO layer. Further, if employing a factory strategy, it is possible to provide a concrete factory implementation for each underlying storage implementation. In this case, migrating to a different storage  

**DAO层**使得应用程序更容易迁移到不同的数据库实现。业务对象无需了解底层数据实现细节，因此迁移仅涉及DAO层的修改。此外，若采用工厂策略，可为每种底层存储实现提供具体的工厂实现。在这种情况下，迁移到不同的存储

implementation means providing a new factory implementation to the application.  

实现意味着向应用程序提供新的工厂实现。

# Reduces Code Complexity in Business Objects  

Because the DAOs manage all the data access complexities, it simplifies the code in the business objects and other data clients that use the DAOs. All implementation-related code (such as SQL statements) is contained in the DAO and not in the business object. This improves code readability and development productivity.  

由于DAO负责处理所有数据访问的复杂性，它简化了业务对象及其他使用DAO的数据客户端中的代码。所有与实现相关的代码（如SQL语句）都封装在DAO中，而非业务对象内。这提升了代码可读性和开发效率。

# Centralizes All Data Access into a Separate Layer  

Because all data access operations are now delegated to the DAOs, the separate data access layer can be viewed as the layer that can isolate the rest of the application from the data access implementation. This centralization makes the application easier to maintain and manage.  

由于所有数据访问操作现在都委托给DAO处理，独立的数据访问层可视为隔离应用程序其他部分与数据访问实现的层级。这种集中化设计使应用程序更易于维护和管理。

# Not Useful for Container-Managed Persistence  

Because the EJB container manages entity beans with container-managed persistence (CMP), the container automatically services all persistent storage access. Applications using container-managed entity beans do not need a DAO layer, since the application server transparently provides this functionality. However, DAOs are still useful when a combination of CMP (for entity beans) and BMP (for session beans, servlets) is required.  

由于EJB容器通过容器管理持久化(CMP)来管理实体Bean，容器会自动处理所有持久化存储访问。使用容器管理实体Bean的应用程序不需要DAO层，因为应用服务器已透明地提供了这一功能。然而，当需要同时使用CMP（针对实体Bean）和BMP（针对会话Bean、Servlet）时，DAO仍然有其用武之地。

# Adds Extra Layer  

The DAOs create an additional layer of objects between the data client and the data source that need to be designed and implemented to leverage the benefits of this pattern. But the benefit realized by choosing this approach pays off for the additional effort.  

DAO在数据客户端与数据源之间创建了额外的对象层，这些对象需要经过设计和实现以充分利用该模式的优势。尽管选择这种方法需要额外的工作，但其带来的收益将远超这些投入。

# Needs Class Hierarchy Design  

When using a factory strategy, the hierarchy of concrete factories and the hierarchy of concrete products produced by the factories need to be designed and implemented. This additional effort needs to be considered if there is sufficient justification warranting such flexibility. This increases the complexity of the design. However, you can choose to implement the factory strategy starting with the Factory Method pattern first, and then move towards the Abstract Factory if necessary.  

采用工厂策略时，需设计和实现具体工厂的层级结构及其所生产的具体产品层级结构。若需确保此类灵活性具备充分合理性，则必须考量这一额外工作量。该策略会增加设计复杂度。但开发者可优先从工厂方法模式着手实现工厂策略，必要时再过渡至抽象工厂模式。

# Sample Code  

# Implementing Data Access Object pattern  

An example DAO code for a persistent object that represents Customer information is shown in Example 9.4. The CloudscapeCustomerDAO creates a Customer value object when the findCustomer() method is invoked.  

示例9.4展示了一个表示客户信息的持久化对象DAO代码实现。当调用`findCustomer()`方法时，`CloudscapeCustomerDAO`会创建一个客户值对象。

The sample code to use the DAO is shown in Example 9.6. The class diagram for this example is shown in Figure 9.6.  

使用该DAO的示例代码如示例9.6所示。本例的类图如图9.6所示。

![](images/1f3c3d46470cbc6d632e3967743d48bdab838f9903aec2f64995737d50634e8c.jpg)  
Figure 9.6. Implementing the DAO pattern  

图 9.6. 实现DAO模式

# Implementing Factory for Data Access Objects Strategy  

# Using Factory Method Pattern  

Consider an example where we are implementing this strategy in which a DAO factory produces many DAOs for a single database implementation (e.g., Oracle). The factory produces DAOs such as CustomerDAO, AccountDAO, OrderDAO, and so forth. The class diagram for this example is shown in Figure 9.7.  

假设我们正在实施这样一种策略：**DAO工厂**为单一数据库实现（例如Oracle）生成多个DAO。该工厂会生成诸如`CustomerDAO`、`AccountDAO`、`OrderDAO`等数据访问对象。此示例的类图如图9.7所示。

# Figure 9.7. Implementing the Factory for DAO strategy using Factory Method  

![](images/cde4ed6c2ac824d450dc34d9d4f32a5589c63a5f53316137f9e955104a1ab8a0.jpg)  

The example code for the DAO factory (CloudscapeDAOFactory) is listed in Example 9.2.  

示例代码中的 DAO 工厂 (`CloudscapeDAOFactory`) 列于示例 9.2。

# Using Abstract Factory Pattern  

Consider an example where we are considering implementing this strategy for three different databases. In this case, the Abstract Factory pattern can be employed. The class diagram for this example is shown in Figure 9.8. The sample code in Example 9.1 shows code excerpt for the abstract DAOFactory class. This factory produces DAOs such as CustomerDAO, AccountDAO, OrderDAO, and so forth. This strategy uses the Factory Method implementation in the factories produced by the Abstract Factory.  

假设我们有一个需要为三种不同数据库实施该策略的示例场景。此时可采用**抽象工厂模式**，其类结构如图9.8所示。示例9.1中的代码片段展示了抽象类`DAOFactory`的实现，该工厂负责生成`CustomerDAO`、`AccountDAO`、`OrderDAO`等数据访问对象。该策略通过在抽象工厂生成的子工厂中运用**工厂方法模式**来实现。

# Figure 9.8. Implementing the Factory for DAO strategy using Abstract Factory  

![](images/29595d8f2d547a8b3a47a2fa19fba13adaa164f6ed2961b1fae6da84acb98d98.jpg)  

# Example 9.1 Abstract DAOFactory Class  

// Abstract class DAO Factory public abstract class DAOFactory { // List of DAO types supported by the factory public static final int CLOUDSCAPE $\L=\L\perp$ ; public static final int ORACLE $=~2$ ; public static final int SYBASE $\a=\phantom{-}3$ ;  

// 抽象类 DAO 工厂  
public abstract class DAOFactory {  
    // 工厂支持的 DAO 类型列表  
    public static final int CLOUDSCAPE $\L=\L\perp$ ;  
    public static final int ORACLE $=~2$ ;  
    public static final int SYBASE $\a=\phantom{-}3$ ;

// There will be a method for each DAO that can be // created. The concrete factories will have to  

// 每个可创建的DAO都将对应一个方法。具体工厂类必须

// implement these methods.   
public abstract CustomerDAO getCustomerDAO();   
public abstract AccountDAO getAccountDAO();   
public abstract OrderDAO getOrderDAO();   
public static DAOFactory getDAOFactory( int whichFactory) { switch (whichFactory) case CLOUDSCAPE: return new CloudscapeDAOFactory(); case ORACLE return new OracleDAOFactory(); case SYBASE : return new SybaseDAOFactory(); default return null;  

// 实现这些方法  
public abstract CustomerDAO getCustomerDAO();  
public abstract AccountDAO getAccountDAO();  
public abstract OrderDAO getOrderDAO();  
public static DAOFactory getDAOFactory(int whichFactory) {  
    switch (whichFactory) {  
        case CLOUDSCAPE:  
            return new CloudscapeDAOFactory();  
        case ORACLE:  
            return new OracleDAOFactory();  
        case SYBASE:  
            return new SybaseDAOFactory();  
        default:  
            return null;  
    }  
}

The sample code for CloudscapeDAOFactory is shown in Example 9.2. The implementation for OracleDAOFactory and SybaseDAOFactory are similar except for specifics of each implementation, such as JDBC driver, database URL, and differences in SQL syntax, if any.  

示例代码 `CloudscapeDAOFactory` 如示例 9.2 所示。`OracleDAOFactory` 和 `SybaseDAOFactory` 的实现方式类似，仅存在各实现特有的细节差异，例如 JDBC 驱动、数据库 URL 以及 SQL 语法上的区别（如有）。

# Example 9.2 Concrete DAOFactory Implementation for Cloudscape  

// Cloudscape concrete DAO Factory implementation import java.sql.\*;  

// Cloudscape 具体 DAO 工厂实现 import java.sql.\*;

public class CloudscapeDAOFactory extends DAOFactory { public static final String DRIVER $\varepsilon$ "COM.cloudscape.core.RmiJdbcDriver"; public static final String DBURL $=$ "jdbc:cloudscape:rmi://localhost:1099/CoreJ2EEDB";  

public class CloudscapeDAOFactory extends DAOFactory { public static final String DRIVER $\varepsilon$ "COM.cloudscape.core.RmiJdbcDriver"; public static final String DBURL $=$ "jdbc:cloudscape:rmi://localhost:1099/CoreJ2EEDB";

// method to create Cloudscape connections public static Connection createConnection() { // Use DRIVER and DBURL to create a connection  

// 创建Cloudscape数据库连接的方法  
public static Connection createConnection() { // 使用DRIVER和DBURL创建连接

// Recommend connection pool implementation/usage   
public CustomerDAO getCustomerDAO() { // CloudscapeCustomerDAO implements CustomerDAO return new CloudscapeCustomerDAO();   
}   
public AccountDAO getAccountDAO() { // CloudscapeAccountDAO implements AccountDAO return new CloudscapeAccountDAO();   
}   
public OrderDAO getOrderDAO() { // CloudscapeOrderDAO implements OrderDAO return new CloudscapeOrderDAO();  

// 推荐连接池的实现与使用  
public CustomerDAO getCustomerDAO() { // CloudscapeCustomerDAO 实现 CustomerDAO 接口  
    return new CloudscapeCustomerDAO();   
}   
public AccountDAO getAccountDAO() { // CloudscapeAccountDAO 实现 AccountDAO 接口  
    return new CloudscapeAccountDAO();   
}   
public OrderDAO getOrderDAO() { // CloudscapeOrderDAO 实现 OrderDAO 接口  
    return new CloudscapeOrderDAO();

The CustomerDAO interface shown in Example 9.3 defines the DAO methods for Customer persistent object that are implemented by all concrete DAO implementations, such as CloudscapeCustomerDAO, OracleCustomerDAO, and SybaseCustomerDAO. Similar, but not listed here, are AccountDAO and OrderDAO interfaces that define the DAO methods for Account and Order business objects respectively.  

示例9.3所示的CustomerDAO接口定义了客户持久化对象的DAO方法，这些方法由所有具体DAO实现（如CloudscapeCustomerDAO、OracleCustomerDAO和SybaseCustomerDAO）所实现。与之类似但未列出的还有AccountDAO和OrderDAO接口，它们分别定义了针对账户和订单业务对象的DAO方法。

# Example 9.3 Base DAO Interface for Customer  

// Interface that all CustomerDAOs must support public interface CustomerDAO { public int insertCustomer(...); public boolean deleteCustomer(...); public Customer findCustomer(...); public boolean updateCustomer(...); public RowSet selectCustomersRS(...); public Collection selectCustomersVO(...);  

// 所有CustomerDAO必须支持的接口  
public interface CustomerDAO {  
    public int insertCustomer(...);  
    public boolean deleteCustomer(...);  
    public Customer findCustomer(...);  
    public boolean updateCustomer(...);  
    public RowSet selectCustomersRS(...);  
    public Collection selectCustomersVO(...);

The CloudscapeCustomerDAO implements the CustomerDAO as shown in Example 9.4. The implementation of other DAOs, such as CloudscapeAccountDAO, CloudscapeOrderDAO, OracleCustomerDAO, OracleAccountDAO, and so forth, are similar.  

`CloudscapeCustomerDAO` 实现了 `CustomerDAO` 接口，如示例 9.4 所示。其他 DAO（例如 `CloudscapeAccountDAO`、`CloudscapeOrderDAO`、`OracleCustomerDAO`、`OracleAccountDAO` 等）的实现方式与之类似。

# Example 9.4 Cloudscape DAO Implementation for Customer  

/ / CloudscapeCustomerDAO implementation of the   
// CustomerDAO interface. This class can contain all   
// Cloudscape specific code and SQL statements.   
// The client is thus shielded from knowing   
// these implementation details.   
import java.sql.\*;   
public class CloudscapeCustomerDAO implements CustomerDAO {   
public CloudscapeCustomerDAO() { // initialization } // The following methods can use   
// CloudscapeDAOFactory.createConnection()   
// to get a connection as required   
public int insertCustomer(...) { // Implement insert customer here. // Return newly created customer number // or a -1 on error }   
public boolean deleteCustomer(...) { // Implement delete customer here // Return true on success, false on failure }   
public Customer findCustomer(...) { // Implement find a customer here using supplied // argument values as search criteria // Return a value object if found, // return null on error or if not found }   
public boolean updateCustomer(...) { // implement update record here using data // from the customerData value object // Return true on success, false on failure or error   
public RowSet selectCustomersRS(...) // implement search customers here using the // supplied criteria. // Return a RowSet.   
public Collection selectCustomersVO(...) { // implement search customers here using the // supplied criteria. // Alternatively, implement to return a Collection // of value objects.  

// CloudscapeCustomerDAO 对 CustomerDAO 接口的实现类  
// 该类可包含所有 Cloudscape 专属代码及 SQL 语句  
// 客户端因此无需知晓这些实现细节  
import java.sql.\*;  
public class CloudscapeCustomerDAO implements CustomerDAO {  
public CloudscapeCustomerDAO() { // 初始化 }  
// 下列方法可通过 CloudscapeDAOFactory.createConnection()  
// 按需获取数据库连接  
public int insertCustomer(...) { // 实现客户新增逻辑 // 返回新创建客户编号 // 错误时返回-1 }  
public boolean deleteCustomer(...) { // 实现客户删除逻辑 // 成功返回true，失败返回false }  
public Customer findCustomer(...) { // 根据参数值作为查询条件实现客户查找 // 找到则返回值对象 // 未找到或出错时返回null }  
public boolean updateCustomer(...) { // 使用customerData值对象数据实现记录更新 // 成功返回true，失败或出错返回false }  
public RowSet selectCustomersRS(...) // 根据指定条件实现客户搜索 // 返回RowSet结果集  
public Collection selectCustomersVO(...) { // 根据指定条件实现客户搜索 // 也可实现为返回值对象的Collection集合

The Customer value object class is shown in Example 9.5. This is used by the DAOs to send and receive data from the clients. The usage of value objects is discussed in detail in the Value Object pattern.  

示例9.5展示了客户值对象类。DAO通过该对象与客户端进行数据收发。关于值对象的使用细节，请参阅"值对象模式"章节。

# Example 9.5 Customer Value Object  

public class Customer implements java.io.Serializable { // member variables int CustomerNumber; String name; String streetAddress; String city; getter and setter methods...  

public class Customer implements java.io.Serializable { // 成员变量 int CustomerNumber; String name; String streetAddress; String city; getter和setter方法...

Example 9.6 shows the usage of the DAO factory and the DAO. If the implementation changes from Cloudscape to another product, the only required change is the getDAOFactory() method call to the DAO factory to obtain a different factory.  

示例9.6展示了DAO工厂和DAO的使用方式。若需将实现从Cloudscape切换至其他产品，唯一需要修改的就是通过DAO工厂的getDAOFactory()方法调用来获取不同的工厂实例。

# Example 9.6 Using a DAO and DAO Factory – Client Code  

// create the required DAO Factory   
DAOFactory cloudscapeFactory $=$ DAOFactory.getDAOFactory(DAOFactory.DAOCLOUDSCAPE);   
// Create a DAO   
CustomerDAO custDAO $=$ cloudscapeFactory.getCustomerDAO();  

// 创建所需的DAO工厂  
DAOFactory cloudscapeFactory = DAOFactory.getDAOFactory(DAOFactory.DAOCLOUDSCAPE);  
// 创建DAO  
CustomerDAO custDAO = cloudscapeFactory.getCustomerDAO();

// create a new customer int newCustNo $=$ custDAO.insertCustomer(...);  

// 创建新客户  
int newCustNo = custDAO.insertCustomer(...);

// Find a customer object. Get the value object.   
Customer cust $=$ custDAO.findCustomer(...); // modify the values in the value object.   
cust.setAddress(...);   
cust.setEmail(...);   
// update the customer object using the DAO custDAO.updateCustomer(cust); // delete a customer object   
custDAO.deleteCustomer(...);   
// select all customers in the same city   
Customer criteria $\varepsilon$ new Customer();   
criteria.setCity("New York");   
Collection customersList $=$   
custDAO.selectCustomersVO(criteria);   
// returns customersList - collection of Customer // value objects. iterate through this collection to // get values.  

// 查找客户对象并获取值对象  
Customer cust = custDAO.findCustomer(...);  
// 修改值对象中的属性值  
cust.setAddress(...);  
cust.setEmail(...);  
// 通过DAO更新客户对象  
custDAO.updateCustomer(cust);  
// 删除客户对象  
custDAO.deleteCustomer(...);  
// 查询同一城市的所有客户  
Customer criteria = new Customer();  
criteria.setCity("New York");  
Collection customersList =   
custDAO.selectCustomersVO(criteria);  
// 返回customersList - 由Customer值对象组成的集合  
// 遍历该集合以获取具体值

# Related Patterns  

# Value Object  

A DAO uses value objects to transport data to and from its clients.  

DAO 使用值对象在客户端之间传输数据。

# Factory Method [GoF] and Abstract Factory [GoF]  

The Factory for Data Access Objects Strategy uses the Factory Method pattern to implement the concrete factories and its products (DAOs). For added flexibility, the Abstract Factory pattern may be employed as discussed in the strategies.  

数据访问对象工厂策略采用工厂方法模式来实现具体工厂及其产品（DAO）。为增强灵活性，亦可如策略部分所述采用抽象工厂模式。

# Broker [POSA1]  

The DAO pattern is related to the Broker pattern, which describes approaches for decoupling clients and servers in distributed systems. The DAO pattern more specifically applies this pattern to decouple the resource tier from clients in another tier, such as the business or presentation tier.  

DAO模式与Broker模式相关，后者描述了在分布式系统中解耦客户端和服务端的方法。DAO模式更具体地将该模式应用于解耦资源层与其他层（如业务层或表示层）中的客户端。

# Service Activator  

# Context  

Enterprise beans and other business services need a way to be activated asynchronously.  

企业级Bean及其他业务服务需要支持异步激活的机制。

# Problem  

When a client needs to access an enterprise bean, it first looks up the bean's home object. The client requests the EJB home to provide a remote reference to the required enterprise bean. The client then invokes business method calls on the remote reference to access the enterprise bean services. All these method calls, such as lookup and remote method calls, are synchronous. The client has to wait until these methods return.  

当客户端需要访问企业级Bean时，首先会查找该Bean的Home对象。客户端请求EJB Home提供所需企业级Bean的远程引用，随后通过该远程引用调用业务方法以访问企业级Bean服务。所有这些方法调用（如查找操作和远程方法调用）都是同步的，客户端必须等待这些方法返回结果。

Another factor to consider is the life cycle of an enterprise bean. The EJB specification permits the container to passivate an enterprise bean to secondary storage. As a result, the EJB container has no mechanism by which it can provide a process-like service to keep an enterprise bean constantly in an activated and ready state. Because the client must interact with the enterprise bean using the bean's remote interface, even if the bean is in an activated state in the container, the client still needs to obtain its remote interface via the lookup process and still interacts with the bean in a synchronous manner.  

另一个需要考虑的因素是企业级 Bean 的生命周期。EJB 规范允许容器将企业级 Bean 钝化到二级存储。因此，EJB 容器无法提供类似进程的服务来使企业级 Bean 始终保持激活就绪状态。由于客户端必须通过 Bean 的远程接口与企业级 Bean 交互，即便该 Bean 在容器中处于激活状态，客户端仍需通过查找流程获取其远程接口，并以同步方式与 Bean 进行交互。

If an application needs synchronous processing for its server-side business components, then enterprise beans are an appropriate choice. Some application clients may require asynchronous processing for the server-side business objects because the clients do not need to wait or do not have the time to wait for the  

若应用程序需对其服务端业务组件进行同步处理，则企业级Bean是恰当的选择。某些应用客户端可能需要对服务端业务对象进行异步处理，因为客户端无需等待或没有时间等待

processing to complete. In cases where the application needs a form of asynchronous processing, enterprise beans do not offer this capability in implementations prior to EJB 2.0.  

处理完成。在应用程序需要某种异步处理的情况下，EJB 2.0 之前版本的企业级 Bean 实现不提供此功能。

EJB 2.0 provides integration by introducing message-driven bean, which is a special type of stateless session bean that offers asynchronous invocation capabilities. However, the new specification does not offer asynchronous invocation for other types of enterprise beans, such as stateful or entity beans.  

EJB 2.0通过引入消息驱动Bean实现了集成，这是一种特殊的无状态会话Bean，具备异步调用能力。然而，该新规范并未为其他类型的企业级Bean（如有状态Bean或实体Bean）提供异步调用功能。

In general, a business service such as a session or entity bean provides only synchronous processing and thus presents a challenge to implementing asynchronous processing.  

通常而言，诸如会话Bean或实体Bean之类的业务服务仅提供同步处理，因此对实现异步处理提出了挑战。

# Forces  

Enterprise beans are exposed to their clients via their remote interfaces, which allow only synchronous access.   
The container manages enterprise beans, allowing interactions only via the remote references. The EJB container does not allow direct access to the bean implementation and its methods. Thus, implementing the JMS   
message listener in an enterprise bean is not feasible, since this violates the EJB specification by permitting direct access to the bean implementation. An application needs to provide a publish/subscribe or point-to-point messaging framework where clients can publish requests to enterprise beans for asynchronous processing.   
Clients need asynchronous processing capabilities from the enterprise beans and other business components that can only provide synchronous access, so that the client can send a request for processing without waiting for the results.   
Clients want to use the message-oriented middleware (MOM) interfaces offered by the Java Messaging Service (JMS). These interfaces are not integrated into EJB server products that are based on the pre-EJB 2.0 specification.   
An application needs to provide daemon-like service so that an enterprise bean can be in a quiet mode until an event (or a message) triggers its activity.   
Enterprise beans are subject to the container life cycle management, which includes passivation due to time-outs, inactivity and resource management. The client will have to invoke on an enterprise bean to activate it again. EJB 2.0 introduces a message-driven bean as a stateless session bean, but it is not possible to invoke other types of enterprise beans asynchronously.  

企业级Bean通过其远程接口向客户端暴露，该接口仅允许同步访问。  
容器负责管理企业级Bean，仅允许通过远程引用进行交互。EJB容器不允许直接访问Bean实现及其方法。因此，在企业级Bean中实现JMS消息监听器不可行，因为这违反了EJB规范中禁止直接访问Bean实现的规定。应用程序需要提供发布/订阅或点对点消息框架，使客户端能向企业级Bean发布请求以实现异步处理。  

客户端需要从企业级Bean及其他仅支持同步访问的业务组件获取异步处理能力，从而无需等待结果即可发送处理请求。  
客户端希望使用Java消息服务(JMS)提供的面向消息中间件(MOM)接口。这些接口未集成到基于EJB 2.0之前规范的EJB服务器产品中。  

应用程序需提供守护进程式服务，使企业级Bean可保持静默状态，直到事件（或消息）触发其活动。  
企业级Bean受容器生命周期管理约束，包括因超时、闲置和资源管理导致的钝化。客户端必须重新调用企业级Bean以激活它。EJB 2.0引入了作为无状态会话Bean的消息驱动Bean，但无法异步调用其他类型的企业级Bean。

# Solution  

# Use a Service Activator to receive asynchronous client requests and messages. On receiving a message, the Service Activator locates and invokes the necessary business methods on the business service components to fulfill the request asynchronously.  

The ServiceActivator is a JMS Listener and delegation service that requires implementing the JMS message listener—making it a JMS listener object that can listen to JMS messages. The ServiceActivator can be implemented as a standalone service. Clients act as the message generator, generating events based on their activity.  

ServiceActivator 是一种兼具 JMS 监听器与委托服务功能的组件，其实现需遵循 JMS 消息监听器接口——这使得它成为能够监听 JMS 消息的监听器对象。该组件可作为独立服务进行实现。客户端作为消息生成方，根据其业务活动产生事件消息。

Any client that needs to asynchronously invoke a business service, such as an enterprise bean, may create and send a message to the Service Activator. The Service Activator receives the message and parses it to interpret the client request. Once the client's request is parsed or unmarshalled, the Service Activator identifies and locates the necessary business service component and invokes business methods to complete processing of the client's request asynchronously.  

任何需要异步调用业务服务（如企业级Bean）的客户端均可创建消息并发送至服务激活器。服务激活器接收消息后对其进行解析以理解客户端请求。当客户端请求被解析或反序列化后，服务激活器将识别并定位所需的业务服务组件，通过异步调用业务方法完成客户端请求的处理。

The Service Activator may optionally send an acknowledgement to the client after successfully completing the request processing. The Service Activator may also notify the client or other services on failure events if it fails to complete the asynchronous request processing.  

服务激活器在成功完成请求处理后，可选择性地向客户端发送确认通知。若未能完成异步请求处理，服务激活器亦可向客户端或其他服务发送失败事件通知。

The Service Activator may use the services of a Service Locator to locate a business component. See “Service Locator”.  

服务激活器（Service Activator）可通过**服务定位器**（Service Locator）定位业务组件。具体参见“服务定位器”章节。

# Structure  

Figure 9.9 represents the class relationships for the Service Activator pattern.  

图9.9展示了服务激活器模式的类关系图。

# Figure 9.9. Service Activator class diagram  

![](images/2f218be28c97a358b01096e80d04fa9e71e4653572eb1f6cf807b8414dff1c48.jpg)  

# Participants and Responsibilities  

Figure 9.10 shows the interactions between the various participants in the Service Activator pattern.  

图9.10展示了服务激活器模式中各参与者间的交互关系。

![](images/ba0ee40cac5ee7a2967ab68d87c3faedf8056d3fefafb9133225f6176d1f0776.jpg)  
Figure 9.10. Service Activator sequence diagram  

图9.10 服务激活器时序图

# Client  

The client requires an asynchronous processing facility from the business objects participating in a workflow. The client can be any type of application that has the capability to create and send JMS messages. The client can also be an EJB component that needs to invoke another EJB component's business methods in an asynchronous manner. The client can use the services offered by the Service Locator pattern to look up or create EJB components, JMS services, and JMS objects, as necessary.  

客户端要求参与工作流的业务对象提供异步处理能力。客户端可以是任何能够创建和发送JMS消息的应用程序类型，也可以是需要以异步方式调用另一个EJB组件业务方法的EJB组件。客户端可根据需要使用服务定位器模式提供的服务来查找或创建EJB组件、JMS服务及JMS对象。

# Request  

The Request is the message object created by the client and sent to the ServiceActivator via the MOM. According to the JMS specification, the Request is an object that implements the javax.jms.Message interface. The JMS API provides several message types, such as TextMessage, ObjectMessage, and so forth, that can be used as request objects.  

**Request** 是由客户端创建并通过MOM发送至ServiceActivator的消息对象。根据JMS规范，Request是一个实现了`javax.jms.Message`接口的对象。JMS API提供了多种消息类型（例如`TextMessage`、`ObjectMessage`等），均可作为请求对象使用。

# ServiceActivator  

The ServiceActivator is the main class of the pattern. It implements the javax.jms.MessageListener interface, which is defined by the JMS specification. The ServiceActivator implements an onMessage() method that is invoked when a new message arrives. The ServiceActivator parses (unmarshals) the message (request) to determine what needs to be done. The ServiceActivator may use the services offered by a Service Locator (see Service Locator) pattern to look up or create Business Service components such as enterprise beans.  

`ServiceActivator`是该模式的主类，它实现了JMS规范定义的`javax.jms.MessageListener`接口。该组件通过实现`onMessage()`方法来响应新消息到达事件，并对消息（请求）进行解析（反序列化）以确定后续操作。`ServiceActivator`可借助**服务定位器**（参见Service Locator模式）提供的服务来查找或创建业务服务组件（例如企业级Bean）。

# BusinessObject  

BusinessObject is the target object to which the client needs access in an asynchronous mode. The business object is a role fulfilled by either a session or entity bean. It is also possible that the BusinessObject is an external service instead of an entity bean.  

BusinessObject 是客户端需要以异步模式访问的目标对象。该业务对象角色可由会话 Bean 或实体 Bean 实现，也可能由外部服务而非实体 Bean 承担。

# Strategies  

# Entity Bean Strategy  

Both session and entity beans can fulfill the role of a BusinessObject. When J2EE applications implement a Session Fa ade pattern to provide coarse-grained access to entity beans and to encapsulate the workflow, then the session bean from the Session Fa ade fulfills the BusinessObject role.  

会话Bean和实体Bean均可承担业务对象（BusinessObject）的角色。当J2EE应用程序采用**会话门面（Session Facade）**模式来提供对实体Bean的粗粒度访问并封装工作流时，该会话门面中的会话Bean即履行业务对象的职责。

In simple applications with minimal workflow, an entity bean may fulfill the BusinessObject role. However, for complex workflow involving multiple entity beans and other business objects, the ServiceActivator typically interacts with a Session Facade which encapsulates such workflow.  

在业务流程简单的轻量级应用中，实体Bean可承担业务对象（BusinessObject）的角色。但对于涉及多个实体Bean及其他业务对象的复杂业务流程，**ServiceActivator**通常通过与封装此类流程的**会话门面（Session Facade）**进行交互。

# Session Bean Strategy  

When a session bean fulfills the role of the BusinessObject, the business requirements determine whether the bean should be stateful or stateless. Since the client for the BusinessObject is a ServiceActivator that activates the BusinessObject on receiving a new message, the workflow to process the message can define whether the bean should be stateful or not. In most cases, a message delivery simply activates a single method in the BusinessObject that delegates the processing of the message within. A stateless session bean can be used in these cases. If the ServiceActivator needs to invoke multiple methods in the BusinessObject or to work with more than one BusinessObject to fulfill the processing requirements for a message, it may be useful to consider a stateful session bean to retain state between multiple invocations. See “Stateless Session Facade Strategy” and “Stateful Session Facade Strategy”.  

当会话Bean（Session Bean）承担业务对象（BusinessObject）角色时，业务需求决定了该Bean应设计为有状态（stateful）还是无状态（stateless）。由于业务对象的客户端是ServiceActivator（在接收到新消息时激活业务对象），消息处理的工作流程可定义Bean的状态需求。大多数情况下，消息传递仅需激活业务对象中的单一方法，由该方法内部委托处理消息，此时使用无状态会话Bean即可。若ServiceActivator需要调用业务对象的多个方法，或协同多个业务对象完成消息处理，则考虑采用有状态会话Bean以在多次调用间保持状态。参见“无状态会话门面策略”与“有状态会话门面策略”。

# ServiceActivator Server Strategy  

The most straightforward strategy for implementing the listener or ServiceActivator is as a standalone JMS application that listens and processes JMS messages.  

实现监听器或ServiceActivator最直接的策略是将其作为独立的JMS应用程序，用于监听并处理JMS消息。

An alternative is to implement the ServiceActivator as a service of the application server. This may make it easier to manage the ServiceActivator, because it uses the application server features to monitor the ServiceActivator state and to start, restart, and stop the ServiceActivator as needed, either manually or automatically.  

另一种方案是将 `ServiceActivator` 实现为应用服务器的服务。这可以简化对 `ServiceActivator` 的管理，因为它能利用应用服务器的功能来监控其状态，并根据需要手动或自动启动、重启及停止该服务。

# Enterprise Bean as Client Strategy  

The Client can be any client, including another enterprise bean that requires asynchronous processing from the enterprise bean. When integrating legacy applications to the J2EE platform, it is logical to choose Java application clients to act as the message generators based on the activity in the legacy system. The ServiceActivator can receive messages and perform the necessary enterprise bean invocations to process the request from the legacy system.  

客户端可以是任意客户端，包括需要从企业级Bean获取异步处理的其他企业级Bean。在将遗留系统集成至J2EE平台时，基于遗留系统的活动特性，选择Java应用客户端作为消息生成器是符合逻辑的。ServiceActivator能够接收消息，并通过执行必要的企业级Bean调用来处理来自遗留系统的请求。

# Consequences  

# Integrates JMS into Pre-EJB 2.0 Implementations  

Prior to the EJB 2.0 specification, there was no integration between enterprise bean and JMS components. This pattern provides a means to integrate JMS into an EJB application and enable asynchronous processing. The EJB 2.0 specification defines a new type of session bean, called a message-driven bean, to integrate JMS and EJB components. This special bean implements the JMS Message Listener interface and it receives asynchronous messages. In this case, the application server plays the role of the Service Activator. This pattern makes it possible to run applications in EJB 2.0 implementations as well as pre-EJB 2.0 implementations.  

在EJB 2.0规范之前，企业级Bean与JMS组件之间缺乏集成机制。该模式提供了将JMS集成至EJB应用并实现异步处理的方法。EJB 2.0规范定义了一种新型会话Bean——消息驱动Bean（Message-Driven Bean），用于整合JMS与EJB组件。这种特殊Bean实现了JMS Message Listener接口，可接收异步消息。此时应用服务器承担了服务激活器（Service Activator）的角色。该模式使得应用既能运行于EJB 2.0实现环境，也能兼容EJB 2.0之前的实现版本。

# Provides Asynchronous Processing for any Enterprise Beans  

In EJB 2.0, the message-driven bean is a stateless session bean. Using the Service Activator pattern, it is possible to provide asynchronous invocation on all types of enterprise beans, including stateless session beans, stateful session beans, and entity beans. As previously explained, since the Service Activator is implemented in its own right, without any limitations of the message-driven bean, the Service Activator can perform asynchronous invocations on any type of business service. Thus, this pattern provides a way to enable asynchronous processing for clients that either have no need to wait for the results or do not want to wait for processing to complete. The processing can be deferred and performed at a later time, enabling the client to complete the service in less time.  

在EJB 2.0中，消息驱动Bean属于无状态会话Bean。通过采用服务激活器模式，可以为所有类型的企业级Bean（包括无状态会话Bean、有状态会话Bean以及实体Bean）提供异步调用能力。如前所述，由于服务激活器本身是独立实现的，不受消息驱动Bean的任何限制，因此该模式能够对任意类型的业务服务执行异步调用。这种模式为客户端提供了一种异步处理机制，适用于既不需要等待结果也不希望等待处理完成的场景。处理过程可被延迟并在后续执行，从而使客户端能以更短时间完成服务调用。

# Standalone Process  

The Service Activator can be run as a standalone process. However, in a critical application, Service Activator needs to be monitored to ensure availability. The additional management and maintenance of this process can add to application support overhead.  

服务激活器可作为独立进程运行。但在关键应用中，需监控服务激活器以确保其可用性。该进程的额外管理和维护会增加应用支持的开销。

# Sample Code  

Consider an order processing application where the customers shop online and the order fulfillment process happens in the background. In some cases, order fulfillment may be outsourced to a third-party warehouse. In such cases, the online store needs to invoke these fulfillment services asynchronously. This is an example that demonstrates usage of point-to-point (PTP) messaging to accomplish asynchronous processing. However, using publish/subscribe messaging would be similar, except that Topic is used instead of a Queue. Choosing which method to use, PTP or publish/subscribe, depends on the business and application requirements, and hence is outside the scope of this pattern.  

考虑一个订单处理应用程序，客户在线购物，订单履行流程在后台进行。在某些情况下，订单履行可能外包给第三方仓库。此时，在线商店需要异步调用这些履行服务。此示例展示了如何使用点对点（PTP）消息传递来实现异步处理。不过，若采用发布/订阅消息传递，其原理类似，只是用Topic替代了Queue。选择使用PTP还是发布/订阅取决于业务和应用程序需求，因此不属于本模式的讨论范畴。

The class diagram with only the relevant methods for this example is shown in Figure 9.11.  

仅包含本示例相关方法的类图如图9.11所示。

![](images/00bbd24b79e5d823a8dc75aa7f51eb5744234ff98ccc796e70487b22ddd216a7.jpg)  
Figure 9.11. Service Activator for Order Processing example – class diagram  

图 9.11  订单处理服务激活器示例——类图

The code excerpt shown in Example 9.7 demonstrates a sample Service Activator implementation. This is the class that can be instantiated in an application server or run in a stand-alone server, as explained in the Service Activator Server strategy.  

示例9.7所示的代码片段展示了一个Service Activator实现样例。如Service Activator Server策略所述，该实现类可在应用服务器中实例化，或运行于独立服务器环境。

# Example 9.7 Order Service Activator  

public class OrderServiceActivator implements javax.jms.MessageListener{  

public class OrderServiceActivator implements javax.jms.MessageListener{

// Queue session and receiver: see JMS API for // details private QueueSession orderQueueSession; private QueueReceiver orderQueueReceiver;  

// 队列会话与接收器：详见JMS API  
private QueueSession orderQueueSession;  
private QueueReceiver orderQueueReceiver;

// Note: values should come from property files or   
// environment instead of hard coding.   
private String connFactoryName $=$ "PendingOrdersQueueFactory";   
private String queueName $=$ "PendingOrders";   
// use a service locator to locate administered   
// JMS components such as a Queue or a Queue   
// Connection factory   
private JMSServiceLocator serviceLocator;   
public OrderServiceActivator(String connFactoryName, String queueName) { super(); this.connFactoryName $=$ connFactoryName; this.queueName $=$ queueName; startListener();   
private void startListener() { try { serviceLocator $=$ new JMSServiceLocator (connFactoryName); qConnFactory $=$ serviceLocator.getQueueConnectionFactory(); qConn $=$ qConnFactory.createQueueConnection(); // See JMS API for method usage and arguments orderQueueSession $=$ qConn.createQueueSession   
(...); Queue ordersQueue $=$ serviceLocator.getQueue(queueName); orderQueueReceiver $=$ orderQueueSession.createReceiver(ordersQueue); orderQueueReceiver.setMessageListener(this); } catch (JMSException excp) { // handle error }   
// The JMS API specifies the onMessage method in the   
// javax.jms.MessageListener interface.   
// This method is asynchronously invoked   
// when a message arrives on the Queue being   
// listened to by the ServiceActivator.   
// See JMS Specification and API for more details.   
public void onMessage(Message msg) { try { // parse Message msg. See JMS API for Message. // Invoke business method on an enterprise // bean using the bean's business delegate. // OrderProcessorDelegate is the business // delegate for OrderProcessor Session bean. // See Business Delegate pattern for details. OrderProcessorDelegate orderProcDeleg $=$ new OrderProcessorDelegate(); // Use data values from the parsed message to // invoke business method on bean via delegate orderProcDeleg.fulfillOrder(...); // send any acknowledgement here... catch (JMSException jmsexcp) { // Handle JMSExceptions, if any } catch (Exception excp) { // Handle any other exceptions   
public void close() { try { // cleanup before closing orderQueueReceiver.setMessageListener (null); orderQueueSession.close(); } catch(Exception excp) { // Handle exception - Failure to close  

// 注意：这些值应从属性文件或环境变量中获取，而非硬编码  
private String connFactoryName $=$ "PendingOrdersQueueFactory";  
private String queueName $=$ "PendingOrders";  
// 使用服务定位器来查找托管的JMS组件，  
// 例如队列或队列连接工厂  
private JMSServiceLocator serviceLocator;  

public OrderServiceActivator(String connFactoryName, String queueName) {  
    super();  
    this.connFactoryName $=$ connFactoryName;  
    this.queueName $=$ queueName;  
    startListener();  
}  

private void startListener() {  
    try {  
        serviceLocator $=$ new JMSServiceLocator(connFactoryName);  
        qConnFactory $=$ serviceLocator.getQueueConnectionFactory();  
        qConn $=$ qConnFactory.createQueueConnection();  
        // 关于方法用法和参数顺序，请参阅JMS API  
        orderQueueSession $=$ qConn.createQueueSession(...);  
        Queue ordersQueue $=$ serviceLocator.getQueue(queueName);  
        orderQueueReceiver $=$ orderQueueSession.createReceiver(ordersQueue);  
        orderQueueReceiver.setMessageListener(this);  
    } catch (JMSException excp) {  
        // 错误处理  
    }  
}  

// JMS API在javax.jms.MessageListener接口中定义了onMessage方法。  
// 当ServiceActivator监听的队列有消息到达时，  
// 该方法会被异步调用。  
// 更多细节请参阅JMS规范和API。  
public void onMessage(Message msg) {  
    try {  
        // 解析Message msg。关于Message请参阅JMS API。  
        // 通过企业Bean的业务委托调用业务方法。  
        // OrderProcessorDelegate是OrderProcessor Session Bean的业务委托。  
        // 详情请参阅业务委托模式。  
        OrderProcessorDelegate orderProcDeleg $=$ new OrderProcessorDelegate();  
        // 使用解析后的消息数据值，通过委托调用Bean的业务方法  
        orderProcDeleg.fulfillOrder(...);  
        // 在此发送任何确认...  
    } catch (JMSException jmsexcp) {  
        // 处理JMSExceptions（如有）  
    } catch (Exception excp) {  
        // 处理其他异常  
    }  
}  

public void close() {  
    try {  
        // 关闭前进行清理  
        orderQueueReceiver.setMessageListener(null);  
        orderQueueSession.close();  
    } catch(Exception excp) {  
        // 处理异常 - 关闭失败  
    }  
}

This example demonstrates using the Business Delegate pattern between business and integration tiers. OrderProcessorDelegate logically resides in the integration tier and accesses the Order Processor session bean, which resides in the business tier.  

本示例展示了在业务层与集成层之间使用**业务委托模式**（Business Delegate）。OrderProcessorDelegate逻辑上位于集成层，并访问业务层中的Order Processor会话Bean。

The sample session facade code responsible to dispatch orders to this asynchronous service is shown in the code excerpt in Example 9.8. The Service Activator client can be a session bean that implements the Session Fa ade pattern to provide order processing services to the online store application. When the session bean's createOrder() method is called, after successfully validating and creating a new order, it invokes sendOrder() to dispatch the new order to the backend order fulfillment service.  

示例会话门面代码负责将订单分派给该异步服务，其代码片段如示例9.8所示。Service Activator客户端可以是一个实现会话门面模式的Session Bean，用于为在线商店应用提供订单处理服务。当调用该会话Bean的createOrder()方法时，在成功验证并创建新订单后，该方法会调用sendOrder()将新订单分派至后端订单履行服务。

# Example 9.8 Session Facade as Client for Service Activator  

// imports...   
public class OrderDispatcherFacade implements javax.ejb.SessionBean { // business method to create new Order public int createOrder(...) throws OrderException { // create new business order entity bean successfully created Order. send Order to // asynchronous backend processing OrderSender orderSender $=$ new OrderSender(); orderSender.sendOrder(order); // close the sender, if done... orderSender.close(); // other processing  

// imports...   
public class OrderDispatcherFacade implements javax.ejb.SessionBean { // 创建新订单的业务方法  
public int createOrder(...) throws OrderException { // 成功创建新的业务订单实体Bean  
Order. 将订单发送至  
// 异步后端处理  
OrderSender orderSender = new OrderSender();  
orderSender.sendOrder(order);  
// 处理完成后关闭发送器...  
orderSender.close();  
// 其他处理

The JMS code can be separated into a different class so that it can be reused by different clients. This JMS delegate class is shown as OrderSender in the Example 9.9 code listing.  

JMS代码可被分离至独立类中，以便不同客户端复用。如示例9.9代码清单所示，该JMS委托类命名为OrderSender。

# Example 9.9 OrderSender: Used to Dispatch Orders to Queue  

// imports...   
ublic class OrderSender {   
// Queue session and sender: see JMS API for detail   
private QueueSession orderQueueSession;   
private QueueSender orderQueueSender;   
// These values could come from some property files   
private String connFactoryName $=$ "PendingOrdersQueueFactory";   
private String queueName $=$ "PendingOrders";   
// use a service locator to locate administered   
// JMS components such as a Queue or a Queue.   
// Connection factory   
private JMSServiceLocator serviceLocator;   
// method to initialize and create queue sender   
private void createSender() { try { // using ServiceLocator and getting Queue // Connection Factory is similar to the // Service Activator code. serviceLocator $=$ new JMSServiceLocator (connFactoryName); qConnFactory $=$ serviceLocator.getQueueConnectionFactory(); qConn $=$ qConnFactory.createQueueConnection(); // See JMS API for method usage and arguments orderQueueSession $=$ qConn.createQueueSession (...); Queue ordersQueue $=$ serviceLocator.getQueue(queueName); orderQueueSender $=$ orderQueueSession.createSender(ordersQueue); catch(Exception excp) { // Handle exception - Failure to create sender  

```java
// imports...  
public class OrderSender {  
    // 队列会话与发送器：详见JMS API  
    private QueueSession orderQueueSession;  
    private QueueSender orderQueueSender;  
    // 这些值可从属性文件读取  
    private String connFactoryName = "PendingOrdersQueueFactory";  
    private String queueName = "PendingOrders";  
    // 使用服务定位器获取托管JMS组件  
    // 如队列或队列连接工厂  
    private JMSServiceLocator serviceLocator;  

    // 初始化并创建队列发送器的方法  
    private void createSender() {  
        try {  
            // 使用ServiceLocator获取队列连接工厂  
            // 与服务激活器代码逻辑类似  
            serviceLocator = new JMSServiceLocator(connFactoryName);  
            qConnFactory = serviceLocator.getQueueConnectionFactory();  
            qConn = qConnFactory.createQueueConnection();  
            // 方法参数详见JMS API  
            orderQueueSession = qConn.createQueueSession(...);  
            Queue ordersQueue = serviceLocator.getQueue(queueName);  
            orderQueueSender = orderQueueSession.createSender(ordersQueue);  
        } catch(Exception excp) {  
            // 异常处理 - 发送器创建失败  
        }  
    }  
```

// method to dispatch order to fulfillment service // for asynchronous processing public void sendOrder(Order newOrder) {  

// 将订单分发给履约服务进行异步处理的方法  
public void sendOrder(Order newOrder) {

// create a new Message to send Order object ObjectMessage objMessage $=$ queueSession.createObjectMessage(order); // set object message properties and delivery // mode as required. // See JMS API for ObjectMessage // Set the Order into the object message objMessage.setObject(order); // send the message to the Queue orderQueueSender.send(objMessage); } catch (Exception e) { // Handle exceptions } public void close() { try { // cleanup before closing orderQueueReceiver.setMessageListener (null); orderQueueSession.close(); } catch(Exception excp) { // Handle exception - Failure to close  

// 创建要发送Order对象的新消息  
ObjectMessage objMessage = queueSession.createObjectMessage(order);  
// 按需设置对象消息属性和传递模式  
// 详情参阅JMS API中ObjectMessage部分  
// 将Order对象设置到消息中  
objMessage.setObject(order);  
// 向队列发送消息  
orderQueueSender.send(objMessage);  
} catch (Exception e) {  
    // 异常处理  
}  

public void close() {  
    try {  
        // 关闭前清理  
        orderQueueReceiver.setMessageListener(null);  
        orderQueueSession.close();  
    } catch(Exception excp) {  
        // 处理关闭失败异常  
    }

# Related Patterns  

# Session Facade  

The Session Facade pattern encapsulates the complexity of the system and provides coarse-grained access to business objects. This Service Activator pattern may access a Session Fa ade as the primary business object to  

会话外观模式封装了系统的复杂性，并为业务对象提供粗粒度访问。该服务激活器模式可将会话外观作为主要业务对象进行访问。

invoke business service methods in the Session Fa ade asynchronously on behalf of the client.  

代表客户端异步调用Session Facade中的业务服务方法。

# Business Delegate  

The Service Activator pattern may use a Business Delegate to access the Session Fa ade or other enterprise bean implementations. This results in simpler code for the Service Activator and results in Business Delegate reuse across different tiers, as intended by the Business Delegate pattern.  

服务激活器模式可通过业务委托（Business Delegate）访问会话门面（Session Facade）或其他企业级Bean实现。这种设计既简化了服务激活器的代码结构，又实现了业务委托模式的核心目标——使业务委托能在不同层级间复用。

# Service Locator  

The client can use the Service Locator pattern to look up and create JMS-related service objects. The Service Activator can use the Service Locator pattern to look up and create enterprise bean components.  

客户端可通过**服务定位器模式**查找并创建JMS相关服务对象。**服务激活器**则可利用该模式定位并创建企业级Bean组件。

# Half-Sync/Half-Async [POSA2]  

The Service Activator pattern is related to the Half-Sync/Half-Async pattern, which describes architectural decoupling of synchronous and asynchronous processing by suggesting different layers for synchronous, asynchronous and an intermediate queueing layer inbetween.  

服务激活器模式与半同步/半异步模式相关，后者通过建议采用同步层、异步层及中间队列层来实现同步与异步处理的架构解耦。

# Epilogue J2EE PATTERNS APPLIED  

# Topics in This Chapter  

• PSA Overview   
• Use Case Model   
• Use Cases, Patterns, and Pattern Frameworks   
• Create Project Use Case   
• Reserve Resource Use Case   
• Find Available Resources Use Case  

• PSA概述  
• 用例模型  
• 用例、模式与模式框架  
• 创建项目用例  
• 预留资源用例  
• 查找可用资源用例

In this chapter we present an example of using the J2EE patterns in an application. Our experiences have shown us that using the pattern catalog can improve the efficiency and quality of your software development process. It is important to understand how to leverage the pattern catalog, and that's what we illustrate in this chapter. Leveraging the pattern catalog does not in itself require a new development process or a new methodology. Rather, it shows how to integrate the patterns in the catalog into your present design process or approach, so that your approach improves and produces a better, more robust solution.  

本章将通过实际应用案例展示J2EE模式的使用。我们的实践经验表明，合理运用模式目录能显著提升软件开发效率与质量。关键在于掌握如何有效利用模式目录，这正是本章要阐述的核心内容。需要强调的是，运用模式目录本身并不需要引入新的开发流程或方法论，而是指导如何将目录中的模式整合到现有设计流程中，从而优化现有方案，最终构建出更健壮、更完善的系统解决方案。

This chapter shows you a sampling of ways to apply the patterns to real-world examples. We go directly to the patterns and pattern realizations to describe how the patterns are applied to an example. We want to emphasize that these ideas are a sampling of many possibilities. They are meant to get you thinking creatively with the patterns. You will benefit by applying approaches similar to ours, and you will gain confidence in applying the patterns to your own design problems in new and unique ways.  

本章将通过实际案例示范如何应用这些模式。我们将直接切入模式及其实现，阐述如何将模式应用于示例场景。需要强调的是，这些方案仅是众多可能性中的示例，旨在启发您创造性地运用模式。通过借鉴类似方法，您不仅能获得收益，更能以新颖独特的方式将这些模式灵活应用于自身的设计难题中，从而建立应用信心。

# PSA Overview  

This example deals with the domain of professional services automation, also known as PSA. PSA is a set of software and services used by professional services organizations to help operate more effectively. PSA may cover a wide range of processes, including project bidding and team, skill, project, and customer management.  

本示例涉及专业服务自动化（PSA）领域。PSA是一套供专业服务机构使用的软件与服务，旨在提升运营效率。其涵盖的流程范围广泛，包括项目投标、团队管理、技能管理、项目管理及客户管理等环节。

Our intention with this example is to address a small set of basic requirements of a professional services organization. The PSA system must be flexible, providing different services based on the particular role of the user.  

本示例旨在满足专业服务组织的一小部分基础需求。该PSA系统必须具备灵活性，能够根据用户的具体角色提供差异化服务。

Project managers will search the PSA system for matching resources, check on the availability of a particular resource, and schedule an available resource for a specific project. Consultants (hereafter known as “resources”) accept and manage their assignments, their availability, and the listing of their current skill set. Project administrators are “super” project managers, as they can act on behalf of a project manager. In addition, they perform administrative tasks, such as creating new projects and managing the care and feeding of project information over its lifetime.  

项目经理将在PSA系统中搜索匹配的资源，检查特定资源的可用性，并为特定项目安排可用资源。顾问（以下简称“资源”）接受并管理其任务分配、可用性及当前技能清单。项目管理员是“超级”项目经理，可代表项目经理执行操作。此外，他们还负责执行行政任务，例如创建新项目，以及在项目生命周期内维护和管理项目信息。

Each of the three roles share common functional requirements:  

这三个角色均具有以下共同功能需求：

Searching based on projects, resources, skills. • Managing resource information (address, email, phone, etc.). Other packaged and ad hoc reports and queries.  

基于项目、资源和技能进行搜索  
• 管理资源信息（地址、电子邮件、电话等）  
其他打包报表和即席查询

# Use Case Model  

The following use case model is derived from the functional requirements for the PSA application. In the model, we've identified the following actors for the PSA application, as shown in Table E-1.  

以下用例模型源自PSA应用程序的功能需求。在该模型中，我们已识别出PSA应用程序的参与者，如表E-1所示。

Figure E.1 shows the use case model for the PSA application.   

图E.1展示了PSA应用程序的用例模型。


<html><body><table><tr><td colspan="2">TableE-1.PSAActors</td></tr><tr><td>Actor</td><td>Description</td></tr><tr><td>Resource</td><td>An employee who can be assigned to work on a project.</td></tr><tr><td>ProjectManager</td><td>An employee who can be assigned to manage and execute a project.</td></tr><tr><td>Administrator</td><td>An employee who provides administrative support to the PS organization.</td></tr><tr><td>Resource Manager</td><td>An employee who is responsible to manage a group of resources.</td></tr></table></body></html>  

<html><body><table><tr><td colspan="2">表E-1.PSA参与者</td></tr><tr><td>参与者</td><td>描述</td></tr><tr><td>资源</td><td>可被分配参与项目工作的员工。</td></tr><tr><td>项目经理</td><td>可被分配管理和执行项目的员工。</td></tr><tr><td>管理员</td><td>为PS组织提供行政支持的员工。</td></tr><tr><td>资源经理</td><td>负责管理一组资源的员工。</td></tr></table></body></html>

![](images/06329d207d44d7d04bedb9eb7e8bcc7e0b7851f8d20c73f89e25a2e3b2528739.jpg)  
Figure E.1. Use case model  

图 E.1. 用例模型

# Use Cases, Patterns, and Pattern Frameworks  

In this section we apply the patterns based on the use cases. The goal of this section is to focus on the realized patterns, not the process from which we arrived at the pattern selection. The approach we take is to show the pattern framework and then the realized pattern framework. We define a pattern framework as a set of patterns commonly used in combination to solve a problem.  

本节将基于用例应用相关模式。本部分的重点在于已实现的模式，而非模式选择的过程推导。我们的方法是先展示模式框架，再呈现其具体实现。所谓模式框架，是指为解决问题而经常组合使用的一组模式。

We are confident that as you see these examples and begin applying the J2EE patterns to your solutions, you will be able to quickly identify the proper patterns.  

我们确信，当您看到这些示例并开始将J2EE模式应用到您的解决方案中时，您将能够快速识别出合适的模式。

# Create Project Use Case  

In this use case, the administrator creates a project. See Figure E.2. The project contains information such as the start and end dates, customer name, and skills required.  

在本用例中，管理员创建项目（参见图E.2）。项目包含开始日期、结束日期、客户名称及所需技能等信息。

![](images/90f647e2db8372f47fe27432b6274164914683d8259882cf0436a5664c68dd4d.jpg)  
Figure E.2. Create Project use case  

图 E.2. 创建项目用例

# Pattern Identification  

We use the following presentation patterns:  

我们采用以下表示模式：

• Intercepting Filter—  A filter checks user privileges for creating a project.   
• Front Controller—  A controller acts as the initial point of contact for generating the form for project creation, and subsequently handles submission of this form. The controller delegates project creation-related processing to its helpers, which in turn delegate much of this processing to the business tier. View Helper—  The view delegates to its helpers in order to generate dynamic portions of the display. Composite View—  The view includes a header and a footer to create the Create Project page. This is a very simple example of a composite view.  

• **拦截过滤器**——过滤器负责校验用户创建项目的权限。  
• **前端控制器**——控制器作为初始接触点，生成项目创建表单并处理后续表单提交。该控制器将项目创建相关处理委托给辅助组件，后者再将大部分处理逻辑转交给业务层。  
• **视图助手**——视图通过委托其助手组件来生成动态显示内容。  
• **组合视图**——该视图通过包含页眉和页脚构建出"创建项目"页面，这是组合视图的一个极简示例。  

（注：严格遵循技术术语一致性，保留"Filter"、"Controller"、"View"等核心模式名称不翻译，符合J2EE设计模式规范）

We use the following business patterns:  

我们采用以下业务模式：

Business Delegate—  A business delegate interacts with the business tier for creating a project.   
Service Locator—  A business delegate uses a service locator to look up the project components.   
Session Facade—  The business delegate interacts with a session bean, which interacts with the project entity when creating a project.   
Value Object—  A project value object encapsulates the project data, which is passed from the presentation tier to the business tier.  

业务委托（Business Delegate）—— 业务委托与业务层交互以创建项目。  
服务定位器（Service Locator）—— 业务委托通过服务定位器查找项目组件。  
会话门面（Session Facade）—— 业务委托与会话Bean交互，后者在创建项目时与项目实体交互。  
值对象（Value Object）—— 项目值对象封装项目数据，这些数据从表示层传递至业务层。

We use the following integration pattern:  

我们采用以下集成模式：

Data Access Object—  A data access object abstracts and encapsulates access to the project tables.  

数据访问对象（Data Access Object）—— 一种对项目表访问进行抽象与封装的对象。

Figure E.3 shows the pattern framework for the Create Project use case. It shows the patterns used in presentation, business, and integration.  

图E.3展示了创建项目用例的模式框架，呈现了在表示层、业务层和集成层中使用的模式。

![](images/503d5cf28d439ba5661c4e9aa38f077f23aed3a4c3986f3b58030402ba46f579.jpg)  
Figure E.3. Create Project pattern framework  

图 E.3. 创建项目模式框架

# Pattern Realization  

Figure E.4 shows the realized patterns for the Create Project use case. This diagram provides a breakdown by tiers. The following list matches the name of an implementation class with the pattern from which it is realized  

图E.4展示了"创建项目"用例的实现模式。该图表按分层架构进行了分解。以下列表将实现类名称与其对应的实现模式进行匹配。

Presentation—The Create Project form is shown in Figure E.5.  

呈现层——创建项目表单如图E.5所示。

<html><body><table><tr><td>Class</td><td>Pattern</td></tr><tr><td>LoginCheckFilter</td><td>Intercepting Filter</td></tr><tr><td>PSAController</td><td>Front Controller</td></tr><tr><td>CreateProject, header, footer</td><td>CompositeView</td></tr><tr><td>Project View,current Date, list Customers</td><td>ViewHelper</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr><tr><td>LoginCheckFilter</td><td>拦截过滤器</td></tr><tr><td>PSAController</td><td>前端控制器</td></tr><tr><td>CreateProject, header, footer</td><td>组合视图</td></tr><tr><td>Project View,current Date, list Customers</td><td>视图助手</td></tr></table></body></html>

Business  

业务

<html><body><table><tr><td>Class</td><td>Pattern</td></tr><tr><td>ProjectDelegate</td><td>BusinessDelegate</td></tr><tr><td>PSAServiceLocator</td><td>ServiceLocator</td></tr><tr><td>ProjectManagerSession</td><td>SessionFacade</td></tr><tr><td>ProjectEntity</td><td>SessionFacade</td></tr><tr><td>ProjectVO</td><td>ValueObject</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr><tr><td>ProjectDelegate</td><td>BusinessDelegate</td></tr><tr><td>PSAServiceLocator</td><td>ServiceLocator</td></tr><tr><td>ProjectManagerSession</td><td>SessionFacade</td></tr><tr><td>ProjectEntity</td><td>SessionFacade</td></tr><tr><td>ProjectVO</td><td>ValueObject</td></tr></table></body></html>

Integration  

集成

<html><body><table><tr><td>Class</td><td>Pattern</td></tr><tr><td>ProjectDAO</td><td>Data Access Object</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr><tr><td>ProjectDAO</td><td>数据访问对象</td></tr></table></body></html>

# Figure E.4. Create Project realized patterns  

![](images/12f255a12a0ac0f6c8c9a9d1234de63074e456ada7e54a83940ccf8a0a8797dd.jpg)  
Figure E.5. Create Project Form  

图 E.5. 创建项目表单

![](images/ae46ac661d041f8921e4e184d3295a0347991fa47500e31288ea58bc023b8a9c.jpg)  

# Reserve Resource Use Case  

In the Reserve Resource use case, the project manager must reserve a resource for use on a project. See Figure E.6. The reservation is comprised of a length of time and a number of hours per week. After the resource is reserved, the resource manager must approve him. Once the resource manager approves the resource, the resource is officially assigned to the project.  

在预留资源用例中，项目经理必须为项目预留某项资源。参见图E.6。预留内容包括时间跨度及每周使用小时数。资源完成预留后，需经资源经理审批通过。资源经理核准后，该资源即被正式分配至项目。

![](images/9263193d2491c419a16ce001aa5d1bd6787902a3395e5142d38c3b306c55d510.jpg)  
Figure E.6. Reserve Resource use case  

图 E.6 预留资源用例

# Pattern Identification  

Figure E.7 contains the pattern framework for the Reserve Resource use case. It shows the patterns used in presentation, business, and integration. We use the following presentation patterns:  

图E.7展示了"资源预留"用例的模式框架，其中包含表示层、业务层和集成层采用的设计模式。在表示层我们应用了以下模式：

Intercepting Filter—  A filter checks user privileges for reserving a resource. Front Controller—  A controller acts as the initial point of contact for reserving a resource. The controller delegates resource reservation-related processing to its helpers, which in turn delegate much of this processing to the business tier. View Helper—  The view delegates to its helpers in order to generate dynamic portions of the display. Composite View—  The view includes a header and a footer to create the Reserve Resource page. This is a very simple example of a composite view.  

拦截过滤器（Intercepting Filter）——过滤器负责检查用户对资源预留的权限。  
前端控制器（Front Controller）——控制器作为资源预留的初始接触点，将资源预留相关处理委托给辅助组件，这些辅助组件进而将大部分处理逻辑委托给业务层。  
视图助手（View Helper）——视图通过委托给其助手组件来生成动态显示内容。  
组合视图（Composite View）——该视图通过包含页眉和页脚来构建资源预留页面，这是组合视图的一个极简示例。

We use the following business patterns:  

我们采用以下业务模式：

Business Delegate—  A business delegate interacts with the business tier for reserving a resource.   
Service Locator—  A business delegate uses a service locator to look up the resource components.   
Session Facade—  The business delegate interacts with a session bean, which interacts with the project entity when reserving a resource.  

业务委托（Business Delegate）—— 业务委托通过与业务层交互来预留资源。  
服务定位器（Service Locator）—— 业务委托通过服务定位器查找资源组件。  
会话门面（Session Facade）—— 业务委托与会话Bean交互，该会话Bean在预留资源时与项目实体进行交互。

Value Object—  A commitment value object encapsulates the commitment data, which is passed from the presentation tier to the business tier. Composite Entity—  A project entity acts as a coarse-grained object to the dependent commitment objects.  

值对象（Value Object）——承诺值对象封装了从表示层传递至业务层的承诺数据。  
组合实体（Composite Entity）——项目实体作为粗粒度对象，管理其依赖的承诺对象。

We use the following integration patterns:  

我们采用以下集成模式：

Data Access Object—  A data access object abstracts and encapsulates access to the resource and commitment tables.  

数据访问对象（Data Access Object）—— 一种对资源及事务表的访问进行抽象与封装的对象。

![](images/7d36b96919ab5e3832907d1acd210a8ddcd98b7d2f7d19fae23f806eb4ca6806.jpg)  
Figure E.7. Reserve Resource pattern framework  

图 E.7. 资源预留模式框架

# Pattern Realization  

Figure Figure E.8 shows the realized patterns for the Reserve Resource use case. The following list matches the name of an implementation class with the pattern from which it is realized  

图E.8展示了"预留资源"用例的实现模式。以下列表将实现类名称与其对应的实现模式进行匹配

Presentation—The Reserve Resource form is shown in Figure E.9.  

呈现层——储备资源表单如图E.9所示。

<html><body><table><tr><td>Class</td><td>Pattern</td></tr><tr><td>LoginCheckFilter</td><td>Intercepting Filter</td></tr><tr><td>PSAController</td><td>FrontController</td></tr><tr><td>ReserveResourceForm,header, footer</td><td>CompositeView</td></tr><tr><td>ReserveResourceForm,F ResourceHelper</td><td>ViewHelper</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr><tr><td>LoginCheckFilter</td><td>拦截过滤器</td></tr><tr><td>PSAController</td><td>前端控制器</td></tr><tr><td>ReserveResourceForm,header, footer</td><td>组合视图</td></tr><tr><td>ReserveResourceForm,F ResourceHelper</td><td>视图助手</td></tr></table></body></html>

Business  

业务

<html><body><table><tr><td>Class</td><td>Pattern</td></tr><tr><td>ProjectDelegate</td><td>BusinessDelegate</td></tr><tr><td>PSAServiceLocator</td><td>ServiceLocator</td></tr><tr><td>ProjectManagerSession</td><td>SessionFacade</td></tr><tr><td>ProjectEntity</td><td>Session Facade, Composite Entity</td></tr><tr><td>Commitment</td><td>Composite Entity</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr><tr><td>ProjectDelegate</td><td>业务委托模式</td></tr><tr><td>PSAServiceLocator</td><td>服务定位器模式</td></tr><tr><td>ProjectManagerSession</td><td>会话门面模式</td></tr><tr><td>ProjectEntity</td><td>会话门面模式、组合实体模式</td></tr><tr><td>Commitment</td><td>组合实体模式</td></tr></table></body></html>

<html><body><table><tr><td>CommitmentVO</td><td>ValueObject</td></tr></table></body></html>  

<html><body><table><tr><td>CommitmentVO</td><td>值对象</td></tr></table></body></html>

Integration  

集成

<html><body><table><tr><td>Class</td><td>Pattern</td></tr><tr><td>ProjectDAO</td><td>DataAccess Object</td></tr><tr><td>CommitmentsDAO</td><td>DataAccess Object</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr><tr><td>ProjectDAO</td><td>数据访问对象</td></tr><tr><td>CommitmentsDAO</td><td>数据访问对象</td></tr></table></body></html>

# • Figure E.8. Reserve Resource realized patterns  

![](images/ff1a2b34f09a5dd2d82911c341ddb525940e0835d8b2f5974719a7675d06b156.jpg)  
Figure E.9. Reserve Resources Form  

图 E.9. 资源预留表单

![](images/64567e466b9b1391ae230000efcd25cf6c25540675e8db62d5fa4dfea67adf62.jpg)  

# Find Available Resources Use Case  

In the Find Available Resources use case, the project manager searches for available resources for a project by start date, end date, and skills. See Figure E.10.  

在"查找可用资源"用例中，项目经理通过开始日期、结束日期和技能条件搜索项目的可用资源。参见图E.10。

![](images/e1ec85b272aa7634d2b07e3448e0ddaaf0f3a38589dd7ca3e7599720a24899dd.jpg)  
Figure E.10. Reserve Resource use case  

图 E.10. 预留资源用例

# Pattern Identification  

For this use case, we use the following presentation patterns:  

针对该用例，我们采用以下表示层模式：

Intercepting Filter—  A filter checks user privileges for searching for available resources.  

拦截过滤器——该过滤器用于检查用户搜索可用资源的权限。

Front Controller—  A controller acts as the initial point of contact for searching for resources. The controller delegates resource availabilityrelated processing to its helpers, which in turn delegate much of this processing to the business tier.   
View Helper—  The view delegates to its helpers in order to generate dynamic portions of the display.   
Composite View—  The view includes a header and a footer to create the search for available resources page. This is a very simple example of a composite view.  

前端控制器——控制器作为查找资源的初始接触点，将资源可用性相关的处理委托给其辅助组件，这些辅助组件进而将大部分处理逻辑转交给业务层。  

视图助手——视图通过委托给其助手组件来生成动态显示内容。  

组合视图——视图通过包含页眉和页脚来构建资源搜索页面，这是组合视图的一个极简示例。

We use the following business patterns:  

我们采用以下业务模式：

Business Delegate—  A business delegate interacts with the business tier when searching for available resources.   
Service Locator—  A business delegate uses a service locator to look up the resource components.   
Session Facade—  The business delegate interacts with a session bean, which interacts with the list handler when searching for available resources. Value Object—  The commitment value object encapsulates the   
commitment data, which is passed from the presentation tier to the business tier.   
Composite Entity—  A project entity acts as a coarse-grained object to the dependent commitment objects.   
Value List Handler—  A value list handler controls the lookup, cache, and iteration of the resources.  

业务委托（Business Delegate）—— 业务委托通过与业务层交互来搜索可用资源。  
服务定位器（Service Locator）—— 业务委托通过服务定位器查找资源组件。  
会话门面（Session Facade）—— 业务委托与会话Bean交互，后者在搜索可用资源时与值列表处理器（Value List Handler）协作。  
值对象（Value Object）—— 承诺值对象封装了从表示层传递至业务层的承诺数据。  
组合实体（Composite Entity）—— 项目实体作为粗粒度对象管理其依赖的承诺对象。  
值列表处理器（Value List Handler）—— 负责控制资源的查询、缓存及遍历操作。

We use the following integration patterns:  

我们采用以下集成模式：

Data Access Object—  A data access object abstracts and encapsulates access to commitments and resource tables.  

数据访问对象（Data Access Object）—— 一种对承诺和资源表访问进行抽象与封装的对象。

Figure E.11 is the pattern framework for the Find Available Resources use case. It shows the patterns used in presentation, business, and integration.  

图E.11展示了"查找可用资源"用例的模式框架，其中呈现了表示层、业务层和集成层所采用的设计模式。

# Figure E.11. Find Available Resources pattern framework  

![](images/964d2d699ec7255b1f337f11265b2577cf00c6083d0f4e5eda28628d6fec2e23.jpg)  

# Pattern Realization  

Figure E.12 shows the realized patterns for the Find Available Resources use case. The following list matches the name of an implementation class with the pattern from which it is realized:  

图E.12展示了"查找可用资源"用例的实现模式。以下列表将实现类名称与其对应的实现模式进行匹配：

• Presentation—The Find Available Resources form is shown in Figure E.13.  

• 表示层——"查找可用资源"表单如图E.13所示。

<html><body><table><tr><td>Class</td><td>Pattern</td></tr><tr><td>LoginCheckFilter</td><td>Intercepting Filter</td></tr><tr><td>PSAController</td><td>FrontController</td></tr><tr><td>FindAvailableResourcesForm,ResourceHelper</td><td>ViewHelper</td></tr><tr><td>FindAvailableResourcesForm,header,footer</td><td>CompositeView</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr><tr><td>LoginCheckFilter</td><td>拦截过滤器</td></tr><tr><td>PSAController</td><td>前端控制器</td></tr><tr><td>FindAvailableResourcesForm,ResourceHelper</td><td>视图助手</td></tr><tr><td>FindAvailableResourcesForm,header,footer</td><td>组合视图</td></tr></table></body></html>

Business  

业务

<html><body><table><tr><td>Class</td><td>Pattern</td></tr><tr><td>ResourceDelegate</td><td>BusinessDelegate</td></tr><tr><td>PSAServiceLocator</td><td>ServiceLocator</td></tr><tr><td>ResourceAdminSession</td><td>Session Facade</td></tr><tr><td>ResourceListHandler, ResourcesList</td><td>ValueListHandler</td></tr><tr><td>ResourceVO</td><td>ValueObject</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr><tr><td>ResourceDelegate</td><td>业务委托</td></tr><tr><td>PSAServiceLocator</td><td>服务定位器</td></tr><tr><td>ResourceAdminSession</td><td>会话门面</td></tr><tr><td>ResourceListHandler, ResourcesList</td><td>值列表处理器</td></tr><tr><td>ResourceVO</td><td>值对象</td></tr></table></body></html>

Integration  

集成

<html><body><table><tr><td>Class</td><td>Pattern</td></tr></table></body></html>  

<html><body><table><tr><td>类</td><td>模式</td></tr></table></body></html>

# Figure E.12. Find Available Resources realized  

patterns  

模式

![](images/78f939a44e68f1ef7717d8532d5bb683030e68e7136316e300519c63bccfdeda.jpg)  

# Figure E.13. Find Available Resources Form  

![](images/67b40a1f486815e4349ef325a666868b870c0e7592cac00daf3d5c767671a948.jpg)  

![](images/3f825abef6c39156359d44ade451e3b070ab6bf6cabf9799bfd7e5f72a9f000c.jpg)  

# BIBLIOGRAPHY  

[Alex] Christopher Alexander, “The Timeless Way of Building”, Oxford University Press, New York, 1979  

[Alex] 克里斯托弗·亚历山大，《建筑的永恒之道》，牛津大学出版社，纽约，1979年

[Alex2] Christopher Alexander Sara Ishikawa Murray Silverstein Max Jacobson Ingrid Fiksdahl-King Shlomo Angel “A Pattern Language”, Oxford University Press, New York, 1977  

[Alex2] 克里斯托弗·亚历山大 莎拉·伊势崎 穆雷·西尔弗斯坦 马克斯·雅各布森 英格丽·菲克斯达尔-金 什洛莫·安杰尔 《模式语言》，牛津大学出版社，纽约，1977年

[Arnold] Ken Arnold David Holmes James Gosling “The Java Programming Language, Third Edition: The Java Series”, Addison Wesley, 2000  

[Arnold] Ken Arnold David Holmes James Gosling 《Java编程语言（第三版）：Java系列》，Addison Wesley，2000年

[Bergsten] Hans Bergsten, “JavaServer Pages”, O'Reilly & Associates, Inc., 2001.  

[Bergsten] Hans Bergsten，《JavaServer Pages》，O'Reilly & Associates, Inc.，2001年。

[Booch] Grady Booch James Rumbaugh Ivar Jacobson “The Unified Modeling Language User Guide”, Addison Wesley, 1998.  

[Booch] Grady Booch、James Rumbaugh、Ivar Jacobson 合著《统一建模语言用户指南》，Addison Wesley 出版社，1998年。

[Brown] William H. Brown Raphael C. Malveau Hays W. "Skip" McCormick III Thomas J. Mowbray “Anti-Patterns: Refactoring Software, Architectures and Projects in Crisis”, Wiley Press, 1998  

[美]威廉·H·布朗 拉斐尔·C·马尔沃 海斯·W·"斯基普"·麦考密克三世 托马斯·J·莫布雷 著  
《反模式：危机中的软件重构、架构与项目治理》，威立出版社，1998年

[Coplien] Jim O. Coplien, Douglas C. Schmidt (Editors), “Pattern Languages of Program Design”, Addison Wesley, 1995  

[Coplien] Jim O. Coplien, Douglas C. Schmidt (编), 《程序设计的模式语言》, Addison Wesley, 1995

[Fowler] Martin Fowler, “Refactorings - Improving the Design Of Existing Code”, Addison Wesley, 1999  

[Fowler] Martin Fowler，《重构——改善既有代码的设计》，Addison Wesley，1999年

[Fowler2] Martin Fowler, “Analysis Patterns: Reusable Object Models”, Addison Wesley, 1997  

[Fowler2] Martin Fowler，《分析模式：可复用的对象模型》，Addison Wesley，1997年

[Fowler3] Martin Fowler Kendall Scott “UML Distilled : A Brief Guide to the Standard Object Modeling Language, Second Edition”, Addison Wesley, 2000.  

[Fowler3] Martin Fowler、Kendall Scott 《UML精粹：标准对象建模语言简明指南（第二版）》，Addison Wesley，2000年。

[Gabriel] Richard P. Gabriel, “Patterns of Software: Tales from the Software Community”, Oxford University Press, 1998  

[Gabriel] Richard P. Gabriel，《软件模式：来自软件社区的故事》，牛津大学出版社，1998年

[Geary] David M. Geary, “Advanced JavaServer Pages”, Sun Microsystems Press/Prentice Hall PTR, 2001  

[Geary] David M. Geary，《高级JavaServer Pages》，Sun Microsystems Press/Prentice Hall PTR，2001年

[GoF] Erich Gamma Richard Helm Ralph Johnson John Vlissides “Design Patterns: Elements of Reusable Object-Oriented Software”, Addison Wesley, 1994  

[GoF] Erich Gamma Richard Helm Ralph Johnson John Vlissides 《设计模式：可复用面向对象软件的基础》，Addison Wesley，1994年

[Gosling] James Gosling Bill Joy Guy Steele Gilad Bracha “The Java Language Specification, Second Edition: The Java Series”, Addison Wesley, 2000  

[Gosling] James Gosling、Bill Joy、Guy Steele、Gilad Bracha 合著《Java语言规范（第二版）：Java系列》，Addison Wesley出版社，2000年

[Haefel] Richard Monson-Haefel, “Enterprise JavaBeans, Second Edition”, O'Reilly & Associates, Inc., 2000  

[Haefel] Richard Monson-Haefel，《企业级JavaBeans（第二版）》，O'Reilly & Associates, Inc.，2000年

[Harrison] Niel Harrison, Brian Foote and Hans Rohnert (Editors), “Pattern Languages of Program Design 4”, Addison Wesley, 1999  

[Harrison] Niel Harrison、Brian Foote 和 Hans Rohnert（编者），《程序设计的模式语言 4》，Addison Wesley，1999 年

[Jacobsen] Ivar Jacobson Magnus Christerson Patrik Jonsson Gunnar Overgaard “Object-Oriented Software Engineering-A Use Case Driven Approach”, Addison-Wesley, ACM Press, 1992-98  

[Jacobsen] Ivar Jacobson Magnus Christerson Patrik Jonsson Gunnar Overgaard 《面向对象软件工程——用例驱动方法》，Addison-Wesley，ACM Press，1992-98

[POSA1] Frank Buschmann Regine Meunier Hans Rohnert Peter Sommerlad Michael Stal “Pattern-Oriented Software Architecture-A System of patterns”, Wiley Press, 1996-2000  

[POSA1] Frank Buschmann、Regine Meunier、Hans Rohnert、Peter Sommerlad、Michael Stal 合著《面向模式的软件架构——模式系统》，Wiley出版社，1996-2000年

[POSA2] Douglas Schmidt Michael Stal Hans Rohnert Frank Buschmann “Pattern-Oriented Software Architecture-Volume 2: Patterns for Concurrent and Networked Objects”, Wiley Press, 2000  

[POSA2] Douglas Schmidt、Michael Stal、Hans Rohnert、Frank Buschmann 合著《面向模式的软件架构 卷2：并发与联网对象模式》，Wiley出版社，2000年

[Shannon] Bill Shannon Mark Hapner Vlada Matena James Davidson Eduardo Pelegri-Llopart Larry Cable and the Enterprise Team, “Java 2 Platform, Enterprise Edition: Platform and Component Specifications”, Addison Wesley, 2000  

[Shannon] Bill Shannon、Mark Hapner、Vlada Matena、James Davidson、Eduardo Pelegri-Llopart、Larry Cable及企业级团队 著，《Java 2平台企业版：平台与组件规范》，Addison Wesley出版社，2000年

[Martin] Robert Martin, Dirk Riehle, and Frank Buschmann (Editors), “Pattern Languages of Program Design $^{3^{\prime\prime}}$ , Addison Wesley, 1998  

[Martin] Robert Martin、Dirk Riehle 和 Frank Buschmann（编者），《程序设计的模式语言 $^{3^{\prime\prime}}$》，Addison Wesley，1998年

[Rosenberg] Doug Rosenberg Kendall Scott “Use Case Driven Object Modeling with UML”, Addison Wesley, 1999.  

[罗森伯格] 道格·罗森伯格 肯德尔·斯科特 《UML用例驱动对象建模》，艾迪生韦斯利出版社，1999年。

[Rumbaugh] James Rumbaugh Ivar Jacobson Grady Booch “The Unified Modeling Language Reference Manual”, Addison Wesley, 1999.  

[Rumbaugh] James Rumbaugh Ivar Jacobson Grady Booch 《UML参考手册》，Addison Wesley，1999年。

[Vlissides] John M. Vlissides, Jim O. Coplien, and Norman L. Kerth (Editors), “Pattern Languages of Program Design $^{2^{\prime\prime}}$ Addison Wesley, 1996  

[Vlissides] John M. Vlissides、Jim O. Coplien 和 Norman L. Kerth（编者），《程序设计的模式语言 $^{2^{\prime\prime}}$》，Addison Wesley，1996 年

[Vlissides2] John Vlissides, “Pattern Hatching: Design Patterns Applied”, Addison Wesley, 1998  

[Vlissides2] John Vlissides，《设计模式应用：模式孵化》，Addison Wesley，1998年

# Online References  

[EJBHome] Enterprise Java Beans (EJB) Home Page and Specification  

[EJBHome] 企业级Java Beans (EJB) 主页与规范

http://java.sun.com/products/ejb/  

http://java.sun.com/products/ejb/

# EJB 2.0 (Final Draft) Specification:  

http://java.sun.com/products/ejb/2.0.html  

http://java.sun.com/products/ejb/2.0.html

[Hillside] Hillside.net - Patterns Home Page http://hillside.net/patterns  

[Hillside] Hillside.net - 模式主页 http://hillside.net/patterns

[JakartaTaglibs] The Jakarta “Taglibs” Project http://www.jakarta.apache.org/taglibs/index.htm  

[JakartaTaglibs] Jakarta "标签库"项目 http://www.jakarta.apache.org/taglibs/index.htm

[JavaHome] Java Home Page http://java.sun.com  

[JavaHome] Java 主页 http://java.sun.com

[J2EEHome] Java 2 Enterprise Edition (J2EE) Home Page http://java.sun.com/j2ee/  

[J2EEHome] Java 2 企业版 (J2EE) 主页 http://java.sun.com/j2ee/

[JDBCHome] Java Database Connectivity (JDBC) Technology Home page and   
Specification   
http://java.sun.com/products/jdbc/   
[JNDIHome] Java Naming and Directory Interface (JNDI) Home page and   
Specification   
http://java.sun.com/products/jndi/  

[JDBCHome] Java数据库连接(JDBC)技术主页与规范  
http://java.sun.com/products/jdbc/  
[JNDIHome] Java命名与目录接口(JNDI)主页与规范  
http://java.sun.com/products/jndi/

[JSPHome] Java Server Pages (JSP) Home page and Specification http://java.sun.com/products/jsp/  

[JSP主页] Java Server Pages (JSP) 主页与规范 http://java.sun.com/products/jsp/

[JMSHome] Java Message Service (JMS) Home page and Specification http://java.sun.com/products/jms/  

[JMS主页] Java消息服务(JMS) 主页及规范 http://java.sun.com/products/jms/

[Portland] The Portland Pattern Repository http://www.c2.com/cgi/wiki?PortlandPatternRepository  

[波特兰] 波特兰模式仓库 http://www.c2.com/cgi/wiki?PortlandPatternRepository

[Resonate]  

[共鸣]

http://www.resonate.com  

http://www.resonate.com

[ServletHome] Java Servlet Technology Home page and Specification http://java.sun.com/products/servlet/  

[ServletHome] Java Servlet 技术主页与规范 http://java.sun.com/products/servlet/

[Struts] http://jakarta.apache.org/struts/index.html  

[Struts] http://jakarta.apache.org/struts/index.html

# [TS1341] Daniel Malks and Deepak Alur, “Prototyping Patterns for the J2EE Platform”, JavaOne 2000, San Francisco  

http://jsp.java.sun.com/javaone/javaone2000/event.jsp?eventId=1341  

http://jsp.java.sun.com/javaone/javaone2000/event.jsp?eventId=1341
